-- ------------------------------------------------------
-- ------------------------------------------------------
--
-- WPBackItUp Database Export 
--
-- Created: 2016/11/02 on 09:13
--
-- Database : blog
--
-- Backup   Table  : bg_posts
-- Snapshot Table  : 1478106789_posts
--
-- SQL    : SELECT * FROM bg_posts LIMIT 0,10000
-- Offset : 0
-- Rows   : 46
-- ------------------------------------------------------
-- ------------------------------------------------------
SET AUTOCOMMIT = 0 ;
SET FOREIGN_KEY_CHECKS=0 ;

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Table structure for table `1478106789_posts`
--
DROP TABLE  IF EXISTS `1478106789_posts`;
CREATE TABLE `1478106789_posts` (
  `ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `post_author` bigint(20) unsigned NOT NULL DEFAULT '0',
  `post_date` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_date_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content` longtext COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_title` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_excerpt` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_status` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'publish',
  `comment_status` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'open',
  `ping_status` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'open',
  `post_password` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
  `post_name` varchar(200) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
  `to_ping` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `pinged` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_modified` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_modified_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content_filtered` longtext COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_parent` bigint(20) unsigned NOT NULL DEFAULT '0',
  `guid` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
  `menu_order` int(11) NOT NULL DEFAULT '0',
  `post_type` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'post',
  `post_mime_type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
  `comment_count` bigint(20) NOT NULL DEFAULT '0',
  PRIMARY KEY (`ID`),
  KEY `post_name` (`post_name`(191)),
  KEY `type_status_date` (`post_type`,`post_status`,`post_date`,`ID`),
  KEY `post_parent` (`post_parent`),
  KEY `post_author` (`post_author`)
) ENGINE=InnoDB AUTO_INCREMENT=121 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;



--
-- Data for table `bg_posts`
-- Number of rows: 46
--
INSERT INTO `1478106789_posts` VALUES 
(7,1,'2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gXHU3ZjI5XHU3NTY1XHU1NmZlIFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJpbWFnZSJdLCJwcmV2aWV3X2ltYWdlX3JlbHBhdGgiOiJcL25leHRnZW4tZ2FsbGVyeVwvcHJvZHVjdHNcL3Bob3RvY3JhdGlfbmV4dGdlblwvbW9kdWxlc1wvbmV4dGdlbl9iYXNpY19nYWxsZXJ5XC9zdGF0aWNcL3RodW1iX3ByZXZpZXcuanBnIiwiZGVmYXVsdF9zb3VyY2UiOiJnYWxsZXJpZXMiLCJ2aWV3X29yZGVyIjoxMDAwMCwiYWxpYXNlcyI6WyJiYXNpY190aHVtYm5haWwiLCJiYXNpY190aHVtYm5haWxzIiwibmV4dGdlbl9iYXNpY190aHVtYm5haWxzIl0sIm5hbWUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfdGh1bWJuYWlscyIsImluc3RhbGxlZF9hdF92ZXJzaW9uIjoiMi4xLjU2IiwiaWRfZmllbGQiOiJJRCIsInNldHRpbmdzIjp7InVzZV9saWdodGJveF9lZmZlY3QiOnRydWUsImltYWdlc19wZXJfcGFnZSI6IjIwIiwibnVtYmVyX29mX2NvbHVtbnMiOjAsInRodW1ibmFpbF93aWR0aCI6MjQwLCJ0aHVtYm5haWxfaGVpZ2h0IjoxNjAsInNob3dfYWxsX2luX2xpZ2h0Ym94IjowLCJhamF4X3BhZ2luYXRpb24iOjAsInVzZV9pbWFnZWJyb3dzZXJfZWZmZWN0IjowLCJ0ZW1wbGF0ZSI6IiIsImRpc3BsYXlfbm9faW1hZ2VzX2Vycm9yIjoxLCJkaXNhYmxlX3BhZ2luYXRpb24iOjAsInNob3dfc2xpZGVzaG93X2xpbmsiOjEsInNsaWRlc2hvd19saW5rX3RleHQiOiJbXHU2NjNlXHU3OTNhXHU1ZTdiXHU3MDZmXHU3MjQ3XSIsIm92ZXJyaWRlX3RodW1ibmFpbF9zZXR0aW5ncyI6MCwidGh1bWJuYWlsX3F1YWxpdHkiOiIxMDAiLCJ0aHVtYm5haWxfY3JvcCI6MSwidGh1bWJuYWlsX3dhdGVybWFyayI6MCwibmdnX3RyaWdnZXJzX2Rpc3BsYXkiOiJuZXZlciJ9LCJoaWRkZW5fZnJvbV91aSI6ZmFsc2UsImhpZGRlbl9mcm9tX2lndyI6ZmFsc2UsIl9fZGVmYXVsdHNfc2V0Ijp0cnVlfQ==','NextGEN 缩略图 基础版','','draft','closed','closed','','','','','2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gXHU3ZjI5XHU3NTY1XHU1NmZlIFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJpbWFnZSJdLCJwcmV2aWV3X2ltYWdlX3JlbHBhdGgiOiJcL25leHRnZW4tZ2FsbGVyeVwvcHJvZHVjdHNcL3Bob3RvY3JhdGlfbmV4dGdlblwvbW9kdWxlc1wvbmV4dGdlbl9iYXNpY19nYWxsZXJ5XC9zdGF0aWNcL3RodW1iX3ByZXZpZXcuanBnIiwiZGVmYXVsdF9zb3VyY2UiOiJnYWxsZXJpZXMiLCJ2aWV3X29yZGVyIjoxMDAwMCwiYWxpYXNlcyI6WyJiYXNpY190aHVtYm5haWwiLCJiYXNpY190aHVtYm5haWxzIiwibmV4dGdlbl9iYXNpY190aHVtYm5haWxzIl0sIm5hbWUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfdGh1bWJuYWlscyIsImluc3RhbGxlZF9hdF92ZXJzaW9uIjoiMi4xLjU2IiwiaWRfZmllbGQiOiJJRCIsInNldHRpbmdzIjp7InVzZV9saWdodGJveF9lZmZlY3QiOnRydWUsImltYWdlc19wZXJfcGFnZSI6IjIwIiwibnVtYmVyX29mX2NvbHVtbnMiOjAsInRodW1ibmFpbF93aWR0aCI6MjQwLCJ0aHVtYm5haWxfaGVpZ2h0IjoxNjAsInNob3dfYWxsX2luX2xpZ2h0Ym94IjowLCJhamF4X3BhZ2luYXRpb24iOjAsInVzZV9pbWFnZWJyb3dzZXJfZWZmZWN0IjowLCJ0ZW1wbGF0ZSI6IiIsImRpc3BsYXlfbm9faW1hZ2VzX2Vycm9yIjoxLCJkaXNhYmxlX3BhZ2luYXRpb24iOjAsInNob3dfc2xpZGVzaG93X2xpbmsiOjEsInNsaWRlc2hvd19saW5rX3RleHQiOiJbXHU2NjNlXHU3OTNhXHU1ZTdiXHU3MDZmXHU3MjQ3XSIsIm92ZXJyaWRlX3RodW1ibmFpbF9zZXR0aW5ncyI6MCwidGh1bWJuYWlsX3F1YWxpdHkiOiIxMDAiLCJ0aHVtYm5haWxfY3JvcCI6MSwidGh1bWJuYWlsX3dhdGVybWFyayI6MCwibmdnX3RyaWdnZXJzX2Rpc3BsYXkiOiJuZXZlciJ9LCJoaWRkZW5fZnJvbV91aSI6ZmFsc2UsImhpZGRlbl9mcm9tX2lndyI6ZmFsc2UsIl9fZGVmYXVsdHNfc2V0Ijp0cnVlfQ==',0,'https://blog-scottwang.rhcloud.com/?post_type=display_type&p=7',0,'display_type','',0),
 (8,1,'2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gXHU1ZTdiXHU3MDZmXHU3MjQ3IFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJpbWFnZSJdLCJwcmV2aWV3X2ltYWdlX3JlbHBhdGgiOiJcL25leHRnZW4tZ2FsbGVyeVwvcHJvZHVjdHNcL3Bob3RvY3JhdGlfbmV4dGdlblwvbW9kdWxlc1wvbmV4dGdlbl9iYXNpY19nYWxsZXJ5XC9zdGF0aWNcL3NsaWRlc2hvd19wcmV2aWV3LmpwZyIsImRlZmF1bHRfc291cmNlIjoiZ2FsbGVyaWVzIiwidmlld19vcmRlciI6MTAwMTAsImFsaWFzZXMiOlsiYmFzaWNfc2xpZGVzaG93IiwibmV4dGdlbl9iYXNpY19zbGlkZXNob3ciXSwibmFtZSI6InBob3RvY3JhdGktbmV4dGdlbl9iYXNpY19zbGlkZXNob3ciLCJpbnN0YWxsZWRfYXRfdmVyc2lvbiI6IjIuMS41NiIsImlkX2ZpZWxkIjoiSUQiLCJzZXR0aW5ncyI6eyJ1c2VfbGlnaHRib3hfZWZmZWN0Ijp0cnVlLCJnYWxsZXJ5X3dpZHRoIjo2MDAsImdhbGxlcnlfaGVpZ2h0Ijo0MDAsInRodW1ibmFpbF93aWR0aCI6MjQwLCJ0aHVtYm5haWxfaGVpZ2h0IjoxNjAsImN5Y2xlX2ludGVydmFsIjoxMCwiY3ljbGVfZWZmZWN0IjpudWxsLCJlZmZlY3RfY29kZSI6ImNsYXNzPVwibmdnLWZhbmN5Ym94XCIgcmVsPVwiJUdBTExFUllfTkFNRSVcIiIsInNob3dfdGh1bWJuYWlsX2xpbmsiOjEsInRodW1ibmFpbF9saW5rX3RleHQiOiJbXHU2NjNlXHU3OTNhXHU3ZjI5XHU3NTY1XHU1NmZlXSIsInRlbXBsYXRlIjoiIiwibmdnX3RyaWdnZXJzX2Rpc3BsYXkiOiJuZXZlciJ9LCJoaWRkZW5fZnJvbV91aSI6ZmFsc2UsImhpZGRlbl9mcm9tX2lndyI6ZmFsc2UsIl9fZGVmYXVsdHNfc2V0Ijp0cnVlfQ==','NextGEN 幻灯片 基础版','','draft','closed','closed','','','','','2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gXHU1ZTdiXHU3MDZmXHU3MjQ3IFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJpbWFnZSJdLCJwcmV2aWV3X2ltYWdlX3JlbHBhdGgiOiJcL25leHRnZW4tZ2FsbGVyeVwvcHJvZHVjdHNcL3Bob3RvY3JhdGlfbmV4dGdlblwvbW9kdWxlc1wvbmV4dGdlbl9iYXNpY19nYWxsZXJ5XC9zdGF0aWNcL3NsaWRlc2hvd19wcmV2aWV3LmpwZyIsImRlZmF1bHRfc291cmNlIjoiZ2FsbGVyaWVzIiwidmlld19vcmRlciI6MTAwMTAsImFsaWFzZXMiOlsiYmFzaWNfc2xpZGVzaG93IiwibmV4dGdlbl9iYXNpY19zbGlkZXNob3ciXSwibmFtZSI6InBob3RvY3JhdGktbmV4dGdlbl9iYXNpY19zbGlkZXNob3ciLCJpbnN0YWxsZWRfYXRfdmVyc2lvbiI6IjIuMS41NiIsImlkX2ZpZWxkIjoiSUQiLCJzZXR0aW5ncyI6eyJ1c2VfbGlnaHRib3hfZWZmZWN0Ijp0cnVlLCJnYWxsZXJ5X3dpZHRoIjo2MDAsImdhbGxlcnlfaGVpZ2h0Ijo0MDAsInRodW1ibmFpbF93aWR0aCI6MjQwLCJ0aHVtYm5haWxfaGVpZ2h0IjoxNjAsImN5Y2xlX2ludGVydmFsIjoxMCwiY3ljbGVfZWZmZWN0IjpudWxsLCJlZmZlY3RfY29kZSI6ImNsYXNzPVwibmdnLWZhbmN5Ym94XCIgcmVsPVwiJUdBTExFUllfTkFNRSVcIiIsInNob3dfdGh1bWJuYWlsX2xpbmsiOjEsInRodW1ibmFpbF9saW5rX3RleHQiOiJbXHU2NjNlXHU3OTNhXHU3ZjI5XHU3NTY1XHU1NmZlXSIsInRlbXBsYXRlIjoiIiwibmdnX3RyaWdnZXJzX2Rpc3BsYXkiOiJuZXZlciJ9LCJoaWRkZW5fZnJvbV91aSI6ZmFsc2UsImhpZGRlbl9mcm9tX2lndyI6ZmFsc2UsIl9fZGVmYXVsdHNfc2V0Ijp0cnVlfQ==',0,'https://blog-scottwang.rhcloud.com/?post_type=display_type&p=8',0,'display_type','',0),
 (9,1,'2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gSW1hZ2VCcm93c2VyIFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJpbWFnZSJdLCJwcmV2aWV3X2ltYWdlX3JlbHBhdGgiOiJcL25leHRnZW4tZ2FsbGVyeVwvcHJvZHVjdHNcL3Bob3RvY3JhdGlfbmV4dGdlblwvbW9kdWxlc1wvbmV4dGdlbl9iYXNpY19pbWFnZWJyb3dzZXJcL3N0YXRpY1wvcHJldmlldy5qcGciLCJkZWZhdWx0X3NvdXJjZSI6ImdhbGxlcmllcyIsInZpZXdfb3JkZXIiOjEwMDIwLCJhbGlhc2VzIjpbImJhc2ljX2ltYWdlYnJvd3NlciIsImltYWdlYnJvd3NlciIsIm5leHRnZW5fYmFzaWNfaW1hZ2Vicm93c2VyIl0sIm5hbWUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfaW1hZ2Vicm93c2VyIiwiaW5zdGFsbGVkX2F0X3ZlcnNpb24iOiIyLjEuNTYiLCJpZF9maWVsZCI6IklEIiwic2V0dGluZ3MiOnsidXNlX2xpZ2h0Ym94X2VmZmVjdCI6dHJ1ZSwidGVtcGxhdGUiOiIiLCJuZ2dfdHJpZ2dlcnNfZGlzcGxheSI6Im5ldmVyIn0sImhpZGRlbl9mcm9tX3VpIjpmYWxzZSwiaGlkZGVuX2Zyb21faWd3IjpmYWxzZSwiX19kZWZhdWx0c19zZXQiOnRydWV9','NextGEN ImageBrowser 基础版','','draft','closed','closed','','','','','2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gSW1hZ2VCcm93c2VyIFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJpbWFnZSJdLCJwcmV2aWV3X2ltYWdlX3JlbHBhdGgiOiJcL25leHRnZW4tZ2FsbGVyeVwvcHJvZHVjdHNcL3Bob3RvY3JhdGlfbmV4dGdlblwvbW9kdWxlc1wvbmV4dGdlbl9iYXNpY19pbWFnZWJyb3dzZXJcL3N0YXRpY1wvcHJldmlldy5qcGciLCJkZWZhdWx0X3NvdXJjZSI6ImdhbGxlcmllcyIsInZpZXdfb3JkZXIiOjEwMDIwLCJhbGlhc2VzIjpbImJhc2ljX2ltYWdlYnJvd3NlciIsImltYWdlYnJvd3NlciIsIm5leHRnZW5fYmFzaWNfaW1hZ2Vicm93c2VyIl0sIm5hbWUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfaW1hZ2Vicm93c2VyIiwiaW5zdGFsbGVkX2F0X3ZlcnNpb24iOiIyLjEuNTYiLCJpZF9maWVsZCI6IklEIiwic2V0dGluZ3MiOnsidXNlX2xpZ2h0Ym94X2VmZmVjdCI6dHJ1ZSwidGVtcGxhdGUiOiIiLCJuZ2dfdHJpZ2dlcnNfZGlzcGxheSI6Im5ldmVyIn0sImhpZGRlbl9mcm9tX3VpIjpmYWxzZSwiaGlkZGVuX2Zyb21faWd3IjpmYWxzZSwiX19kZWZhdWx0c19zZXQiOnRydWV9',0,'https://blog-scottwang.rhcloud.com/?post_type=display_type&p=9',0,'display_type','',0),
 (10,1,'2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gQmFzaWMgU2luZ2xlUGljIiwiZW50aXR5X3R5cGVzIjpbImltYWdlIl0sInByZXZpZXdfaW1hZ2VfcmVscGF0aCI6IlwvbmV4dGdlbi1nYWxsZXJ5XC9wcm9kdWN0c1wvcGhvdG9jcmF0aV9uZXh0Z2VuXC9tb2R1bGVzXC9uZXh0Z2VuX2Jhc2ljX3NpbmdsZXBpY1wvc3RhdGljXC9wcmV2aWV3LmdpZiIsImRlZmF1bHRfc291cmNlIjoiZ2FsbGVyaWVzIiwidmlld19vcmRlciI6MTAwNjAsImhpZGRlbl9mcm9tX3VpIjp0cnVlLCJoaWRkZW5fZnJvbV9pZ3ciOnRydWUsImFsaWFzZXMiOlsiYmFzaWNfc2luZ2xlcGljIiwic2luZ2xlcGljIiwibmV4dGdlbl9iYXNpY19zaW5nbGVwaWMiXSwibmFtZSI6InBob3RvY3JhdGktbmV4dGdlbl9iYXNpY19zaW5nbGVwaWMiLCJpbnN0YWxsZWRfYXRfdmVyc2lvbiI6IjIuMS41NiIsImlkX2ZpZWxkIjoiSUQiLCJzZXR0aW5ncyI6eyJ1c2VfbGlnaHRib3hfZWZmZWN0Ijp0cnVlLCJ3aWR0aCI6IiIsImhlaWdodCI6IiIsIm1vZGUiOiIiLCJkaXNwbGF5X3dhdGVybWFyayI6MCwiZGlzcGxheV9yZWZsZWN0aW9uIjowLCJmbG9hdCI6IiIsImxpbmsiOiIiLCJsaW5rX3RhcmdldCI6Il9ibGFuayIsInF1YWxpdHkiOjEwMCwiY3JvcCI6MCwidGVtcGxhdGUiOiIiLCJuZ2dfdHJpZ2dlcnNfZGlzcGxheSI6Im5ldmVyIn0sIl9fZGVmYXVsdHNfc2V0Ijp0cnVlfQ==','NextGEN Basic SinglePic','','draft','closed','closed','','','','','2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gQmFzaWMgU2luZ2xlUGljIiwiZW50aXR5X3R5cGVzIjpbImltYWdlIl0sInByZXZpZXdfaW1hZ2VfcmVscGF0aCI6IlwvbmV4dGdlbi1nYWxsZXJ5XC9wcm9kdWN0c1wvcGhvdG9jcmF0aV9uZXh0Z2VuXC9tb2R1bGVzXC9uZXh0Z2VuX2Jhc2ljX3NpbmdsZXBpY1wvc3RhdGljXC9wcmV2aWV3LmdpZiIsImRlZmF1bHRfc291cmNlIjoiZ2FsbGVyaWVzIiwidmlld19vcmRlciI6MTAwNjAsImhpZGRlbl9mcm9tX3VpIjp0cnVlLCJoaWRkZW5fZnJvbV9pZ3ciOnRydWUsImFsaWFzZXMiOlsiYmFzaWNfc2luZ2xlcGljIiwic2luZ2xlcGljIiwibmV4dGdlbl9iYXNpY19zaW5nbGVwaWMiXSwibmFtZSI6InBob3RvY3JhdGktbmV4dGdlbl9iYXNpY19zaW5nbGVwaWMiLCJpbnN0YWxsZWRfYXRfdmVyc2lvbiI6IjIuMS41NiIsImlkX2ZpZWxkIjoiSUQiLCJzZXR0aW5ncyI6eyJ1c2VfbGlnaHRib3hfZWZmZWN0Ijp0cnVlLCJ3aWR0aCI6IiIsImhlaWdodCI6IiIsIm1vZGUiOiIiLCJkaXNwbGF5X3dhdGVybWFyayI6MCwiZGlzcGxheV9yZWZsZWN0aW9uIjowLCJmbG9hdCI6IiIsImxpbmsiOiIiLCJsaW5rX3RhcmdldCI6Il9ibGFuayIsInF1YWxpdHkiOjEwMCwiY3JvcCI6MCwidGVtcGxhdGUiOiIiLCJuZ2dfdHJpZ2dlcnNfZGlzcGxheSI6Im5ldmVyIn0sIl9fZGVmYXVsdHNfc2V0Ijp0cnVlfQ==',0,'https://blog-scottwang.rhcloud.com/?post_type=display_type&p=10',0,'display_type','',0),
 (11,1,'2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gQmFzaWMgVGFnQ2xvdWQiLCJlbnRpdHlfdHlwZXMiOlsiaW1hZ2UiXSwicHJldmlld19pbWFnZV9yZWxwYXRoIjoiXC9uZXh0Z2VuLWdhbGxlcnlcL3Byb2R1Y3RzXC9waG90b2NyYXRpX25leHRnZW5cL21vZHVsZXNcL25leHRnZW5fYmFzaWNfdGFnY2xvdWRcL3N0YXRpY1wvcHJldmlldy5naWYiLCJkZWZhdWx0X3NvdXJjZSI6InRhZ3MiLCJ2aWV3X29yZGVyIjoxMDEwMCwiYWxpYXNlcyI6WyJiYXNpY190YWdjbG91ZCIsInRhZ2Nsb3VkIiwibmV4dGdlbl9iYXNpY190YWdjbG91ZCJdLCJuYW1lIjoicGhvdG9jcmF0aS1uZXh0Z2VuX2Jhc2ljX3RhZ2Nsb3VkIiwiaW5zdGFsbGVkX2F0X3ZlcnNpb24iOiIyLjEuNTYiLCJpZF9maWVsZCI6IklEIiwic2V0dGluZ3MiOnsidXNlX2xpZ2h0Ym94X2VmZmVjdCI6dHJ1ZSwiZGlzcGxheV90eXBlIjoicGhvdG9jcmF0aS1uZXh0Z2VuX2Jhc2ljX3RodW1ibmFpbHMiLCJudW1iZXIiOjQ1LCJuZ2dfdHJpZ2dlcnNfZGlzcGxheSI6Im5ldmVyIn0sImhpZGRlbl9mcm9tX3VpIjpmYWxzZSwiaGlkZGVuX2Zyb21faWd3IjpmYWxzZSwiX19kZWZhdWx0c19zZXQiOnRydWV9','NextGEN Basic TagCloud','','draft','closed','closed','','','','','2016-10-31 12:36:14','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gQmFzaWMgVGFnQ2xvdWQiLCJlbnRpdHlfdHlwZXMiOlsiaW1hZ2UiXSwicHJldmlld19pbWFnZV9yZWxwYXRoIjoiXC9uZXh0Z2VuLWdhbGxlcnlcL3Byb2R1Y3RzXC9waG90b2NyYXRpX25leHRnZW5cL21vZHVsZXNcL25leHRnZW5fYmFzaWNfdGFnY2xvdWRcL3N0YXRpY1wvcHJldmlldy5naWYiLCJkZWZhdWx0X3NvdXJjZSI6InRhZ3MiLCJ2aWV3X29yZGVyIjoxMDEwMCwiYWxpYXNlcyI6WyJiYXNpY190YWdjbG91ZCIsInRhZ2Nsb3VkIiwibmV4dGdlbl9iYXNpY190YWdjbG91ZCJdLCJuYW1lIjoicGhvdG9jcmF0aS1uZXh0Z2VuX2Jhc2ljX3RhZ2Nsb3VkIiwiaW5zdGFsbGVkX2F0X3ZlcnNpb24iOiIyLjEuNTYiLCJpZF9maWVsZCI6IklEIiwic2V0dGluZ3MiOnsidXNlX2xpZ2h0Ym94X2VmZmVjdCI6dHJ1ZSwiZGlzcGxheV90eXBlIjoicGhvdG9jcmF0aS1uZXh0Z2VuX2Jhc2ljX3RodW1ibmFpbHMiLCJudW1iZXIiOjQ1LCJuZ2dfdHJpZ2dlcnNfZGlzcGxheSI6Im5ldmVyIn0sImhpZGRlbl9mcm9tX3VpIjpmYWxzZSwiaGlkZGVuX2Zyb21faWd3IjpmYWxzZSwiX19kZWZhdWx0c19zZXQiOnRydWV9',0,'https://blog-scottwang.rhcloud.com/?post_type=display_type&p=11',0,'display_type','',0),
 (12,1,'2016-10-31 12:36:15','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gXHU3ZDI3XHU1MWQxXHU4OWM2XHU1NmZlXHU3NmY4XHU1MThjIFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJhbGJ1bSIsImdhbGxlcnkiXSwicHJldmlld19pbWFnZV9yZWxwYXRoIjoiXC9uZXh0Z2VuLWdhbGxlcnlcL3Byb2R1Y3RzXC9waG90b2NyYXRpX25leHRnZW5cL21vZHVsZXNcL25leHRnZW5fYmFzaWNfYWxidW1cL3N0YXRpY1wvY29tcGFjdF9wcmV2aWV3LmpwZyIsImRlZmF1bHRfc291cmNlIjoiYWxidW1zIiwidmlld19vcmRlciI6MTAyMDAsImFsaWFzZXMiOlsiYmFzaWNfY29tcGFjdF9hbGJ1bSIsIm5leHRnZW5fYmFzaWNfYWxidW0iLCJiYXNpY19hbGJ1bV9jb21wYWN0IiwiY29tcGFjdF9hbGJ1bSJdLCJuYW1lIjoicGhvdG9jcmF0aS1uZXh0Z2VuX2Jhc2ljX2NvbXBhY3RfYWxidW0iLCJpbnN0YWxsZWRfYXRfdmVyc2lvbiI6IjIuMS41NiIsImlkX2ZpZWxkIjoiSUQiLCJzZXR0aW5ncyI6eyJ1c2VfbGlnaHRib3hfZWZmZWN0Ijp0cnVlLCJnYWxsZXJpZXNfcGVyX3BhZ2UiOjAsImVuYWJsZV9icmVhZGNydW1icyI6MSwiZGlzYWJsZV9wYWdpbmF0aW9uIjowLCJlbmFibGVfZGVzY3JpcHRpb25zIjowLCJ0ZW1wbGF0ZSI6IiIsIm9wZW5fZ2FsbGVyeV9pbl9saWdodGJveCI6MCwiZ2FsbGVyeV9kaXNwbGF5X3R5cGUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfdGh1bWJuYWlscyIsImdhbGxlcnlfZGlzcGxheV90ZW1wbGF0ZSI6IiIsIm5nZ190cmlnZ2Vyc19kaXNwbGF5IjoibmV2ZXIifSwiaGlkZGVuX2Zyb21fdWkiOmZhbHNlLCJoaWRkZW5fZnJvbV9pZ3ciOmZhbHNlLCJfX2RlZmF1bHRzX3NldCI6dHJ1ZX0=','NextGEN 紧凑视图相册 基础版','','draft','closed','closed','','','','','2016-10-31 12:36:15','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gXHU3ZDI3XHU1MWQxXHU4OWM2XHU1NmZlXHU3NmY4XHU1MThjIFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJhbGJ1bSIsImdhbGxlcnkiXSwicHJldmlld19pbWFnZV9yZWxwYXRoIjoiXC9uZXh0Z2VuLWdhbGxlcnlcL3Byb2R1Y3RzXC9waG90b2NyYXRpX25leHRnZW5cL21vZHVsZXNcL25leHRnZW5fYmFzaWNfYWxidW1cL3N0YXRpY1wvY29tcGFjdF9wcmV2aWV3LmpwZyIsImRlZmF1bHRfc291cmNlIjoiYWxidW1zIiwidmlld19vcmRlciI6MTAyMDAsImFsaWFzZXMiOlsiYmFzaWNfY29tcGFjdF9hbGJ1bSIsIm5leHRnZW5fYmFzaWNfYWxidW0iLCJiYXNpY19hbGJ1bV9jb21wYWN0IiwiY29tcGFjdF9hbGJ1bSJdLCJuYW1lIjoicGhvdG9jcmF0aS1uZXh0Z2VuX2Jhc2ljX2NvbXBhY3RfYWxidW0iLCJpbnN0YWxsZWRfYXRfdmVyc2lvbiI6IjIuMS41NiIsImlkX2ZpZWxkIjoiSUQiLCJzZXR0aW5ncyI6eyJ1c2VfbGlnaHRib3hfZWZmZWN0Ijp0cnVlLCJnYWxsZXJpZXNfcGVyX3BhZ2UiOjAsImVuYWJsZV9icmVhZGNydW1icyI6MSwiZGlzYWJsZV9wYWdpbmF0aW9uIjowLCJlbmFibGVfZGVzY3JpcHRpb25zIjowLCJ0ZW1wbGF0ZSI6IiIsIm9wZW5fZ2FsbGVyeV9pbl9saWdodGJveCI6MCwiZ2FsbGVyeV9kaXNwbGF5X3R5cGUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfdGh1bWJuYWlscyIsImdhbGxlcnlfZGlzcGxheV90ZW1wbGF0ZSI6IiIsIm5nZ190cmlnZ2Vyc19kaXNwbGF5IjoibmV2ZXIifSwiaGlkZGVuX2Zyb21fdWkiOmZhbHNlLCJoaWRkZW5fZnJvbV9pZ3ciOmZhbHNlLCJfX2RlZmF1bHRzX3NldCI6dHJ1ZX0=',0,'https://blog-scottwang.rhcloud.com/?post_type=display_type&p=12',0,'display_type','',0),
 (13,1,'2016-10-31 12:36:15','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gXHU2MjY5XHU1YzU1XHU4OWM2XHU1NmZlXHU3NmY4XHU1MThjIFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJhbGJ1bSIsImdhbGxlcnkiXSwicHJldmlld19pbWFnZV9yZWxwYXRoIjoiXC9uZXh0Z2VuLWdhbGxlcnlcL3Byb2R1Y3RzXC9waG90b2NyYXRpX25leHRnZW5cL21vZHVsZXNcL25leHRnZW5fYmFzaWNfYWxidW1cL3N0YXRpY1wvZXh0ZW5kZWRfcHJldmlldy5qcGciLCJkZWZhdWx0X3NvdXJjZSI6ImFsYnVtcyIsInZpZXdfb3JkZXIiOjEwMjEwLCJhbGlhc2VzIjpbImJhc2ljX2V4dGVuZGVkX2FsYnVtIiwibmV4dGdlbl9iYXNpY19leHRlbmRlZF9hbGJ1bSIsImV4dGVuZGVkX2FsYnVtIl0sIm5hbWUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfZXh0ZW5kZWRfYWxidW0iLCJpbnN0YWxsZWRfYXRfdmVyc2lvbiI6IjIuMS41NiIsImlkX2ZpZWxkIjoiSUQiLCJzZXR0aW5ncyI6eyJ1c2VfbGlnaHRib3hfZWZmZWN0Ijp0cnVlLCJnYWxsZXJpZXNfcGVyX3BhZ2UiOjAsImVuYWJsZV9icmVhZGNydW1icyI6MSwiZGlzYWJsZV9wYWdpbmF0aW9uIjowLCJlbmFibGVfZGVzY3JpcHRpb25zIjowLCJ0ZW1wbGF0ZSI6IiIsIm9wZW5fZ2FsbGVyeV9pbl9saWdodGJveCI6MCwib3ZlcnJpZGVfdGh1bWJuYWlsX3NldHRpbmdzIjowLCJ0aHVtYm5haWxfd2lkdGgiOjI0MCwidGh1bWJuYWlsX2hlaWdodCI6MTYwLCJ0aHVtYm5haWxfcXVhbGl0eSI6MTAwLCJ0aHVtYm5haWxfY3JvcCI6dHJ1ZSwidGh1bWJuYWlsX3dhdGVybWFyayI6MCwiZ2FsbGVyeV9kaXNwbGF5X3R5cGUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfdGh1bWJuYWlscyIsImdhbGxlcnlfZGlzcGxheV90ZW1wbGF0ZSI6IiIsIm5nZ190cmlnZ2Vyc19kaXNwbGF5IjoibmV2ZXIifSwiaGlkZGVuX2Zyb21fdWkiOmZhbHNlLCJoaWRkZW5fZnJvbV9pZ3ciOmZhbHNlLCJfX2RlZmF1bHRzX3NldCI6dHJ1ZX0=','NextGEN 扩展视图相册 基础版','','draft','closed','closed','','','','','2016-10-31 12:36:15','0000-00-00 00:00:00','eyJ0aXRsZSI6Ik5leHRHRU4gXHU2MjY5XHU1YzU1XHU4OWM2XHU1NmZlXHU3NmY4XHU1MThjIFx1NTdmYVx1Nzg0MFx1NzI0OCIsImVudGl0eV90eXBlcyI6WyJhbGJ1bSIsImdhbGxlcnkiXSwicHJldmlld19pbWFnZV9yZWxwYXRoIjoiXC9uZXh0Z2VuLWdhbGxlcnlcL3Byb2R1Y3RzXC9waG90b2NyYXRpX25leHRnZW5cL21vZHVsZXNcL25leHRnZW5fYmFzaWNfYWxidW1cL3N0YXRpY1wvZXh0ZW5kZWRfcHJldmlldy5qcGciLCJkZWZhdWx0X3NvdXJjZSI6ImFsYnVtcyIsInZpZXdfb3JkZXIiOjEwMjEwLCJhbGlhc2VzIjpbImJhc2ljX2V4dGVuZGVkX2FsYnVtIiwibmV4dGdlbl9iYXNpY19leHRlbmRlZF9hbGJ1bSIsImV4dGVuZGVkX2FsYnVtIl0sIm5hbWUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfZXh0ZW5kZWRfYWxidW0iLCJpbnN0YWxsZWRfYXRfdmVyc2lvbiI6IjIuMS41NiIsImlkX2ZpZWxkIjoiSUQiLCJzZXR0aW5ncyI6eyJ1c2VfbGlnaHRib3hfZWZmZWN0Ijp0cnVlLCJnYWxsZXJpZXNfcGVyX3BhZ2UiOjAsImVuYWJsZV9icmVhZGNydW1icyI6MSwiZGlzYWJsZV9wYWdpbmF0aW9uIjowLCJlbmFibGVfZGVzY3JpcHRpb25zIjowLCJ0ZW1wbGF0ZSI6IiIsIm9wZW5fZ2FsbGVyeV9pbl9saWdodGJveCI6MCwib3ZlcnJpZGVfdGh1bWJuYWlsX3NldHRpbmdzIjowLCJ0aHVtYm5haWxfd2lkdGgiOjI0MCwidGh1bWJuYWlsX2hlaWdodCI6MTYwLCJ0aHVtYm5haWxfcXVhbGl0eSI6MTAwLCJ0aHVtYm5haWxfY3JvcCI6dHJ1ZSwidGh1bWJuYWlsX3dhdGVybWFyayI6MCwiZ2FsbGVyeV9kaXNwbGF5X3R5cGUiOiJwaG90b2NyYXRpLW5leHRnZW5fYmFzaWNfdGh1bWJuYWlscyIsImdhbGxlcnlfZGlzcGxheV90ZW1wbGF0ZSI6IiIsIm5nZ190cmlnZ2Vyc19kaXNwbGF5IjoibmV2ZXIifSwiaGlkZGVuX2Zyb21fdWkiOmZhbHNlLCJoaWRkZW5fZnJvbV9pZ3ciOmZhbHNlLCJfX2RlZmF1bHRzX3NldCI6dHJ1ZX0=',0,'https://blog-scottwang.rhcloud.com/?post_type=display_type&p=13',0,'display_type','',0),
 (18,1,'2016-10-31 16:52:43','2016-10-31 08:52:43','<p class="action"><a href="https://support.google.com/tagmanager/answer/4605576">详细了解 Google 跟踪代码管理器版本 2 的新功能</a>！</p>\r\n利用 Google 跟踪代码管理器，您可以使用 Universal Analytics 代码或传统版本的代码部署 Google Analytics（分析）。\r\n<p class="tip">注意：<a href="https://support.google.com/analytics/answer/2790010">Universal Analytics</a> 代码是 Google Analytics（分析）跟踪代码的全新运行标准。</p>\r\n要安装 Google Analytics（分析）代码，请创建一个新代码并选择 Google Analytics（分析）作为代码类型。为要触发的代码选择触发器（例如“所有网页”），然后提供您的 Google Analytics（分析）跟踪 ID 以配置 Google Analytics（分析）代码。\r\n\r\n利用 Universal Analytics，您可以收集更多类型的数据并改善数据质量，进而更深入地了解访问者在每个阶段（查看广告、购买产品、使用产品、使用支持服务以及访问者挽留）如何与您的商家进行互动。\r\n\r\n您可以选择部署传统代码，具体方法是在代码类型配置下拉菜单中选择“传统 Google Analytics（分析）”。\r\n\r\n请为您的代码指定名称（例如“Google Analytics（分析）浏览量代码”），并在必填字段中输入媒体资源的跟踪 ID。您可以在 Google Analytics（分析）中通过<strong>管理 → 媒体资源 → 媒体资源设置</strong>或<strong>管理 → 跟踪信息 → 跟踪代码</strong>找到列出的跟踪 ID。您也可以点击“首页”并展开“帐户”文件夹来查找跟踪 ID：跟踪 ID 列在“媒体资源名称”旁边。无论您通过以上哪种方式找到跟踪 ID，跟踪 ID 的显示格式都是：<strong>UA-xxxxxx-xx</strong>。\r\n\r\n提示：您还可以在“网络媒体资源 ID”字段中使用变量，如果您要管理多个 Google Analytics（分析）网络媒体资源，这种方法非常有帮助。例如，您可以创建一个数据层变量，在要跟踪的网站的所有网页上设置此变量，并将每个网站的跟踪 ID 传递给此变量。然后您可以将 Google Analytics（分析）代码的跟踪 ID 映射到此 Google 跟踪代码管理器变量。另一种方法不需要使用数据层，而是使用 Google 跟踪代码管理器中的对照表变量。配置对照表变量时，请使用内置的 url hostname 作为对照键，然后提供要跟踪的每个网域的跟踪 ID 列表。\r\n<p id="displayad"><strong>“启用展示广告功能”复选框</strong>：要启用<a href="https://support.google.com/analytics/answer/3450482">展示广告功能</a>（包括受众特征和兴趣报告、再营销和 DCM 集成），请选中<strong>启用展示广告功能</strong>复选框。如果您决定使用此选项，则应当针对您的所有 Google Analytics（分析）代码启用此选项，以确保尽量准确地收集数据。如果您选中了此选项，还请参阅<a href="https://support.google.com/analytics/answer/2700409">与展示广告相关的政策要求</a>。</p>\r\nGoogle 跟踪代码管理器支持以下 Google Analytics（分析）代码：\r\n<ul>\r\n 	<li><strong>浏览量代码</strong>，应该在网站的每个<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/pages">网页</a>上触发的基本 Google Analytics（分析）代码。</li>\r\n 	<li><strong>事件代码</strong>，用于<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/events">跟踪特定的操作或事件</a>，如按钮点击。</li>\r\n 	<li><strong>交易代码</strong>，用于跟踪<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/ecommerce">电子商务交易</a>。</li>\r\n 	<li><strong>社交代码</strong>，用于跟踪<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/social-interactions">社交互动</a>。</li>\r\n 	<li><strong>计时代码</strong>，用于跟踪<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/user-timings">网页的加载速度</a>。</li>\r\n 	<li><strong>装饰链接</strong>，请参阅<a href="https://support.google.com/tagmanager/answer/3561401">跨网域跟踪</a>中的使用示例。</li>\r\n 	<li><strong>装饰表单</strong>，请参阅<a href="https://support.google.com/tagmanager/answer/3561401">跨网域跟踪</a>中的使用示例。</li>\r\n 	<li><strong>跨网域跟踪</strong>（仅限传统代码，已弃用，改为使用装饰链接）<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiDomainDirectory#_gat.GA_Tracker_._link">相关信息</a></li>\r\n 	<li><strong>表单发布的跨网域跟踪</strong>（仅限传统代码，使用装饰表单）<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiDomainDirectory#_gat.GA_Tracker_._linkByPost">相关信息</a></li>\r\n</ul>\r\n<h2>基本跟踪</h2>\r\n对于基本的 Google Analytics（分析）跟踪，请添加一个 Google Analytics（分析）代码，并选择“<strong>浏览量</strong>”作为跟踪类型。接下来添加在所有网页上触发该代码的触发器。如果您只需要基本的跟踪功能，只添加这一个 Google Analytics（分析）代码就可以了。不过，如果您跟踪的是事件或电子商务交易，则需要添加其他 Google Analytics（分析）代码。\r\n<h2>跟踪 Google Analytics（分析）事件</h2>\r\n请参阅 <a href="https://support.google.com/tagmanager/answer/3420054">Google Analytics（分析）事件</a>中的具体示例。\r\n<h2>跨网域跟踪</h2>\r\n请参阅<a href="https://support.google.com/tagmanager/answer/3561401">跨网域跟踪</a>中的具体示例。\r\n<h2>Google Analytics（分析）代码配置</h2>\r\nGoogle 跟踪代码管理器可提供广泛的配置选项，您可以在其中对所有 Google Analytics（分析）代码进行精确配置，就像在您的网站上手动实现 Google Analytics（分析）代码一样（注意：目前，Google 跟踪代码管理器不支持 Universal Analytics<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/plugins">插件</a>）。\r\n\r\nUniversal Analytics 代码的配置选项：\r\n\r\n<strong>基本配置</strong>\r\n<ul>\r\n<ul>\r\n 	<li>对 IP 地址进行匿名处理：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#anonymizeIp">相关信息</a></li>\r\n 	<li>会话控制：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#session">相关信息</a></li>\r\n 	<li>文档引荐来源网址：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#trafficsources">相关信息</a></li>\r\n 	<li>文档路径：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/pages">相关信息</a></li>\r\n 	<li>文档标题：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/pages">相关信息</a></li>\r\n 	<li>抽样率：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#sampleRate">相关信息</a></li>\r\n</ul>\r\n</ul>\r\n<strong>高级配置</strong>\r\n<ul>\r\n<ul>\r\n 	<li>全局函数名称：<a href="https://developers.google.com/tag-manager/devguide">相关信息</a></li>\r\n 	<li>使用调试版本：<a href="https://developers.google.com/analytics/resources/articles/gaTrackingTroubleshooting#gaDebug">相关信息</a></li>\r\n 	<li>启用增强的链接归因：<a href="https://support.google.com/analytics/answer/2558867?hl=en">相关信息</a></li>\r\n 	<li>始终使用 SSL：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#forceSSL">相关信息</a></li>\r\n 	<li>跟踪器名称：允许您自行为<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/advanced#creation">跟踪器对象</a>命名。注意：我们建议您不要自行为跟踪器对象命名。如果您无意间重复使用了现有的跟踪器对象名称，则数据可能会遭到损坏。虽然为跟踪器命名可以使您在 Google 跟踪代码管理器创建的跟踪器和您已有的 Google Analytics（分析）代码之间共享状态，但您却需要更新网站上的代码才能使用 Google 跟踪代码管理器 dataLayer 语法。否则，您将无法通过 Google 跟踪代码管理器配置跟踪功能。</li>\r\n</ul>\r\n</ul>\r\n<strong>Cookie 配置</strong>：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/domains">相关信息</a>（在大多数情况下，如果使用 Universal Analytics，我们建议使用“auto”Cookie 网域设置）。\r\n\r\n<strong>跨网域跟踪</strong>：自动链接网域：独立的多个网域，用逗号隔开（如 A.com, B.com, C.com）（请参阅<a href="https://support.google.com/tagmanager/answer/3561401">跨网域跟踪</a>中的使用示例）。\r\n\r\n<strong>内容分组</strong>：<a href="https://support.google.com/analytics/answer/2853546?hl=en&amp;ref_topic=1727167">相关信息</a>\r\n\r\n<strong>电子商务功能</strong>：<a href="https://support-content-draft.corp.google.com/tagmanager/answer/4363363">相关信息</a>\r\n\r\n<strong>自定义维度</strong>：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/custom-dims-mets">相关信息</a>\r\n\r\n<strong>自定义指标</strong>：<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/custom-dims-mets">相关信息</a>\r\n\r\n<strong>要设置的字段</strong>：如果您使用网页中的代码（而不是 Google 跟踪代码管理器）来实现代码，那么您需要使用 <a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/method-reference#create">create ()</a> 和 <a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/method-reference#set">set ()</a> API 调用来设置跟踪器并为其添加设置。Google 跟踪代码管理器使用“要设置的字段”帮助您完成此任务。通过此选项，您可以设置代码模板中未提供的字段。\r\n<ul>\r\n<ul>\r\n 	<li>要启用此链接，请点击“+ 添加字段”按钮并按要求输入字段名称和值。</li>\r\n 	<li>注意：某些字段需要输入特殊内容，因此需要在 Google 跟踪代码管理器中设置一个变量。当输入的内容是布尔值（必须为 true 或 false）时，就会出现这种情况。</li>\r\n 	<li>有关详情，请参阅开发者中心的<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference">字段引用</a>页。</li>\r\n</ul>\r\n</ul>\r\n传统 Google Analytics（分析）代码的配置选项：\r\n\r\n<strong>基本配置：</strong>\r\n<ul>\r\n<ul>\r\n 	<li>对 IP 地址进行匿名处理：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApi_gat?hl=en#_gat._anonymizeIp">相关信息</a></li>\r\n 	<li>虚拟网页路径：指示要跟踪的指标所在的网页路径。<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiBasicConfiguration#_gat.GA_Tracker_._trackPageview">相关信息</a></li>\r\n 	<li>设置抽样率：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiBasicConfiguration?hl=en#_gat.GA_Tracker_._setSampleRate">相关信息</a></li>\r\n 	<li>设置会话 Cookie 超时：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiBasicConfiguration?hl=en#_gat.GA_Tracker_._setSessionCookieTimeout">相关信息</a></li>\r\n</ul>\r\n</ul>\r\n<strong>广告系列跟踪：</strong>\r\n<ul>\r\n<ul>\r\n 	<li>允许定位点：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiCampaignTracking#_gat.GA_Tracker_._setAllowAnchor">相关信息</a></li>\r\n 	<li>设置广告系列 Cookie 超时：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiCampaignTracking#_gat.GA_Tracker_._setCampaignCookieTimeout">相关信息</a></li>\r\n</ul>\r\n</ul>\r\n<strong>自定义变量</strong>：<a href="https://developers.google.com/analytics/devguides/collection/gajs/gaTrackingCustomVariables">相关信息</a>\r\n\r\n<strong>网域和目录</strong>：<a href="https://developers.google.com/analytics/devguides/collection/gajs/gaTrackingSite">相关信息</a>\r\n<ul>\r\n<ul>\r\n 	<li>例如，对 A.com 到 B.com 进行跨网域跟踪时，您需要将 B.com 配置为使用网址参数（来自 A.com 会话）的中 Cookie 数据，而不是设置/使用它自己的 Cookie。要启用此链接，请选中“允许链接器”复选框。</li>\r\n</ul>\r\n</ul>\r\n<strong>搜索引擎和引荐来源网址</strong>：<a href="https://developers.google.com/analytics/devguides/collection/gajs/gaTrackingTraffic">相关信息</a>\r\n\r\n<a href="https://developers.google.com/analytics/devguides/collection/gajs/gaTrackingTraffic"><strong>内容分组</strong></a>：<a href="https://support.google.com/analytics/answer/2853546?hl=en&amp;ref_topic=1727167">相关信息</a>\r\n\r\n<strong>高级配置：</strong>\r\n<ul>\r\n 	<li>跟踪器名称：允许您自行为<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApi_gat#_gat._createTracker">跟踪器对象</a>命名。注意：我们建议您不要自行为跟踪器对象命名。如果您无意间重复使用了现有的跟踪器对象名称，则数据可能会遭到损坏。虽然为跟踪器命名可以使您在 Google 跟踪代码管理器创建的跟踪器和您已有的 Google Analytics（分析）代码之间共享状态，但您却需要更新网站上的代码才能使用 Google 跟踪代码管理器 dataLayer 语法。否则，您将无法通过 Google 跟踪代码管理器配置跟踪功能。</li>\r\n 	<li>本地 GIF 路径：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiUrchin#_gat.GA_Tracker_._setLocalGifPath">相关信息</a></li>\r\n 	<li>访问者 Cookie 超时：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiBasicConfiguration?hl=en#_gat.GA_Tracker_._setVisitorCookieTimeout">相关信息</a></li>\r\n 	<li>匹配回调：此字段的值应指向一个将会返回函数的变量。当 Google Analytics（分析）跟踪信标完全发送后将调用此函数。</li>\r\n 	<li>启用增强的链接归因：<a href="https://support.google.com/analytics/answer/2558867">相关信息</a></li>\r\n 	<li>启用浏览器跟踪模块：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiWebClient#_gat.GA_Tracker_._setClientInfo">相关信息</a></li>\r\n 	<li>启用 Flash 检测：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiWebClient#_gat.GA_Tracker_._setDetectFlash">相关信息</a></li>\r\n 	<li>启用标题检测：<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiWebClient#_gat.GA_Tracker_._setDetectTitle">相关信息</a></li>\r\n 	<li>向 Google 服务器发送匹配数：如果您设置了<a href="https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiUrchin#_gat.GA_Tracker_._setLocalGifPath">本地 GIF 路径</a>，匹配数将发送到您拥有的服务器。选择此选项之后，匹配数还会发送至 Google。</li>\r\n 	<li>使用调试版本：相关信息</li>\r\n</ul>\r\n<strong>始终使用 SSL</strong>：确保所有链接都通过 HTTPS 执行。\r\n\r\n&nbsp;\r\n\r\nCopied from:\r\n\r\n<a href="https://support.google.com/tagmanager/answer/6107124?visit_id=1-636134940343760838-1169925764&amp;rd=1">https://support.google.com/tagmanager/answer/6107124?visit_id=1-636134940343760838-1169925764&amp;rd=1</a>','Google Analytics（分析）','','publish','open','open','','google-analytics','','','2016-10-31 16:58:00','2016-10-31 08:58:00','',0,'https://blog-scottwang.rhcloud.com/?p=18',0,'post','',0),
 (35,1,'2016-10-31 17:05:39','0000-00-00 00:00:00','','首页','','draft','closed','closed','','','','','2016-10-31 17:05:39','0000-00-00 00:00:00','',0,'https://blog-scottwang.rhcloud.com/?p=35',1,'nav_menu_item','',0),
 (37,1,'2016-10-31 17:07:05','0000-00-00 00:00:00','','首页','','draft','closed','closed','','','','','2016-10-31 17:07:05','0000-00-00 00:00:00','',0,'https://blog-scottwang.rhcloud.com/?p=37',1,'nav_menu_item','',0),
 (40,1,'2016-11-01 16:01:57','2016-11-01 08:01:57','from:\r\n\r\n<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">http://www.ruanyifeng.com/blog/2016/08/http.html</a>\r\n\r\n&nbsp;\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\nHTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n本文介绍 HTTP 协议的历史演变和设计思路。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016081901.jpg" alt="" />\r\n<h2>一、HTTP/0.9</h2>\r\nHTTP 是基于 TCP/IP 协议的<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank"><strong>应用层协议</strong></a>。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。\r\n\r\n最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\nGET /index.html\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。\r\n\r\n协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。\r\n<blockquote>\r\n<pre><code class="language-html">\r\n&lt;html&gt;\r\n  &lt;body&gt;Hello World&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n</blockquote>\r\n服务器发送完毕，就关闭TCP连接。\r\n<h2>二、HTTP/1.0</h2>\r\n<h3>2.1 简介</h3>\r\n1996年5月，HTTP/1.0 版本发布，内容大大增加。\r\n\r\n首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。\r\n\r\n其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。\r\n\r\n再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。\r\n\r\n其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。\r\n<h3>2.2 请求格式</h3>\r\n下面是一个1.0版的HTTP请求的例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\nGET / HTTP/1.0\r\n<span class="token keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)\r\n<span class="token keyword">Accept:</span> */*\r\n</code></pre>\r\n</blockquote>\r\n可以看到，这个格式与0.9版有很大变化。\r\n\r\n第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。\r\n<h3>2.3 回应格式</h3>\r\n服务器的回应如下。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\nHTTP/1.0 200 OK \r\n<span class="token keyword">Content-Type:</span> text/plain\r\n<span class="token keyword">Content-Length:</span> 137582\r\n<span class="token keyword">Expires:</span> Thu, 05 Dec 1997 16:00:00 GMT\r\n<span class="token keyword">Last-Modified:</span> Wed, 5 August 1996 15:55:28 GMT\r\n<span class="token keyword">Server:</span> Apache 0.84\r\n\r\n&lt;html&gt;\r\n  &lt;body&gt;Hello World&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n</blockquote>\r\n回应的格式是"头信息 + 一个空行（<code>\\r\\n</code>） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。\r\n<h3>2.4 Content-Type 字段</h3>\r\n关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。\r\n\r\n下面是一些常见的<code>Content-Type</code>字段的值。\r\n<blockquote>\r\n<ul>\r\n 	<li>text/plain</li>\r\n 	<li>text/html</li>\r\n 	<li>text/css</li>\r\n 	<li>image/jpeg</li>\r\n 	<li>image/png</li>\r\n 	<li>image/svg+xml</li>\r\n 	<li>audio/mp4</li>\r\n 	<li>video/mp4</li>\r\n 	<li>application/javascript</li>\r\n 	<li>application/pdf</li>\r\n 	<li>application/zip</li>\r\n 	<li>application/atom+xml</li>\r\n</ul>\r\n</blockquote>\r\n这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。\r\n\r\n除了预定义的类型，厂商也可以自定义类型。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\napplication/vnd.debian.binary-package\r\n</code></pre>\r\n</blockquote>\r\n上面的类型表明，发送的是Debian系统的二进制数据包。\r\n\r\n<code>MIME type</code>还可以在尾部使用分号，添加参数。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Content-Type:</span> text/html; charset=utf-8\r\n</code></pre>\r\n</blockquote>\r\n上面的类型表明，发送的是网页，而且编码是UTF-8。\r\n\r\n客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Accept:</span> */*\r\n</code></pre>\r\n</blockquote>\r\n上面代码中，客户端声明自己可以接受任何格式的数据。\r\n\r\n<code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。\r\n<blockquote>\r\n<pre><code class="language-html">\r\n&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;\r\n&lt;!-- 等同于 --&gt;\r\n&lt;meta charset="utf-8" /&gt; \r\n</code></pre>\r\n</blockquote>\r\n<h3>2.5 Content-Encoding 字段</h3>\r\n由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Content-Encoding:</span> gzip\r\n<span class="token keyword">Content-Encoding:</span> compress\r\n<span class="token keyword">Content-Encoding:</span> deflate\r\n</code></pre>\r\n</blockquote>\r\n客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Accept-Encoding:</span> gzip, deflate\r\n</code></pre>\r\n</blockquote>\r\n<h3>2.6 缺点</h3>\r\nHTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。\r\n\r\nTCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。\r\n\r\n为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Connection:</span> keep-alive\r\n</code></pre>\r\n</blockquote>\r\n这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Connection:</span> keep-alive\r\n</code></pre>\r\n</blockquote>\r\n一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。\r\n<h2>三、HTTP/1.1</h2>\r\n1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。\r\n<h3>3.1 持久连接</h3>\r\n1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。\r\n\r\n客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Connection:</span> close\r\n</code></pre>\r\n</blockquote>\r\n目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。\r\n<h3>3.2 管道机制</h3>\r\n1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。\r\n\r\n举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。\r\n<h3>3.3 Content-Length 字段</h3>\r\n一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Content-Length:</span> 3495\r\n</code></pre>\r\n</blockquote>\r\n上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。\r\n\r\n在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。\r\n<h3>3.4 分块传输编码</h3>\r\n使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。\r\n\r\n对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。\r\n\r\n因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank">"分块传输编码"</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Transfer-Encoding:</span> chunked\r\n</code></pre>\r\n</blockquote>\r\n每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\nHTTP/1.1 200 OK\r\n<span class="token keyword">Content-Type:</span> text/plain\r\n<span class="token keyword">Transfer-Encoding:</span> chunked\r\n\r\n25\r\nThis is the data in the first chunk\r\n\r\n1C\r\nand this is the second one\r\n\r\n3\r\ncon\r\n\r\n8\r\nsequence\r\n\r\n0\r\n\r\n</code></pre>\r\n</blockquote>\r\n<h3>3.5 其他功能</h3>\r\n1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。\r\n\r\n另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Host:</span> www.example.com\r\n</code></pre>\r\n</blockquote>\r\n有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。\r\n<h3>3.6 缺点</h3>\r\n虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank">"队头堵塞"</a>（Head-of-line blocking）。\r\n\r\n为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。\r\n<h2>四、SPDY 协议</h2>\r\n2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。\r\n\r\n这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。\r\n<h2>五、HTTP/2</h2>\r\n2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。\r\n<h3>5.1 二进制协议</h3>\r\nHTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。\r\n\r\n二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。\r\n<h3>5.2 多工</h3>\r\nHTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。\r\n\r\n举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。\r\n\r\n这样双向的、实时的通信，就叫做多工（Multiplexing）。\r\n<h3>5.3 数据流</h3>\r\n因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。\r\n\r\nHTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。\r\n\r\n数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。\r\n\r\n客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。\r\n<h3>5.4 头信息压缩</h3>\r\nHTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。\r\n\r\nHTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。\r\n<h3>5.5 服务器推送</h3>\r\nHTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。\r\n\r\n常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。\r\n<h3>六、参考链接</h3>\r\n<ul>\r\n 	<li><a href="http://kamranahmed.info/blog/2016/08/13/http-in-depth/" target="_blank">Journey to HTTP/2</a>, by Kamran Ahmed</li>\r\n 	<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">HTTP</a>, by Wikipedia</li>\r\n 	<li><a href="https://tools.ietf.org/html/rfc1945" target="_blank">HTTP/1.0 Specification</a></li>\r\n 	<li><a href="https://http2.github.io/http2-spec/" target="_blank">HTTP/2 Specification</a></li>\r\n</ul>\r\n（完）\r\n\r\n<!-- /div -->\r\n\r\n</div>','HTTP协议入门','','publish','open','open','','http-basic','','','2016-11-01 16:01:57','2016-11-01 08:01:57','',0,'https://blog-scottwang.rhcloud.com/?p=40',0,'post','',0),
 (43,1,'2016-11-01 16:23:54','2016-11-01 08:23:54','from:\r\n<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n我们每天使用互联网，你是否想过，它是如何实现的？\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？\r\n\r\n互联网的核心是一系列协议，总称为"互联网协议"（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。\r\n\r\n下面就是我的学习笔记。因为这些协议实在太复杂、太庞大，我想整理一个简洁的框架，帮助自己从总体上把握它们。为了保证简单易懂，我做了大量的简化，有些地方并不全面和精确，但是应该能够说清楚互联网的原理。\r\n\r\n&nbsp;\r\n\r\n<strong>一、概述</strong>\r\n\r\n<strong>1.1 五层模型</strong>\r\n\r\n互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。\r\n\r\n用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。\r\n\r\n如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052902.png" />\r\n\r\n如上图所示，最底下的一层叫做"实体层"（Physical Layer），最上面的一层叫做"应用层"（Application Layer），中间的三层（自下而上）分别是"链接层"（Link Layer）、"网络层"（Network Layer）和"传输层"（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。\r\n\r\n它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。\r\n\r\n<strong>1.2 层与协议</strong>\r\n\r\n每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。\r\n\r\n大家都遵守的规则，就叫做"协议"（protocol）。\r\n\r\n互联网的每一层，都定义了很多协议。这些协议的总称，就叫做"互联网协议"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。\r\n\r\n<strong>二、实体层</strong>\r\n\r\n我们从最底下的一层开始。\r\n\r\n电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052903.png" />\r\n\r\n<strong>这就叫做"实体层"，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong>\r\n\r\n<strong>三、链接层</strong>\r\n\r\n<strong>3.1 定义</strong>\r\n\r\n单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？\r\n\r\n<strong>这就是"链接层"的功能，它在"实体层"的上方，确定了0和1的分组方式。</strong>\r\n\r\n<strong>3.2 以太网协议</strong>\r\n\r\n早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做<a href="http://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank">"以太网"</a>（Ethernet）的协议，占据了主导地位。\r\n\r\n以太网规定，一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052904.png" />\r\n\r\n"标头"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；"数据"则是数据包的具体内容。\r\n\r\n"标头"的长度，固定为18字节。"数据"的长度，最短为46字节，最长为1500字节。因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。\r\n\r\n<strong>3.3 MAC地址</strong>\r\n\r\n上面提到，以太网数据包的"标头"，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？\r\n\r\n以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052905.jpg" />\r\n\r\n每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052906.png" />\r\n\r\n前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。\r\n\r\n<strong>3.4 广播</strong>\r\n\r\n定义地址只是第一步，后面还有更多的步骤。\r\n\r\n首先，一块网卡怎么会知道另一块网卡的MAC地址？\r\n\r\n回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。\r\n\r\n其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？\r\n\r\n回答是以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052907.png" />\r\n\r\n上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的"标头"，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做"广播"（broadcasting）。\r\n\r\n有了数据包的定义、网卡的MAC地址、广播的发送方式，"链接层"就可以在多台计算机之间传送数据了。\r\n\r\n<strong>四、网络层</strong>\r\n\r\n<strong>4.1 网络层的由来</strong>\r\n\r\n以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。\r\n\r\n但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一"包"，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。\r\n\r\n互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052914.png" />\r\n\r\n因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用"路由"方式发送。（"路由"的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。\r\n\r\n<strong>这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"。</strong>\r\n\r\n于是，"网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。\r\n\r\n网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。\r\n\r\n<strong>4.2 IP协议</strong>\r\n\r\n规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。\r\n\r\n目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052908.png" />\r\n\r\n习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。\r\n\r\n互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。\r\n\r\n但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。\r\n\r\n那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数"子网掩码"（subnet mask）。\r\n\r\n所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。\r\n\r\n知道"子网掩码"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。\r\n\r\n比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。\r\n\r\n总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。\r\n\r\n<strong>4.3 IP数据包</strong>\r\n\r\n根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。\r\n\r\n但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？\r\n\r\n回答是不需要，我们可以把IP数据包直接放进以太网数据包的"数据"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。\r\n\r\n具体来说，IP数据包也分为"标头"和"数据"两个部分。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052909.png" />\r\n\r\n"标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052910.png" />\r\n\r\nIP数据包的"标头"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的"数据"部分，最长为65,515字节。前面说过，以太网数据包的"数据"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。\r\n\r\n<strong>4.4 ARP协议</strong>\r\n\r\n关于"网络层"，还有最后一点需要说明。\r\n\r\n因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。\r\n\r\n所以，我们需要一种机制，能够从IP地址得到MAC地址。\r\n\r\n这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。\r\n\r\n第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。\r\n\r\n总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。\r\n\r\n<strong>五、传输层</strong>\r\n\r\n<strong>5.1 传输层的由来</strong>\r\n\r\n有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。\r\n\r\n接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？\r\n\r\n也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做"端口"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。\r\n\r\n"端口"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。\r\n\r\n<strong>"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。</strong>因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。\r\n\r\n<strong>5.2 UDP协议</strong>\r\n\r\n现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。\r\n\r\nUDP数据包，也是由"标头"和"数据"两部分组成。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052911.png" />\r\n\r\n"标头"部分主要定义了发出端口和接收端口，"数据"部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的"数据"部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052912.png" />\r\n\r\nUDP数据包非常简单，"标头"部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。\r\n\r\n<strong>5.3 TCP协议</strong>\r\n\r\nUDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。\r\n\r\n为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。\r\n\r\n因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。\r\n\r\nTCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。\r\n\r\n<strong>六、应用层</strong>\r\n\r\n应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。\r\n\r\n<strong>"应用层"的作用，就是规定应用程序的数据格式。</strong>\r\n\r\n举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。\r\n\r\n这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分。因此，现在的以太网的数据包就变成下面这样。\r\n\r\n<img src="http://image.beekka.com/blog/201205/bg2012052913.png" />\r\n\r\n至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。<a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank">下一篇</a>，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。\r\n\r\n（完）\r\n\r\n<!-- /div -->\r\n\r\n</div>','互联网协议入门（一）','','publish','open','open','','internet_protocol','','','2016-11-01 16:24:17','2016-11-01 08:24:17','',0,'https://blog-scottwang.rhcloud.com/?p=43',0,'post','',0),
 (46,1,'2016-11-01 16:42:06','2016-11-01 08:42:06','from:\r\n<a href="http://www.ruanyifeng.com/blog/2016/08/boolean-algebra.html">http://www.ruanyifeng.com/blog/2016/08/boolean-algebra.html</a>\r\n<div class="asset-meta"></div>\r\n<div class="asset-meta"></div>\r\n<article class="hentry">\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0" target="_blank">布尔代数</a>是计算机的基础。没有它，就不会有计算机。\r\n\r\n布尔代数发展到今天，已经非常抽象，但是它的核心思想很简单。本文帮助你理解布尔代数，以及为什么它促成了计算机的诞生。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016080505.jpg" alt="" />\r\n\r\n我依据的是《编码的奥妙》的第十章。这是一本好书，强烈推荐。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016080501.jpg" alt="" />\r\n<h2>一、数理逻辑的起源</h2>\r\n19世纪早期，英国数学家乔治·布尔（George Boole，1815－1864）突发奇想：人的思想能不能用数学表达？\r\n\r\n此前，数学只用于计算，没有人意识到，数学还能表达人的逻辑思维。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016080502.jpg" alt="" />\r\n\r\n两千年来，哲学书都是用文字写的。比如，最著名的三段论：\r\n<blockquote>所有人都是要死的，\r\n苏格拉底是人，\r\n所以，苏格拉底是要死的。</blockquote>\r\n乔治·布尔认为，这种推理可以用数学表达，也就是说，哲学书完全可以用数学写。这就是数理逻辑的起源。\r\n<h2>二、集合论</h2>\r\n乔治·布尔发明的工具，叫做"集合论"（Set theory）。他认为，逻辑思维的基础是一个个集合（Set），每一个命题表达的都是集合之间的关系。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016080503.jpg" alt="" />\r\n\r\n比如，所有人类组成一个集合<code>R</code>，所有会死的东西组成一个集合<code>D</code>。\r\n<blockquote>所有人都是要死的</blockquote>\r\n集合论的写法就是：\r\n<blockquote>R X D = R</blockquote>\r\n集合之间最基本的关系是并集和交集。乘号（<code>X</code>）表示交集，加号（<code>+</code>）表示并集。上面这个式子的意思是，<code>R</code>与<code>D</code>的交集就是<code>R</code>。\r\n\r\n同样的，苏格拉底也是一个集合<code>S</code>，这个集合里面只有苏格拉底一个成员。\r\n<blockquote>苏格拉底是人\r\n// 等同于\r\nS X R = S</blockquote>\r\n上面式子的意思是，苏格拉底与人类的交集，就是苏格拉底。\r\n\r\n将第一个式子代入第二个式子，就得到了结论。\r\n<blockquote>S X (R X D)\r\n= (S X R) X D\r\n= S X D\r\n= S</blockquote>\r\n这个式子的意思是，苏格拉底与会死的东西的交集，就是苏格拉底，即苏格拉底也属于会死的东西。\r\n<h2>三、集合的运算法则</h2>\r\n前面的三段论比较容易，一眼就能看出结论。但是，有些三段轮比较复杂，不容易立即反应过来。\r\n\r\n请看下面这两句话。\r\n<blockquote>"鸭嘴兽是卵生的哺乳动物。鸭嘴兽是澳洲的动物。"</blockquote>\r\n你能一眼得到结论吗？\r\n<blockquote>鸭嘴兽 X 卵生 = 鸭嘴兽\r\n鸭嘴兽 x 澳洲 = 鸭嘴兽</blockquote>\r\n将第一个式子代入第二个，就会得到：\r\n<blockquote>鸭嘴兽 X 卵生 x 澳洲 = 鸭嘴兽\r\n// 相当于\r\n卵生 x 澳洲 = 鸭嘴兽 + 其他</blockquote>\r\n因此，结论就是"有的卵生动物是澳洲的动物"，或者"有的澳洲的动物是卵生动物"。\r\n\r\n还有更不直观的三段论。\r\n<blockquote>"哲学家都是有逻辑头脑的，一个没有逻辑头脑的人总是很顽固。"</blockquote>\r\n请问结论是什么？\r\n\r\n这道题会用到新的概念：全集和空集。集合<code>A</code>和所有不属于它的元素（记作<code>-A</code>）构成全集（<code>I</code>），这时<code>A</code>和<code>-A</code>的交集就是一个空集（<code>0</code>）。\r\n<blockquote>A + (-A) = I\r\nA X (-A) = 0</blockquote>\r\n因此，有下面的公式。\r\n<blockquote>B\r\n= B X I\r\n= B X (A + -A)\r\n= B X A + B X (-A)</blockquote>\r\n回到上面那道题。\r\n<blockquote>哲学家 X 逻辑 = 哲学家\r\n无逻辑 X 顽固 = 无逻辑</blockquote>\r\n根据第一个命题，可以得到下面的结论。\r\n<blockquote>哲学家 X 无逻辑\r\n= (哲学家 X 逻辑) X 无逻辑\r\n= 哲学家 X (逻辑 X 无逻辑)\r\n= 哲学家 X 0\r\n= 0</blockquote>\r\n即哲学家与没有逻辑的人的交集，是一个空集。\r\n\r\n根据第二个命题，可以得到下面的结论。\r\n<blockquote>无逻辑 X 顽固\r\n= 无逻辑 X 顽固 X (哲学家 + 非哲学家)\r\n= 无逻辑 X 顽固 X 哲学家 + 无逻辑 X 顽固 X 非哲学家\r\n= 0 X 顽固 + 无逻辑 X 顽固 X 非哲学家\r\n= 无逻辑 X 顽固 X 非哲学家\r\n= 无逻辑</blockquote>\r\n也就是说，最终的结论如下。\r\n<blockquote>无逻辑 X 顽固 X 非哲学家 = 无逻辑\r\n// 相当于\r\n顽固 X 非哲学家 = 无逻辑 + 其他</blockquote>\r\n结论就是顽固的人与非哲学家之间有交集。通俗的表达就是：一些顽固的人，不是哲学家，或者一些不是哲学家的人，很顽固。\r\n\r\n由此可见，集合论可以帮助我们得到直觉无法得到的结论，保证推理过程正确，比文字推导更可靠。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016080506.jpg" alt="" />\r\n<h2>四、 集合论到布尔代数</h2>\r\n既然命题可以用集合论表达，那么逻辑推导无非就是一系列集合运算。\r\n\r\n由于集合运算的结果还是集合，那么通过判断个体是否属于指定集合，就可以计算命题的真伪。\r\n<blockquote>一名顾客走进宠物店，对店员说："我想要一只公猫，白色或黄色均可；或者一只母猫，除了白色，其他颜色均可；或者只要是黑猫，我也要。"</blockquote>\r\n这名顾客的要求用集合论表达，就是下面的式子。\r\n<blockquote>公猫 X (白色 + 黄色)\r\n+ 母猫 X 非白色\r\n+ 黑猫</blockquote>\r\n店员拿出一只灰色的公猫，请问是否满足要求？\r\n\r\n布尔代数规定，个体属于某个集合用<code>1</code>表示，不属于就用<code>0</code>表示。 灰色的公猫属于公猫集合，就是<code>1</code>，不属于白色集合，就是<code>0</code>。\r\n\r\n上面的表达式变成下面这样。\r\n<blockquote>1 X (0 + 0)\r\n+ 0 X 1\r\n+ 0\r\n= 0</blockquote>\r\n因此，就得到结论，灰色的公猫不满足要求。\r\n\r\n这就是布尔代数：计算命题真伪的数学方法。\r\n<h2>五、布尔代数的运算法则</h2>\r\n布尔代数的运算法则与集合论很像。\r\n\r\n交集的运算法则如下。\r\n<blockquote>1 X 1 = 1\r\n1 X 0 = 0\r\n0 X 0 = 0</blockquote>\r\n并集的运算法则如下。\r\n<blockquote>1 + 1 = 1\r\n1 + 0 = 1\r\n0 + 0 = 0</blockquote>\r\n集合论可以描述逻辑推理过程，布尔代数可以判断某个命题是否符合这个过程。人类的推理和判断，因此就变成了数学运算。\r\n\r\n20世纪初，英国科学家香农指出，布尔代数可以用来描述电路，或者说，电路可以模拟布尔代数。于是，人类的推理和判断，就可以用电路实现了。这就是计算机的实现基础。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016080504.gif" alt="" />\r\n<h2>六、布尔代数的局限</h2>\r\n虽然布尔代数可以判断命题真伪，但是无法取代人类的理性思维。原因是它有一个局限。\r\n\r\n它必须依据一个或几个已经明确知道真伪的命题，才能做出判断。比如，只有知道"所有人都会死"这个命题是真的，才能得出结论"苏格拉底会死"。\r\n\r\n布尔代数只能保证推理过程正确，无法保证推理所依据的前提是否正确。如果前提是错的，正确的推理也会得到错误的结果。而前提的真伪要由科学实验和观察来决定，布尔代数无能为力。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','布尔代数入门','','publish','open','open','','boolean-algebra','','','2016-11-01 16:42:06','2016-11-01 08:42:06','',0,'https://blog-scottwang.rhcloud.com/?p=46',0,'post','',0),
 (48,1,'2016-11-01 16:46:15','2016-11-01 08:46:15','from:\r\n<a href="http://www.ruanyifeng.com/blog/2016/06/dns.html">http://www.ruanyifeng.com/blog/2016/06/dns.html</a>\r\n<div id="entry-1892" class="entry-asset asset hentry"><article class="hentry">\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\nDNS 是互联网核心协议之一。不管是上网浏览，还是编程开发，都需要了解一点它的知识。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n本文详细介绍DNS的原理，以及如何运用工具软件观察它的运作。我的目标是，读完此文后，你就能完全理解DNS。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061513.png" alt="" />\r\n<h2>一、DNS 是什么？</h2>\r\nDNS （Domain Name System 的缩写）的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。\r\n\r\n举例来说，如果你要访问域名<code>math.stackexchange.com</code>，首先要通过DNS查出它的IP地址是<code>151.101.129.69</code>。\r\n\r\n如果你不清楚为什么一定要查出IP地址，才能进行网络通信，建议先阅读我写的<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank">《互联网协议入门》</a>。\r\n<h2>二、查询过程</h2>\r\n虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。\r\n\r\n工具软件<code>dig</code>可以显示整个查询过程。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ dig math<span class="token punctuation">.</span>stackexchange<span class="token punctuation">.</span>com\r\n</code></pre>\r\n</blockquote>\r\n上面的命令会输出六段信息。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061501.png" alt="" />\r\n\r\n第一段是查询参数和统计。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061502.png" alt="" />\r\n\r\n第二段是查询内容。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061503.png" alt="" />\r\n\r\n上面结果表示，查询域名<code>math.stackexchange.com</code>的<code>A</code>记录，<code>A</code>是address的缩写。\r\n\r\n第三段是DNS服务器的答复。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061504.png" alt="" />\r\n\r\n上面结果显示，<code>math.stackexchange.com</code>有四个<code>A</code>记录，即四个IP地址。<code>600</code>是TTL值（Time to live 的缩写），表示缓存时间，即600秒之内不用重新查询。\r\n\r\n第四段显示<code>stackexchange.com</code>的NS记录（Name Server的缩写），即哪些服务器负责管理<code>stackexchange.com</code>的DNS记录。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061505.png" alt="" />\r\n\r\n上面结果显示<code>stackexchange.com</code>共有四条NS记录，即四个域名服务器，向其中任一台查询就能知道<code>math.stackexchange.com</code>的IP地址是什么。\r\n\r\n第五段是上面四个域名服务器的IP地址，这是随着前一段一起返回的。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061506.png" alt="" />\r\n\r\n第六段是DNS服务器的一些传输信息。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061514.png" alt="" />\r\n\r\n上面结果显示，本机的DNS服务器是<code>192.168.1.253</code>，查询端口是53（DNS服务器的默认端口），以及回应长度是305字节。\r\n\r\n如果不想看到这么多内容，可以使用<code>+short</code>参数。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ dig <span class="token operator">+</span>short math<span class="token punctuation">.</span>stackexchange<span class="token punctuation">.</span>com\r\n\r\n<span class="token number">151.101</span><span class="token punctuation">.</span><span class="token number">129.69</span>\r\n<span class="token number">151.101</span><span class="token punctuation">.</span><span class="token number">65.69</span>\r\n<span class="token number">151.101</span><span class="token punctuation">.</span><span class="token number">193.69</span>\r\n<span class="token number">151.101</span><span class="token punctuation">.</span><span class="token number">1.69</span>\r\n</code></pre>\r\n</blockquote>\r\n上面命令只返回<code>math.stackexchange.com</code>对应的4个IP地址（即<code>A</code>记录）。\r\n<h2>三、DNS服务器</h2>\r\n下面我们根据前面这个例子，一步步还原，本机到底怎么得到域名<code>math.stackexchange.com</code>的IP地址。\r\n\r\n首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061507.jpg" alt="" />\r\n\r\nDNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在<code>/etc/resolv.conf</code>文件。\r\n\r\n上例的DNS服务器是<code>192.168.1.253</code>，这是一个内网地址。有一些公网的DNS服务器，也可以使用，其中最有名的就是Google的<a href="https://developers.google.com/speed/public-dns/" target="_blank"><code>8.8.8.8</code></a>和Level 3的<a href="https://www.tummy.com/articles/famous-dns-server/" target="_blank"><code>4.2.2.2</code></a>。\r\n\r\n本机只向自己的DNS服务器查询，<code>dig</code>命令有一个<code>@</code>参数，显示向其他DNS服务器查询的结果。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ dig @<span class="token number">4.2</span><span class="token punctuation">.</span><span class="token number">2.2</span> math<span class="token punctuation">.</span>stackexchange<span class="token punctuation">.</span>com\r\n</code></pre>\r\n</blockquote>\r\n上面命令指定向DNS服务器<code>4.2.2.2</code>查询。\r\n<h2>四、域名的层级</h2>\r\nDNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。\r\n\r\n请仔细看前面的例子，每个域名的尾部都多了一个点。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061503.png" alt="" />\r\n\r\n比如，域名<code>math.stackexchange.com</code>显示为<code>math.stackexchange.com.</code>。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。\r\n\r\n举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。\r\n\r\n根域名的下一级，叫做"顶级域名"（top-level domain，缩写为TLD），比如<code>.com</code>、<code>.net</code>；再下一级叫做"次级域名"（second-level domain，缩写为SLD），比如<code>www.example.com</code>里面的<code>.example</code>，这一级域名是用户可以注册的；再下一级是主机名（host），比如<code>www.example.com</code>里面的<code>www</code>，又称为"三级域名"，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。\r\n\r\n总结一下，域名的层级结构如下。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n主机名<span class="token punctuation">.</span>次级域名<span class="token punctuation">.</span>顶级域名<span class="token punctuation">.</span>根域名\r\n\r\n<span class="token comment" spellcheck="true"># 即\r\n</span>\r\nhost<span class="token punctuation">.</span>sld<span class="token punctuation">.</span>tld<span class="token punctuation">.</span>root\r\n</code></pre>\r\n</blockquote>\r\n<h2>五、根域名服务器</h2>\r\nDNS服务器根据域名的层级，进行分级查询。\r\n\r\n需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。\r\n\r\n所谓"分级查询"，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下。\r\n<blockquote>\r\n<ol start="1">\r\n 	<li>从"根域名服务器"查到"顶级域名服务器"的NS记录和A记录（IP地址）</li>\r\n 	<li>从"顶级域名服务器"查到"次级域名服务器"的NS记录和A记录（IP地址）</li>\r\n 	<li>从"次级域名服务器"查出"主机名"的IP地址</li>\r\n</ol>\r\n</blockquote>\r\n仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道"根域名服务器"的IP地址。回答是"根域名服务器"的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。\r\n\r\n下面是内置的根域名服务器IP地址的一个<a href="http://www.cyberciti.biz/faq/unix-linux-update-root-hints-data-file/" target="_blank">例子</a>。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061508.png" alt="" />\r\n\r\n上面列表中，列出了根域名（<code>.root</code>）的三条NS记录<code>A.ROOT-SERVERS.NET</code>、<code>B.ROOT-SERVERS.NET</code>和<code>C.ROOT-SERVERS.NET</code>，以及它们的IP地址（即<code>A</code>记录）<code>198.41.0.4</code>、<code>192.228.79.201</code>、<code>192.33.4.12</code>。\r\n\r\n另外，可以看到所有记录的TTL值是3600000秒，相当于1000小时。也就是说，每1000小时才查询一次根域名服务器的列表。\r\n\r\n目前，世界上一共有十三组根域名服务器，从<code>A.ROOT-SERVERS.NET</code>一直到<code>M.ROOT-SERVERS.NET</code>。\r\n<h2>六、分级查询的实例</h2>\r\n<code>dig</code>命令的<code>+trace</code>参数可以显示DNS的整个分级查询过程。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ dig <span class="token operator">+</span>trace math<span class="token punctuation">.</span>stackexchange<span class="token punctuation">.</span>com\r\n</code></pre>\r\n</blockquote>\r\n上面命令的第一段列出根域名<code>.</code>的所有NS记录，即所有根域名服务器。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061509.png" alt="" />\r\n\r\n根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问<code>math.stackexchange.com</code>的顶级域名服务器<code>com.</code>的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。\r\n\r\n接着是第二段。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061510.png" alt="" />\r\n\r\n上面结果显示<code>.com</code>域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。\r\n\r\n然后，DNS服务器向这些顶级域名服务器发出查询请求，询问<code>math.stackexchange.com</code>的次级域名<code>stackexchange.com</code>的NS记录。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061511.png" alt="" />\r\n\r\n上面结果显示<code>stackexchange.com</code>有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。\r\n\r\n然后，DNS服务器向上面这四台NS服务器查询<code>math.stackexchange.com</code>的主机名。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061512.png" alt="" />\r\n\r\n上面结果显示，<code>math.stackexchange.com</code>有4条<code>A</code>记录，即这四个IP地址都可以访问到网站。并且还显示，最先返回结果的NS服务器是<code>ns-463.awsdns-57.com</code>，IP地址为<code>205.251.193.207</code>。\r\n<h2>七、NS 记录的查询</h2>\r\n<code>dig</code>命令可以单独查看每一级域名的NS记录。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ dig ns com\r\n$ dig ns stackexchange<span class="token punctuation">.</span>com\r\n</code></pre>\r\n</blockquote>\r\n<code>+short</code>参数可以显示简化的结果。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ dig <span class="token operator">+</span>short ns com\r\n$ dig <span class="token operator">+</span>short ns stackexchange<span class="token punctuation">.</span>com\r\n</code></pre>\r\n</blockquote>\r\n<h2>八、DNS的记录类型</h2>\r\n域名与IP之间的对应关系，称为"记录"（record）。根据使用场景，"记录"可以分成不同的类型（type），前面已经看到了有<code>A</code>记录和<code>NS</code>记录。\r\n\r\n常见的DNS记录类型如下。\r\n<blockquote>（1） <code>A</code>：地址记录（Address），返回域名指向的IP地址。\r\n\r\n（2） <code>NS</code>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。\r\n\r\n（3）<code>MX</code>：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。\r\n\r\n（4）<code>CNAME</code>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。\r\n\r\n（5）<code>PTR</code>：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。</blockquote>\r\n一般来说，为了服务的安全可靠，至少应该有两条<code>NS</code>记录，而<code>A</code>记录和<code>MX</code>记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。\r\n\r\n<code>CNAME</code>记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，<code>facebook.github.io</code>这个域名就是一个<code>CNAME</code>记录。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ dig facebook<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io\r\n\r\n<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\r\n\r\n<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION<span class="token punctuation">:</span>\r\nfacebook<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span> <span class="token number">3370</span>    IN  CNAME   github<span class="token punctuation">.</span>map<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net<span class="token punctuation">.</span>\r\ngithub<span class="token punctuation">.</span>map<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net<span class="token punctuation">.</span>  <span class="token number">600</span> IN  A   <span class="token number">103.245</span><span class="token punctuation">.</span><span class="token number">222.133</span>\r\n</code></pre>\r\n</blockquote>\r\n上面结果显示，<code>facebook.github.io</code>的CNAME记录指向<code>github.map.fastly.net</code>。也就是说，用户查询<code>facebook.github.io</code>的时候，实际上返回的是<code>github.map.fastly.net</code>的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改<code>github.map.fastly.net</code>这个域名就可以了，用户的<code>facebook.github.io</code>域名不用修改。\r\n\r\n由于<code>CNAME</code>记录就是一个替换，所以域名一旦设置<code>CNAME</code>记录以后，就不能再设置其他记录了（比如<code>A</code>记录和<code>MX</code>记录），这是为了防止产生冲突。举例来说，<code>foo.com</code>指向<code>bar.com</code>，而两个域名各有自己的<code>MX</code>记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置<code>MX</code>记录，所以一般不允许用户对顶级域名设置<code>CNAME</code>记录。\r\n\r\n<code>PTR</code>记录用于从IP地址反查域名。<code>dig</code>命令的<code>-x</code>参数用于查询<code>PTR</code>记录。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ dig <span class="token operator">-</span>x <span class="token number">192.30</span><span class="token punctuation">.</span><span class="token number">252.153</span>\r\n\r\n<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\r\n\r\n<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION<span class="token punctuation">:</span>\r\n<span class="token number">153.252</span><span class="token punctuation">.</span><span class="token number">30.192</span><span class="token punctuation">.</span><span class="token keyword">in</span><span class="token operator">-</span>addr<span class="token punctuation">.</span>arpa<span class="token punctuation">.</span> <span class="token number">3600</span> IN    PTR pages<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token punctuation">.</span>\r\n</code></pre>\r\n</blockquote>\r\n上面结果显示，<code>192.30.252.153</code>这台服务器的域名是<code>pages.github.com</code>。\r\n\r\n逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有它所声称的域名。\r\n\r\n<code>dig</code>命令可以查看指定的记录类型。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ dig a github<span class="token punctuation">.</span>com\r\n$ dig ns github<span class="token punctuation">.</span>com\r\n$ dig mx github<span class="token punctuation">.</span>com\r\n</code></pre>\r\n</blockquote>\r\n<h2>九、其他DNS工具</h2>\r\n除了<code>dig</code>，还有一些其他小工具也可以使用。\r\n\r\n<strong>（1）host 命令</strong>\r\n\r\n<code>host</code>命令可以看作<code>dig</code>命令的简化版本，返回当前请求域名的各种记录。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ host github<span class="token punctuation">.</span>com\r\n\r\ngithub<span class="token punctuation">.</span>com has address <span class="token number">192.30</span><span class="token punctuation">.</span><span class="token number">252.121</span>\r\ngithub<span class="token punctuation">.</span>com mail is handled by <span class="token number">5</span> ALT2<span class="token punctuation">.</span>ASPMX<span class="token punctuation">.</span>L<span class="token punctuation">.</span>GOOGLE<span class="token punctuation">.</span>COM<span class="token punctuation">.</span>\r\ngithub<span class="token punctuation">.</span>com mail is handled by <span class="token number">10</span> ALT4<span class="token punctuation">.</span>ASPMX<span class="token punctuation">.</span>L<span class="token punctuation">.</span>GOOGLE<span class="token punctuation">.</span>COM<span class="token punctuation">.</span>\r\ngithub<span class="token punctuation">.</span>com mail is handled by <span class="token number">10</span> ALT3<span class="token punctuation">.</span>ASPMX<span class="token punctuation">.</span>L<span class="token punctuation">.</span>GOOGLE<span class="token punctuation">.</span>COM<span class="token punctuation">.</span>\r\ngithub<span class="token punctuation">.</span>com mail is handled by <span class="token number">5</span> ALT1<span class="token punctuation">.</span>ASPMX<span class="token punctuation">.</span>L<span class="token punctuation">.</span>GOOGLE<span class="token punctuation">.</span>COM<span class="token punctuation">.</span>\r\ngithub<span class="token punctuation">.</span>com mail is handled by <span class="token number">1</span> ASPMX<span class="token punctuation">.</span>L<span class="token punctuation">.</span>GOOGLE<span class="token punctuation">.</span>COM<span class="token punctuation">.</span>\r\n\r\n$ host facebook<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com\r\n\r\nfacebook<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com is an alias <span class="token keyword">for</span> github<span class="token punctuation">.</span>map<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net<span class="token punctuation">.</span>\r\ngithub<span class="token punctuation">.</span>map<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net has address <span class="token number">103.245</span><span class="token punctuation">.</span><span class="token number">222.133</span>\r\n</code></pre>\r\n</blockquote>\r\n<code>host</code>命令也可以用于逆向查询，即从IP地址查询域名，等同于<code>dig -x &lt;ip&gt;</code>。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ host <span class="token number">192.30</span><span class="token punctuation">.</span><span class="token number">252.153</span>\r\n\r\n<span class="token number">153.252</span><span class="token punctuation">.</span><span class="token number">30.192</span><span class="token punctuation">.</span><span class="token keyword">in</span><span class="token operator">-</span>addr<span class="token punctuation">.</span>arpa domain name pointer pages<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token punctuation">.</span>\r\n</code></pre>\r\n</blockquote>\r\n<strong>（2）nslookup 命令</strong>\r\n\r\n<code>nslookup</code>命令用于互动式地查询域名记录。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ nslookup\r\n\r\n<span class="token operator">&gt;</span> facebook<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io\r\nServer<span class="token punctuation">:</span>     <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">1.253</span>\r\nAddress<span class="token punctuation">:</span>    <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">1.253</span><span class="token comment" spellcheck="true">#53\r\n</span>\r\nNon<span class="token operator">-</span>authoritative answer<span class="token punctuation">:</span>\r\nfacebook<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io  canonical name <span class="token operator">=</span> github<span class="token punctuation">.</span>map<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net<span class="token punctuation">.</span>\r\nName<span class="token punctuation">:</span>   github<span class="token punctuation">.</span>map<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net\r\nAddress<span class="token punctuation">:</span> <span class="token number">103.245</span><span class="token punctuation">.</span><span class="token number">222.133</span>\r\n\r\n<span class="token operator">&gt;</span> \r\n</code></pre>\r\n</blockquote>\r\n<strong>（3）whois 命令</strong>\r\n\r\n<code>whois</code>命令用来查看域名的注册情况。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ whois github<span class="token punctuation">.</span>com\r\n</code></pre>\r\n</blockquote>\r\n<h1>十、参考链接</h1>\r\n<ul>\r\n 	<li><a href="https://www.petekeen.net/dns-the-good-parts" target="_blank">DNS: The Good Parts</a>, by Pete Keen</li>\r\n 	<li><a href="http://www.integralist.co.uk/posts/dnsbasics.html" target="_blank">DNS 101</a>, by Mark McDonnell</li>\r\n</ul>\r\n（完）\r\n\r\n</div>\r\n</article></div>','DNS原理入门','','publish','open','open','','dns','','','2016-11-01 16:46:15','2016-11-01 08:46:15','',0,'https://blog-scottwang.rhcloud.com/?p=48',0,'post','',0),
 (50,1,'2016-11-01 16:49:44','2016-11-01 08:49:44','from:\r\n<a href="http://www.ruanyifeng.com/blog/2015/09/0x7c00.html">http://www.ruanyifeng.com/blog/2015/09/0x7c00.html</a>\r\n<div class="asset-meta"></div>\r\n<div class="asset-meta"></div>\r\n<article class="hentry">\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n《计算机原理》课本说，启动时，<a href="https://en.wikipedia.org/wiki/Master_boot_record" target="_blank">主引导记录</a>会存入内存地址0x7C00。\r\n\r\n这个奇怪的地址，是怎么来的，课本就不解释了。我一直有疑问，为什么不存入内存的头部、尾部、或者其他位置，而偏偏存入这个比 32KB 小1024字节的地方？\r\n\r\n昨天，我读到一篇<a href="http://www.glamenv-septzen.net/en/view/6" target="_blank">文章</a>，终于解开了这个谜。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015092804.png" alt="" />\r\n\r\n首先，如果你不知道，主引导记录（Master boot record，缩写为MBR）是什么，可以先读<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank">《计算机是如何启动的？》</a>。\r\n\r\n简单说，计算机启动是这样一个过程。\r\n<blockquote>\r\n<ol start="1">\r\n 	<li>通电</li>\r\n 	<li>读取ROM里面的BIOS，用来检查硬件</li>\r\n 	<li>硬件检查通过</li>\r\n 	<li><strong>BIOS根据指定的顺序，检查引导设备的第一个扇区（即主引导记录），加载在内存地址 0x7C00</strong></li>\r\n 	<li>主引导记录把操作权交给操作系统</li>\r\n</ol>\r\n</blockquote>\r\n<strong>所以，主引导记录就是引导"操作系统"进入内存的一段小程序，大小不超过1个扇区（512字节）。</strong>\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015092802-1.jpg" alt="" />\r\n\r\n0x7C00这个地址来自Intel的第一代个人电脑芯片<a href="https://en.wikipedia.org/wiki/Intel_8088" target="_blank">8088</a>，以后的CPU为了保持兼容，一直使用这个地址。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015092801-1.jpg" alt="" />\r\n\r\n1981年8月，IBM公司最早的个人电脑IBM PC 5150上市，就用了这个芯片。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015092803.png" alt="" />\r\n\r\n当时，搭配的操作系统是<a href="https://en.wikipedia.org/wiki/86-DOS" target="_blank">86-DOS</a>。这个操作系统需要的内存最少是32KB。我们知道，内存地址从0x0000开始编号，32KB的内存就是<code>0x0000～0x7FFF</code>。\r\n\r\n8088芯片本身需要占用<code>0x0000～0x03FF</code>，用来保存<a href="https://en.wikipedia.org/wiki/BIOS_interrupt_call" target="_blank">各种中断处理程序</a>的储存位置。（主引导记录本身就是中断信号INT 19h的处理程序。）所以，内存只剩下<code>0x0400～0x7FFF</code>可以使用。\r\n\r\n<strong>为了把尽量多的连续内存留给操作系统，主引导记录就被放到了内存地址的尾部。</strong>由于一个扇区是512字节，主引导记录本身也会产生数据，需要另外留出512字节保存。所以，它的预留位置就变成了：\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n  <span class="token number">0x7FFF</span> <span class="token operator">-</span> <span class="token number">512</span> <span class="token operator">-</span> <span class="token number">512</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0x7C00</span> \r\n</code></pre>\r\n</blockquote>\r\n0x7C00就是这样来的。\r\n\r\n计算机启动后，32KB内存的使用情况如下。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token operator">+-</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token number">0x0</span>\r\n<span class="token operator">|</span> Interrupts vectors\r\n<span class="token operator">+-</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token number">0x400</span>\r\n<span class="token operator">|</span> BIOS data area\r\n<span class="token operator">+-</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token number">0x5</span><span class="token operator">?</span><span class="token operator">?</span>\r\n<span class="token operator">|</span> OS load area\r\n<span class="token operator">+-</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token number">0x7C00</span>\r\n<span class="token operator">|</span> Boot sector\r\n<span class="token operator">+-</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token number">0x7E00</span>\r\n<span class="token operator">|</span> Boot data<span class="token operator">/</span>stack\r\n<span class="token operator">+-</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token number">0x7FFF</span>\r\n<span class="token operator">|</span> <span class="token punctuation">(</span>not used<span class="token punctuation">)</span>\r\n<span class="token operator">+-</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>\r\n</code></pre>\r\n</blockquote>\r\n（完）\r\n\r\n</div>\r\n</article>','为什么主引导记录的内存地址是0x7C00','','publish','open','open','','0x7c00','','','2016-11-01 16:49:44','2016-11-01 08:49:44','',0,'https://blog-scottwang.rhcloud.com/?p=50',0,'post','',0),
 (52,1,'2016-11-01 16:55:36','0000-00-00 00:00:00','from:\n<a href="http://www.glamenv-septzen.net/en/view/6" target="_blank">http://www.glamenv-septzen.net/en/view/6</a>\n<div class="data_body">\n<h3 id="id1ba83e">The mysteries arround "0x7C00" in x86 architecture bios bootloader</h3>\n<p class="paragraph">Do you know "0x7C00", a magic number, in x86 assembler programming ?\n\n"0x7C00" is the memory address which BIOS loads MBR(Master Boot Record, a first sector in hdd/fdd) into. OS or bootloader developer must assume that their assembler codes are loaded and start from 0x7C00.\n</p>\n<p class="paragraph">But...<strong>1st</strong>, you may wonder.\n</p>\n\n<blockquote>\n<p class="paragraph">"I read all of Intel x86(32bit) programmers manual, but did not found the magic number 0x7C00."\n</p>\n</blockquote>\n<p class="paragraph">Yes.<strong>0x7C00 is NOT related to x86 CPU</strong>. It\'s natural that you couldn\'t find out it in cpu specifications from intel. Then, you wonder, "Who decided it ?"\n</p>\n<p class="paragraph"><strong>2nd</strong>, you may wonder:\n</p>\n\n<blockquote>\n<p class="paragraph">"0x7C00 is 32KiB - 1024B at decimal number. What\'s this number means ?"\n</p>\n</blockquote>\n<p class="paragraph">Anyone decided it. But, why he/she decided such a halfway address?\n</p>\n<p class="paragraph">Hum...There\'re TWO questions(mysteries) arround the magic number "0x7C00".\n</p>\n\n<ol>\n 	<li>Who decided "0x7C00" ?</li>\n 	<li>What "0x7C00 = 32KiB - 1024B" means ?</li>\n</ol>\n<p class="paragraph">Okay, let\'s dive into the secret of BIOS for "IBM PC 5150", ancestor of modern x86(32bit) PCs, with me...!!\n</p>\n\n<h3 id="ida6dff8">"0x7C00" First appeared in IBM PC 5150 ROM BIOS INT 19h handler.</h3>\n<p class="paragraph">Wandering arround the history of x86 IBM Compatible PC, you know <strong>IBM PC 5150</strong> is the ancestor of modern x86(32bit) IBM PC/AT Compatible PCs.\n\nThis PC was released at 1981 August, with Intel 8088(16bit) and 16KiB RAM(for minimum memory model). BIOS and Microsoft BASIC was stored in ROM.\n</p>\n<p class="paragraph">When power on, BIOS processes "POST"(Power On Self Test) procedure, and after, <strong>call INT 19h</strong>.\n\nIn INT 19h handler, BIOS checks that PC has any of floppy/hard/fixed diskette or not have.\n\nIf PC has any of available diskkete, BIOS loads a first sector(512B) of diskette into 0x7C00.\n</p>\n<p class="paragraph">Now, you understand why you couldn\'t find out this magic number in x86 documents. <strong>This magic number belongs to BIOS specification.</strong>\n</p>\n\n<h3 id="id44778c">The origin of 0x7C00</h3>\n<p class="paragraph">Stories surrounding IBM PC DOS, Microsoft, and SCP\'s 86-DOS are famous stories. See: <a class="externallink" href="http://www.patersontech.com/dos/Byte/History.html" target="_blank">"A Short History of MS-DOS"</a>.\n</p>\n<p class="paragraph">SCP\'s "86-DOS"(at 1980) is the reference OS for IBM PC DOS 1.0.\n\n86-DOS(early called "QDOS") is CP/M compatible OS for 8086/8088 cpu. At 1979, Digital Research Inc didn\'t have developed CP/M for 8086/8088 cpu yet.\n</p>\n<p class="paragraph">SCP sold two S-100 bus board, one is 8086 CPU board, two is "CPU Monitor" rom board.\n\n"CPU Monitor" program provided bootloader and debugger. <strong>This "CPU Monitor" bootloader loaded MBR into "0x200", NOT "0x7C00"</strong>. In 1981, IBM PC DOS was the NEXT CP/M like OS for 8086/8088.\n</p>\n<p class="paragraph">So, I told you that "0x7C00 <strong>FIRST appeared</strong> in IBM PC 5150 ROM BIOS".\n\nPrevious one, SCP\'s CPU Monitor bootloader loads into 0x200, not 0x7C00.\n</p>\n\n<h4 id="id16b25f">Why that CPU Monitor\'s bootloader loeded MBR into "0x200" ?</h4>\n<p class="paragraph">There\'re THREE reasons about "0x200".\n</p>\n\n<ol>\n 	<li>8086 Interrupts Vector use 0x0 - 0x3FF.</li>\n 	<li>86-DOS was loaded from 0x400.</li>\n 	<li>86-DOS didn\'t use interrupts vectors between 0x200 - 0x3FF.</li>\n</ol>\n<p class="paragraph">These reasons mean 0x200 - 0x3FF needed to be reserved and couldn\'t be in the way of an OS, no matter where 86-DOS or user application wanted to load.\n</p>\n<p class="paragraph">So Tim Paterson (86-DOS developer) chose 0x200 for MBR load address.\n</p>\n\n<h3 id="idfb1114">Q:Who decided "0x7C00" ? - A: IBM PC 5150 BIOS Developer Team.</h3>\n<p class="paragraph">"0x7C00" was decided by IBM PC 5150 BIOS developer team (Dr. David Bradley).\n\nAs mentioned above, this magic number was born at 1981 and "IBM PC/AT Compat" PC/BIOS vendors did not change this value for BIOS and OS\'s backward compatibility.\n</p>\n<p class="paragraph">Not Intel(8086/8088 vendor) nor Microsoft(OS vendor) decided it.\n</p>\n\n<h3 id="id998b47">Q:What "0x7C00 = 32KiB - 1024B" means ? A: Affected by OS requirements and CPU memory layout.</h3>\n<p class="paragraph">IBM PC 5150 minimum memory model had only 16KiB RAM. So, you may have a question.\n</p>\n\n<blockquote>\n<p class="paragraph">"Could minimum memory model (16KiB) load OS from diskette ? BIOS loads MBR into 32KiB - 1024B address, but physical RAM is not enough..."\n</p>\n</blockquote>\n<p class="paragraph">No, that case was <strong>out of consideration</strong>. One of IBM PC 5150 ROM BIOS Developer Team Members, Dr. David Bradley says:\n</p>\n\n<blockquote>\n<p class="paragraph">"DOS 1.0 required a minimum of 32KB, so we weren\'t concerned about attempting a boot in 16KB."\n</p>\n</blockquote>\n<p class="paragraph">(Note: DOS 1.0 required 16KiB minimum ? or 32KiB ? I couldn\'t find out which correct. But, at least, in 1981\'s early BIOS development, they supposed that 32KiB is DOS minimum requirements.)\n</p>\n<p class="paragraph">BIOS developer team decided 0x7C00 because:\n</p>\n\n<ol>\n 	<li>They wanted to leave as much room as possible for the OS to load itself within the 32KiB.</li>\n 	<li>8086/8088 used 0x0 - 0x3FF for interrupts vector, and BIOS data area was after it.</li>\n 	<li>The boot sector was 512 bytes, and stack/data area for boot program needed more 512 bytes.</li>\n 	<li>So, 0x7C00, the last 1024B of 32KiB was chosen.</li>\n</ol>\n<p class="paragraph">Once OS loaded and started, boot sector is never used until power reset. So, OS and application can use the last 1024B of 32KiB freely.\n</p>\n<p class="paragraph">After OS loaded, memory layout will be:\n</p>\n\n<pre class="plugin_pre">+--------------------- 0x0\n| Interrupts vectors\n+--------------------- 0x400\n| BIOS data area\n+--------------------- 0x5??\n| OS load area\n+--------------------- 0x7C00\n| Boot sector\n+--------------------- 0x7E00\n| Boot data/stack\n+--------------------- 0x7FFF\n| (not used)\n+--------------------- (...)\n</pre>\n<p class="paragraph">That are the origin and reasons of "0x7C00", the magic number survived for about three decades in PC/AT Compat BIOS INT 19h handler.\n</p>\n\n<h3 id="idfa476e">References</h3>\n<p class="paragraph">86-DOS related:\n</p>\n\n<ul>\n 	<li>"8086 Monitor Instruction Manual"(MON 86 - V1.4)</li>\n 	<li>"86-DOS(TM) User\'s Manual Version 0.3"</li>\n 	<li>"86-DOS(TM) Programmer\'s Manual Version 0.3"</li>\n 	<li>"86-DOS(TM) Instruction Manual Version ??"</li>\n</ul>\n<p class="paragraph">IBM PC 5150 related:\n</p>\n\n<ul>\n 	<li>"IBM Personal Computer Hardware Reference Library", "Technical Reference" (IBM Personal Computer Technical Reference manual)</li>\n 	<li>"IBM Personal Computer XT Hardware Reference Library", "Technical Reference" (IBM Personal Computer XT Technical Reference manual)</li>\n</ul>\n<p class="paragraph">Intel 8086/8088 data sheets:\n</p>\n\n<ul>\n 	<li>"8086 16-BIT HMOS MICROPROCESSOR"</li>\n 	<li>"M80C86/M80C86-2 16-BIT CHMOS MICROPROCESSOR"</li>\n 	<li>"8088 8-BIT HMOS MICROPROCESSOR"</li>\n</ul>\n<p class="paragraph">CP/M related:\n</p>\n\n<ul>\n 	<li>The Unofficial CP/M Web Site\n<ul>\n 	<li><a class="externallink" href="http://www.cpm.z80.de/" target="_blank">http://www.cpm.z80.de/</a></li>\n</ul>\n</li>\n 	<li>CP/M Internals : Oscar Vermeulen Personal Web Site\n<ul>\n 	<li><a class="externallink" href="http://www.dcast.vbox.co.uk/cpm.html" target="_blank">http://www.dcast.vbox.co.uk/cpm.html</a></li>\n</ul>\n</li>\n 	<li>Digital Research - CP/M\n<ul>\n 	<li><a class="externallink" href="http://www.digitalresearch.biz/CPM.HTM" target="_blank">http://www.digitalresearch.biz/CPM.HTM</a></li>\n</ul>\n</li>\n 	<li>CP/M Main Page\n<ul>\n 	<li><a class="externallink" href="http://www.seasip.demon.co.uk/Cpm/" target="_blank">http://www.seasip.demon.co.uk/Cpm/</a></li>\n</ul>\n</li>\n</ul>\n<p class="paragraph">86-DOS related:\n</p>\n\n<ul>\n 	<li>Origins of DOS - Paterson Technology\n<ul>\n 	<li><a class="externallink" href="http://www.patersontech.com/dos/" target="_blank">http://www.patersontech.com/dos/</a></li>\n</ul>\n</li>\n 	<li>86-DOS Resource Website\n<ul>\n 	<li><a class="externallink" href="http://www.86dos.org/index.htm" target="_blank">http://www.86dos.org/index.htm</a></li>\n</ul>\n</li>\n 	<li>DosMan Drivel\n<ul>\n 	<li><a class="externallink" href="http://dosmandrivel.blogspot.com/" target="_blank">http://dosmandrivel.blogspot.com/</a></li>\n</ul>\n</li>\n</ul>\n<p class="paragraph">And all related Wikipedia pages.\n</p>\n\n<h3 id="id670482">Special Thanks To...</h3>\n<p class="paragraph">Special Thanks To:\n</p>\n\n<ul>\n 	<li>Tim Peterson</li>\n 	<li>David Bradley</li>\n</ul>\n<p class="paragraph">for japanese article, see:\n\n"Assembler/なぜx86ではMBRが"0x7C00"にロードされるのか？(完全版)"\n\n<a class="externallink" href="http://www.glamenv-septzen.net/view/614" target="_blank">http://www.glamenv-septzen.net/view/614</a></p>\n\n<a style="font-size: small;" href="http://www.glamenv-septzen.net/en/index.php?mdl=raw&amp;id=6">download as plain text</a>\n\n</div>','Why BIOS loads MBR into 0x7C00 in x86 ?','','draft','open','open','','','','','2016-11-01 16:55:36','2016-11-01 08:55:36','',0,'https://blog-scottwang.rhcloud.com/?p=52',0,'post','',0),
 (53,1,'2016-11-01 16:58:41','2016-11-01 08:58:41','from:\r\n<a href="http://www.glamenv-septzen.net/en/view/6" target="_blank">http://www.glamenv-septzen.net/en/view/6</a>\r\n<h3 id="id1ba83e">The mysteries arround "0x7C00" in x86 architecture bios bootloader</h3>\r\n<p class="paragraph">Do you know "0x7C00", a magic number, in x86 assembler programming ?\r\n"0x7C00" is the memory address which BIOS loads MBR(Master Boot Record, a first sector in hdd/fdd) into. OS or bootloader developer must assume that their assembler codes are loaded and start from 0x7C00.</p>\r\n<p class="paragraph">But...<strong>1st</strong>, you may wonder.</p>\r\n\r\n<blockquote>\r\n<p class="paragraph">"I read all of Intel x86(32bit) programmers manual, but did not found the magic number 0x7C00."</p>\r\n</blockquote>\r\n<p class="paragraph">Yes.<strong>0x7C00 is NOT related to x86 CPU</strong>. It\'s natural that you couldn\'t find out it in cpu specifications from intel. Then, you wonder, "Who decided it ?"</p>\r\n<p class="paragraph"><strong>2nd</strong>, you may wonder:</p>\r\n\r\n<blockquote>\r\n<p class="paragraph">"0x7C00 is 32KiB - 1024B at decimal number. What\'s this number means ?"</p>\r\n</blockquote>\r\n<p class="paragraph">Anyone decided it. But, why he/she decided such a halfway address?</p>\r\n<p class="paragraph">Hum...There\'re TWO questions(mysteries) arround the magic number "0x7C00".</p>\r\n\r\n<ol>\r\n 	<li>Who decided "0x7C00" ?</li>\r\n 	<li>What "0x7C00 = 32KiB - 1024B" means ?</li>\r\n</ol>\r\n<p class="paragraph">Okay, let\'s dive into the secret of BIOS for "IBM PC 5150", ancestor of modern x86(32bit) PCs, with me...!!</p>\r\n\r\n<h3 id="ida6dff8">"0x7C00" First appeared in IBM PC 5150 ROM BIOS INT 19h handler.</h3>\r\n<p class="paragraph">Wandering arround the history of x86 IBM Compatible PC, you know <strong>IBM PC 5150</strong> is the ancestor of modern x86(32bit) IBM PC/AT Compatible PCs.\r\nThis PC was released at 1981 August, with Intel 8088(16bit) and 16KiB RAM(for minimum memory model). BIOS and Microsoft BASIC was stored in ROM.</p>\r\n<p class="paragraph">When power on, BIOS processes "POST"(Power On Self Test) procedure, and after, <strong>call INT 19h</strong>.\r\nIn INT 19h handler, BIOS checks that PC has any of floppy/hard/fixed diskette or not have.\r\nIf PC has any of available diskkete, BIOS loads a first sector(512B) of diskette into 0x7C00.</p>\r\n<p class="paragraph">Now, you understand why you couldn\'t find out this magic number in x86 documents. <strong>This magic number belongs to BIOS specification.</strong></p>\r\n\r\n<h3 id="id44778c">The origin of 0x7C00</h3>\r\n<p class="paragraph">Stories surrounding IBM PC DOS, Microsoft, and SCP\'s 86-DOS are famous stories. See: <a class="externallink" href="http://www.patersontech.com/dos/Byte/History.html" target="_blank">"A Short History of MS-DOS"</a>.</p>\r\n<p class="paragraph">SCP\'s "86-DOS"(at 1980) is the reference OS for IBM PC DOS 1.0.\r\n86-DOS(early called "QDOS") is CP/M compatible OS for 8086/8088 cpu. At 1979, Digital Research Inc didn\'t have developed CP/M for 8086/8088 cpu yet.</p>\r\n<p class="paragraph">SCP sold two S-100 bus board, one is 8086 CPU board, two is "CPU Monitor" rom board.\r\n"CPU Monitor" program provided bootloader and debugger. <strong>This "CPU Monitor" bootloader loaded MBR into "0x200", NOT "0x7C00"</strong>. In 1981, IBM PC DOS was the NEXT CP/M like OS for 8086/8088.</p>\r\n<p class="paragraph">So, I told you that "0x7C00 <strong>FIRST appeared</strong> in IBM PC 5150 ROM BIOS".\r\nPrevious one, SCP\'s CPU Monitor bootloader loads into 0x200, not 0x7C00.</p>\r\n\r\n<h4 id="id16b25f">Why that CPU Monitor\'s bootloader loeded MBR into "0x200" ?</h4>\r\n<p class="paragraph">There\'re THREE reasons about "0x200".</p>\r\n\r\n<ol>\r\n 	<li>8086 Interrupts Vector use 0x0 - 0x3FF.</li>\r\n 	<li>86-DOS was loaded from 0x400.</li>\r\n 	<li>86-DOS didn\'t use interrupts vectors between 0x200 - 0x3FF.</li>\r\n</ol>\r\n<p class="paragraph">These reasons mean 0x200 - 0x3FF needed to be reserved and couldn\'t be in the way of an OS, no matter where 86-DOS or user application wanted to load.</p>\r\n<p class="paragraph">So Tim Paterson (86-DOS developer) chose 0x200 for MBR load address.</p>\r\n\r\n<h3 id="idfb1114">Q:Who decided "0x7C00" ? - A: IBM PC 5150 BIOS Developer Team.</h3>\r\n<p class="paragraph">"0x7C00" was decided by IBM PC 5150 BIOS developer team (Dr. David Bradley).\r\nAs mentioned above, this magic number was born at 1981 and "IBM PC/AT Compat" PC/BIOS vendors did not change this value for BIOS and OS\'s backward compatibility.</p>\r\n<p class="paragraph">Not Intel(8086/8088 vendor) nor Microsoft(OS vendor) decided it.</p>\r\n\r\n<h3 id="id998b47">Q:What "0x7C00 = 32KiB - 1024B" means ? A: Affected by OS requirements and CPU memory layout.</h3>\r\n<p class="paragraph">IBM PC 5150 minimum memory model had only 16KiB RAM. So, you may have a question.</p>\r\n\r\n<blockquote>\r\n<p class="paragraph">"Could minimum memory model (16KiB) load OS from diskette ? BIOS loads MBR into 32KiB - 1024B address, but physical RAM is not enough..."</p>\r\n</blockquote>\r\n<p class="paragraph">No, that case was <strong>out of consideration</strong>. One of IBM PC 5150 ROM BIOS Developer Team Members, Dr. David Bradley says:</p>\r\n\r\n<blockquote>\r\n<p class="paragraph">"DOS 1.0 required a minimum of 32KB, so we weren\'t concerned about attempting a boot in 16KB."</p>\r\n</blockquote>\r\n<p class="paragraph">(Note: DOS 1.0 required 16KiB minimum ? or 32KiB ? I couldn\'t find out which correct. But, at least, in 1981\'s early BIOS development, they supposed that 32KiB is DOS minimum requirements.)</p>\r\n<p class="paragraph">BIOS developer team decided 0x7C00 because:</p>\r\n\r\n<ol>\r\n 	<li>They wanted to leave as much room as possible for the OS to load itself within the 32KiB.</li>\r\n 	<li>8086/8088 used 0x0 - 0x3FF for interrupts vector, and BIOS data area was after it.</li>\r\n 	<li>The boot sector was 512 bytes, and stack/data area for boot program needed more 512 bytes.</li>\r\n 	<li>So, 0x7C00, the last 1024B of 32KiB was chosen.</li>\r\n</ol>\r\n<p class="paragraph">Once OS loaded and started, boot sector is never used until power reset. So, OS and application can use the last 1024B of 32KiB freely.</p>\r\n<p class="paragraph">After OS loaded, memory layout will be:</p>\r\n\r\n<pre class="plugin_pre">+--------------------- 0x0\r\n| Interrupts vectors\r\n+--------------------- 0x400\r\n| BIOS data area\r\n+--------------------- 0x5??\r\n| OS load area\r\n+--------------------- 0x7C00\r\n| Boot sector\r\n+--------------------- 0x7E00\r\n| Boot data/stack\r\n+--------------------- 0x7FFF\r\n| (not used)\r\n+--------------------- (...)\r\n</pre>\r\n<p class="paragraph">That are the origin and reasons of "0x7C00", the magic number survived for about three decades in PC/AT Compat BIOS INT 19h handler.</p>\r\n\r\n<h3 id="idfa476e">References</h3>\r\n<p class="paragraph">86-DOS related:</p>\r\n\r\n<ul>\r\n 	<li>"8086 Monitor Instruction Manual"(MON 86 - V1.4)</li>\r\n 	<li>"86-DOS(TM) User\'s Manual Version 0.3"</li>\r\n 	<li>"86-DOS(TM) Programmer\'s Manual Version 0.3"</li>\r\n 	<li>"86-DOS(TM) Instruction Manual Version ??"</li>\r\n</ul>\r\n<p class="paragraph">IBM PC 5150 related:</p>\r\n\r\n<ul>\r\n 	<li>"IBM Personal Computer Hardware Reference Library", "Technical Reference" (IBM Personal Computer Technical Reference manual)</li>\r\n 	<li>"IBM Personal Computer XT Hardware Reference Library", "Technical Reference" (IBM Personal Computer XT Technical Reference manual)</li>\r\n</ul>\r\n<p class="paragraph">Intel 8086/8088 data sheets:</p>\r\n\r\n<ul>\r\n 	<li>"8086 16-BIT HMOS MICROPROCESSOR"</li>\r\n 	<li>"M80C86/M80C86-2 16-BIT CHMOS MICROPROCESSOR"</li>\r\n 	<li>"8088 8-BIT HMOS MICROPROCESSOR"</li>\r\n</ul>\r\n<p class="paragraph">CP/M related:</p>\r\n\r\n<ul>\r\n 	<li>The Unofficial CP/M Web Site\r\n<ul>\r\n 	<li><a class="externallink" href="http://www.cpm.z80.de/" target="_blank">http://www.cpm.z80.de/</a></li>\r\n</ul>\r\n</li>\r\n 	<li>CP/M Internals : Oscar Vermeulen Personal Web Site\r\n<ul>\r\n 	<li><a class="externallink" href="http://www.dcast.vbox.co.uk/cpm.html" target="_blank">http://www.dcast.vbox.co.uk/cpm.html</a></li>\r\n</ul>\r\n</li>\r\n 	<li>Digital Research - CP/M\r\n<ul>\r\n 	<li><a class="externallink" href="http://www.digitalresearch.biz/CPM.HTM" target="_blank">http://www.digitalresearch.biz/CPM.HTM</a></li>\r\n</ul>\r\n</li>\r\n 	<li>CP/M Main Page\r\n<ul>\r\n 	<li><a class="externallink" href="http://www.seasip.demon.co.uk/Cpm/" target="_blank">http://www.seasip.demon.co.uk/Cpm/</a></li>\r\n</ul>\r\n</li>\r\n</ul>\r\n<p class="paragraph">86-DOS related:</p>\r\n\r\n<ul>\r\n 	<li>Origins of DOS - Paterson Technology\r\n<ul>\r\n 	<li><a class="externallink" href="http://www.patersontech.com/dos/" target="_blank">http://www.patersontech.com/dos/</a></li>\r\n</ul>\r\n</li>\r\n 	<li>86-DOS Resource Website\r\n<ul>\r\n 	<li><a class="externallink" href="http://www.86dos.org/index.htm" target="_blank">http://www.86dos.org/index.htm</a></li>\r\n</ul>\r\n</li>\r\n 	<li>DosMan Drivel\r\n<ul>\r\n 	<li><a class="externallink" href="http://dosmandrivel.blogspot.com/" target="_blank">http://dosmandrivel.blogspot.com/</a></li>\r\n</ul>\r\n</li>\r\n</ul>\r\n<p class="paragraph">And all related Wikipedia pages.</p>\r\n\r\n<h3 id="id670482">Special Thanks To...</h3>\r\n<p class="paragraph">Special Thanks To:</p>\r\n\r\n<ul>\r\n 	<li>Tim Peterson</li>\r\n 	<li>David Bradley</li>\r\n</ul>\r\n<p class="paragraph">for japanese article, see:\r\n"Assembler/なぜx86ではMBRが"0x7C00"にロードされるのか？(完全版)"\r\n<a class="externallink" href="http://www.glamenv-septzen.net/view/614" target="_blank">http://www.glamenv-septzen.net/view/614</a></p>\r\n&nbsp;','Why BIOS loads MBR into 0x7C00 in x86','','publish','open','open','','why-bios-loads-mbr-into-0x7c00-in-x86','','','2016-11-01 16:58:41','2016-11-01 08:58:41','',0,'https://blog-scottwang.rhcloud.com/?p=53',0,'post','',0),
 (55,1,'2016-11-01 17:01:02','2016-11-01 09:01:02','from:\r\n<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title">SSL/TLS协议运行机制的概述</h1>\r\n<div id="share_button" style="float: right; padding-right: 2em; padding-top: 1em;"><a class="bshareDiv" style="display: block; text-decoration: none; padding: 0px; margin: 0px; font-size: 12px; height: 21px; width: 51px;" href="http://www.bshare.cn/share">\r\n</a>\r\n<div class="bsPromo bsPromo1"></div>\r\n<script src="http://static.bshare.cn/b/buttonLite.js#uuid=15e016b4-0028-44f1-a40d-a3c9d9c13c28&amp;style=10&amp;bgcolor=#fff&amp;bp=facebook,twitter,sinaminiblog,weixin,gplus,qqmb,qzone,douban,qqim,fanfou,instapaper,xueqiu&amp;ssc=false" type="text/javascript" charset="utf-8"></script>\r\n<script type="text/javascript" charset="utf-8">// <![CDATA[\r\nbShare.addEntry({ title: document.getElementById("page-title").innerHTML, url:window.location.href });\r\n// ]]></script>\r\n\r\n</div>\r\n<div class="asset-meta">\r\n<p class="vcard author">作者： <a class="fn url" href="http://www.ruanyifeng.com">阮一峰</a></p>\r\n日期： <a href="http://www.ruanyifeng.com/blog/2014/02/"><abbr class="published" title="2014-02-05T19:24:46+08:00">2014年2月 5日</abbr></a>\r\n\r\n</div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n互联网的通信安全，建立在SSL/TLS协议之上。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅<a href="http://tools.ietf.org/html/rfc5246" target="_blank">RFC文档</a>。\r\n\r\n<img title="" src="http://image.beekka.com/blog/201402/bg2014020501.jpg" alt="" />\r\n\r\n<strong>一、作用</strong>\r\n\r\n不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。\r\n<blockquote>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。\r\n\r\n（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。\r\n\r\n（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</blockquote>\r\nSSL/TLS协议是为了解决这三大风险而设计的，希望达到：\r\n<blockquote>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。\r\n\r\n（2） 具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。\r\n\r\n（3） 配备<strong>身份证书</strong>，防止身份被冒充。</blockquote>\r\n互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。\r\n\r\n<strong>二、历史</strong>\r\n\r\n互联网加密通信协议的历史，几乎与互联网一样长。\r\n<blockquote>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。\r\n\r\n1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。\r\n\r\n1996年，SSL 3.0版问世，得到大规模应用。\r\n\r\n1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a href="http://en.wikipedia.org/wiki/Secure_Sockets_Layer" target="_blank">TLS</a> 1.0版。\r\n\r\n2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的<a href="http://tools.ietf.org/html/rfc6176" target="_blank">修订版</a>。</blockquote>\r\n目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。\r\n\r\nTLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。\r\n\r\n<strong>三、基本的运行过程</strong>\r\n\r\nSSL/TLS协议的基本思路是采用<a href="http://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\r\n\r\n但是，这里有两个问题。\r\n\r\n<strong>（1）如何保证公钥不被篡改？</strong>\r\n<blockquote>解决方法：将公钥放在<a href="http://en.wikipedia.org/wiki/Digital_certificate" target="_blank">数字证书</a>中。只要证书是可信的，公钥就是可信的。</blockquote>\r\n<strong>（2）公钥加密计算量太大，如何减少耗用的时间？</strong>\r\n<blockquote>解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。</blockquote>\r\n因此，SSL/TLS协议的基本过程是这样的：\r\n<blockquote>（1） 客户端向服务器端索要并验证公钥。\r\n\r\n（2） 双方协商生成"对话密钥"。\r\n\r\n（3） 双方采用"对话密钥"进行加密通信。</blockquote>\r\n上面过程的前两步，又称为"握手阶段"（handshake）。\r\n\r\n<strong>四、握手阶段的详细过程</strong>\r\n\r\n<img title="" src="http://image.beekka.com/blog/201402/bg2014020502.png" alt="" />\r\n\r\n"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。\r\n\r\n<strong>4.1 客户端发出请求（ClientHello）</strong>\r\n\r\n首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。\r\n\r\n在这一步，客户端主要向服务器提供以下信息。\r\n<blockquote>（1） 支持的协议版本，比如TLS 1.0版。\r\n\r\n（2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。\r\n\r\n（3） 支持的加密方法，比如RSA公钥加密。\r\n\r\n（4） 支持的压缩方法。</blockquote>\r\n这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。\r\n\r\n对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个<a href="http://tools.ietf.org/html/rfc4366" target="_blank">Server Name Indication扩展</a>，允许客户端向服务器提供它所请求的域名。\r\n\r\n<strong>4.2 服务器回应（SeverHello）</strong>\r\n\r\n服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。\r\n<blockquote>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。\r\n\r\n（2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。\r\n\r\n（3） 确认使用的加密方法，比如RSA公钥加密。\r\n\r\n（4） 服务器证书。</blockquote>\r\n除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。\r\n\r\n<strong>4.3 客户端回应</strong>\r\n\r\n客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。\r\n\r\n如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。\r\n<blockquote>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。\r\n\r\n（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\r\n\r\n（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</blockquote>\r\n上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。\r\n\r\n至于为什么一定要用三个随机数，来生成"会话密钥"，<a href="http://blog.csdn.net/dog250/article/details/5717162" target="_blank">dog250</a>解释得很好：\r\n<blockquote>"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。\r\n\r\n对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。\r\n\r\npre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"</blockquote>\r\n此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。\r\n\r\n<strong>4.4 服务器的最后回应</strong>\r\n\r\n服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。\r\n<blockquote>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\r\n\r\n（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</blockquote>\r\n至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。\r\n\r\n<img title="" src="http://image.beekka.com/blog/201402/bg2014020503.gif" alt="" />\r\n\r\n<strong>五、参考链接</strong>\r\n<ul>\r\n 	<li>MicroSoft TechNet, <a href="http://technet.microsoft.com/en-us/library/cc785811(v=ws.10).aspx" target="_blank">SSL/TLS in Detail</a></li>\r\n 	<li>Jeff Moser, <a href="http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html" target="_blank">The First Few Milliseconds of an HTTPS Connection</a></li>\r\n 	<li>Wikipedia, <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank">Transport Layer Security</a></li>\r\n 	<li>StackExchange, <a href="http://security.stackexchange.com/questions/20803/how-does-ssl-work" target="_blank">How does SSL work?</a></li>\r\n</ul>\r\n（完）\r\n\r\n</div>\r\n</article>','SSL/TLS协议运行机制的概述','','publish','open','open','','ssl-tls','','','2016-11-01 17:03:29','2016-11-01 09:03:29','',0,'https://blog-scottwang.rhcloud.com/?p=55',0,'post','',0),
 (59,1,'2016-11-01 17:07:17','2016-11-01 09:07:17','from:\r\n<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a>\r\n<div id="entry-1813" class="entry-asset asset hentry"><article class="hentry">\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n本周，<a href="https://www.cloudflare.com/" target="_blank">CloudFlare</a>宣布，开始提供Keyless服务，即你把网站放到它们的CDN上，不用提供自己的私钥，也能使用SSL加密链接。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014092001.png" alt="CloudFlare" />\r\n\r\n我看了CloudFlare的说明（<a href="https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/" target="_blank">这里</a>和<a href="http://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank">这里</a>），突然意识到这是绝好的例子，可以用来说明SSL/TLS协议的运行机制。它配有插图，很容易看懂。\r\n\r\n下面，我就用这些图片作为例子，配合我半年前写的<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank">《SSL/TLS协议运行机制的概述》</a>，来解释SSL协议。\r\n<h2>一、SSL协议的握手过程</h2>\r\n开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。\r\n\r\n假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程可以用下图说明（点击看大图）。\r\n\r\n<a href="http://image.beekka.com/blog/2014/bg2014092002.png" target="_blank"><img title="" src="http://image.beekka.com/blog/2014/bg2014092013.png" alt="" /></a>\r\n\r\n握手阶段分成五步。\r\n<blockquote>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。\r\n\r\n第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。\r\n\r\n第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster\r\nsecret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。\r\n\r\n第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。\r\n\r\n第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。</blockquote>\r\n上面的五步，画成一张图，就是下面这样。\r\n\r\n<a href="http://image.beekka.com/blog/2014/bg2014092003.png" target="_blank"><img title="" src="http://image.beekka.com/blog/2014/bg2014092004.png" alt="" /></a>\r\n<h2>二、私钥的作用</h2>\r\n握手阶段有三点需要注意。\r\n<blockquote>（1）生成对话密钥一共需要三个随机数。\r\n\r\n（2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。\r\n\r\n（3）服务器公钥放在服务器的数字证书之中。</blockquote>\r\n从上面第二点可知，整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。这就是CloudFlare能够提供Keyless服务的根本原因。\r\n\r\n某些客户（比如银行）想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。\r\n\r\n<a href="http://image.beekka.com/blog/2014/bg2014092005.png" target="_blank"><img title="" src="http://image.beekka.com/blog/2014/bg2014092006.png" alt="" /></a>\r\n\r\n上图中，银行的服务器只参与第四步，后面的对话都不再会用到私钥了。\r\n<h2>三、DH算法的握手阶段</h2>\r\n整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。\r\n\r\n虽然理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank">RSA算法</a>，改为 <a href="http://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2%EF%BC%8D%E8%B5%AB%E5%B0%94%E6%9B%BC%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2" target="_blank">Diffie-Hellman算法</a>（简称DH算法）。\r\n\r\n采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。\r\n\r\n<a href="http://image.beekka.com/blog/2014/bg2014092007.png" target="_blank"><img title="" src="http://image.beekka.com/blog/2014/bg2014092008.png" alt="" /></a>\r\n\r\n上图中，第三步和第四步由传递Premaster secret变成了传递DH算法所需的参数，然后双方各自算出Premaster secret。这样就提高了安全性。\r\n<h2>四、session的恢复</h2>\r\n握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。\r\n\r\n这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。\r\n\r\nsession ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。\r\n\r\n<a href="http://image.beekka.com/blog/2014/bg2014092009.png" target="_blank"><img title="" src="http://image.beekka.com/blog/2014/bg2014092010.png" alt="" /></a>\r\n\r\n上图中，客户端给出session ID，服务器确认该编号存在，双方就不再进行握手阶段剩余的步骤，而直接用已有的对话密钥进行加密通信。\r\n\r\nsession ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。\r\n\r\n<a href="http://image.beekka.com/blog/2014/bg2014092011.png" target="_blank"><img title="" src="http://image.beekka.com/blog/2014/bg2014092012.png" alt="" /></a>\r\n\r\n上图中，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。\r\n\r\n（完）\r\n\r\n</div>\r\n</article></div>','图解SSL/TLS协议','','publish','open','open','','illustration-ssl','','','2016-11-01 17:07:17','2016-11-01 09:07:17','',0,'https://blog-scottwang.rhcloud.com/?p=59',0,'post','',0),
 (61,1,'2016-11-01 17:10:14','2016-11-01 09:10:14','from:\r\n<a href="http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html" target="_blank&quot;">http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html</a>\r\n<div id="entry-1522" class="entry-asset asset hentry"><article class="hentry">\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n开发网页的时候，往往需要观察HTTP通信。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n我使用的工具主要有两个，在Firefox中是<a href="http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html" target="_blank">Firebug</a>，在IE中是<a href="http://www.fiddler2.com/fiddler2/" target="_blank">Fiddler</a>。但是，一直听别人说，付费软件<a href="http://www.httpwatch.com/" target="_blank">HttpWatch</a>是这方面最好的工具。\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021312.png" />\r\n\r\n前几天，HttpWatch的<a href="http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/" target="_blank">官方网志</a>刊登了一篇好文章，澄清了一些HTTPS协议容易产生误解的地方。学习之后，我增长了不少网页加密通信的知识。\r\n\r\n我觉得这篇文章很实用，值得留作参考，就翻译了出来。\r\n\r\n==============================================\r\n\r\n<strong>HTTPS的七个误解</strong>\r\n\r\n原文网址：<a href="http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/" target="_blank">http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/</a>\r\n\r\n译者：阮一峰\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021311.jpg" />\r\n<strong>误解七：HTTPS无法缓存</strong>\r\n\r\n许多人以为，出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。\r\n\r\n微软的IE项目经理<a href="http://blogs.msdn.com/b/ieinternals/archive/2010/04/21/internet-explorer-may-bypass-cache-for-cross-domain-https-content.aspx" target="_blank">Eric Lawrence</a>写道：\r\n<blockquote>"说来也许令人震惊，只要HTTP头允许这样做，所有版本的IE都缓存HTTPS内容。比如，如果头命令是Cache-Control: max-age=600，那么这个网页就将被IE缓存10分钟。IE的缓存策略，与是否使用HTTPS协议无关。（其他浏览器在这方面的行为不一致，取决于你使用的版本，所以这里不加以讨论。）"</blockquote>\r\nFirefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。下面的图片显示，Firefox的硬盘缓存中有HTTPS内容，头命令正是Cache-Control:Public。\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021301.png" />\r\n\r\n<strong>误解六：SSL证书很贵</strong>\r\n\r\n如果你在网上<a href="http://www.google.com/search?q=cheap+SSL+certificates&amp;ie=utf-8&amp;oe=utf-8" target="_blank">搜一下</a>，就会发现很多便宜的SSL证书，大概10美元一年，这和一个.com域名的年费差不多。而且事实上，还能找到<a href="http://www.startssl.com/" target="_blank">免费</a>的SSL证书。\r\n\r\n在效力上，便宜的证书当然会比大机构颁发的证书差一点，但是几乎所有的主流浏览器都接受这些证书。\r\n\r\n<strong>误解五：HTTPS站点必须有独享的IP地址</strong>\r\n\r\n由于IPv4将要分配完毕，所以很多人关心这个问题。每个IP地址只能安装一张SSL证书，这是毫无疑问的。但是，如果你使用子域名通配符SSL证书（wildcard SSL certificate，价格大约是每年125美元），就能在一个IP地址上部署多个HTTPS子域名。比如，https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021302.png" />\r\n\r\n另外，UCC（统一通信证书，Unified Communications Certificate）支持一张证书同时匹配多个站点，可以是完全不同的域名。<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank">SNI</a>（服务器名称指示，Server Name Indication）允许一个IP地址上多个域名安装多张证书。服务器端，Apache和Nginx支持该技术，IIS不支持；客户端，IE 7+、Firefox 2.0+、Chrome 6+、Safari 2.1+和Opera 8.0+支持。\r\n\r\n<strong>误解四：转移服务器时要购买新证书</strong>\r\n\r\n部署SSL证书，需要这样几步：\r\n<blockquote>　　1. 在你的服务器上，生成一个CSR文件（SSL证书请求文件，SSL Certificate Signing Request）。\r\n\r\n2. 使用CSR文件，购买SSL证书。\r\n\r\n3. 安装SSL证书。</blockquote>\r\n这些步骤都经过精心设计，保证传输的安全，防止有人截取或非法获得证书。结果就是，你在第二步得到的证书不能用在另一台服务器上。如果你需要这样做，就必须以其他格式输出证书。\r\n\r\n比如，IIS的做法是生成一个可以转移的.pfx文件，并加以密码保护。\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021303.png" />\r\n\r\n将这个文件传入其他服务器，将可以继续使用原来的SSL证书了。\r\n\r\n<strong>误解三：HTTPS太慢</strong>\r\n\r\n使用HTTPS不会使你的网站变得更快（实际上有可能，请看下文），但是有一些<a href="http://blog.httpwatch.com/2009/01/15/https-performance-tuning/" target="_blank">技巧</a>可以大大减少额外开销。\r\n\r\n首先，只要压缩文本内容，就会降低解码耗用的CPU资源。不过，对于当代CPU来说，这点开销不值一提。\r\n\r\n其次，建立HTTPS连接，要求额外的TCP往返，因此会新增一些发送和接收的字节。但是，从下图可以看到，新增的字节是很少的。\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021304.png" />\r\n\r\n第一次打开网页的时候，HTTPS协议会比HTTP协议慢一点，这是因为读取和验证SSL证书的时间。下面是一张HTTP网页打开时间的瀑布图。\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021305.png" />\r\n\r\n同一张网页使用HTTPS协议之后，打开时间变长了。\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021306.png" />\r\n\r\n建立连接的部分，大约慢了10%。但是，一旦有效的HTTPS连接建立起来，再刷新网页，两种协议几乎没有区别。先是HTTP协议的刷新表现：\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021307.png" />\r\n\r\n然后是HTTPS协议：\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021308.png" />\r\n\r\n某些用户可能发现，HTTPS比HTTP更快一点。这会发生在一些大公司的内部局域网，因为通常情况下，公司的网关会截取并分析所有的网络通信。但是，当它遇到HTTPS连接时，它就只能直接放行，因为HTTPS无法被解读。正是因为少了这个解读的过程，所以HTTPS变得比较快。\r\n\r\n<strong>误解二：有了HTTPS，Cookie和查询字符串就安全了</strong>\r\n\r\n虽然无法直接从HTTPS数据中读取Cookie和查询字符串，但是你仍然需要使它们的值变得难以预测。\r\n\r\n比如，曾经有一家英国银行，直接使用顺序排列的数值表示session id:\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021309.png" />\r\n\r\n黑客可以先注册一个账户，找到这个cookie，看到这个值的表示方法。然后，改动cookie，从而劫持其他人的session id。至于查询字符串，也可以通过<a href="http://blog.httpwatch.com/2009/02/20/how-secure-are-query-strings-over-https/" target="_blank">类似方式</a>泄漏。\r\n\r\n<strong>误解一：只有注册登录页，才需要HTTPS</strong>\r\n\r\n这种想法很普遍。人们觉得，HTTPS可以保护用户的密码，此外就不需要了。Firefox浏览器新插件<a href="http://codebutler.com/firesheep" target="_blank">Firesheep</a>，证明了这种想法是错的。我们可以看到，在Twitter和Facebook上，劫持其他人的session是非常容易的。\r\n\r\n咖啡馆的免费WiFi，就是一个很理想的劫持环境，因为两个原因：\r\n<blockquote>　　1. 这种WiFi通常不会加密，所以很容易监控所有流量。\r\n\r\n2. WiFi通常使用NAT进行外网和内网的地址转换，所有内网客户端都共享一个外网地址。这意味着，被劫持的session，看上去很像来自原来的登录者。</blockquote>\r\n以Twitter为例，它的登录页使用了HTTPS，但是登录以后，其他页面就变成了HTTP。这时，它的cookie里的session值就暴露了。\r\n\r\n<img src="http://image.beekka.com/blog/201102/bg2011021310.png" />\r\n\r\n也就是说，这些cookie是在HTTPS环境下建立的，但是却在HTTP环境下传输。如果有人劫持到这些cookie，那他就能以你的身份在Twitter上发言了。\r\n\r\n（完）\r\n\r\n<!-- /div -->\r\n\r\n</div>\r\n<script src="/newwindow.js" type="text/javascript"></script>\r\n<div class="asset-footer">\r\n<h3>文档信息</h3>\r\n<ul>\r\n 	<li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）</li>\r\n 	<li>发表日期： <abbr class="published" title="2011-02-13T21:20:25+08:00">2011年2月13日</abbr></li>\r\n 	<li>更多内容： <a href="http://www.ruanyifeng.com/blog/archives.html" target="_blank"> 档案</a> »\r\n<a href="http://www.ruanyifeng.com/blog/developer/"> 开发者手册</a></li>\r\n 	<li>购买文集：<a href="http://www.ruanyifeng.com/blog/2014/12/my-blog-book.html" target="_blank"><img style="border: 0;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanZZ3VFTXFofPvXd6oc0wAlKG3rvAANJ7k15FYZgZYCgDDjM0sSGiAhFFRJoiSFDEgNFQJFZEsRAUVLAHJAgoMRhFVCxvRtaLrqy89/Ly++Osb+2z97n77L3PWhcAkqcvl5cGSwGQyhPwgzyc6RGRUXTsAIABHmCAKQBMVka6X7B7CBDJy82FniFyAl8EAfB6WLwCcNPQM4BOB/+fpFnpfIHomAARm7M5GSwRF4g4JUuQLrbPipgalyxmGCVmvihBEcuJOWGRDT77LLKjmNmpPLaIxTmns1PZYu4V8bZMIUfEiK+ICzO5nCwR3xKxRoowlSviN+LYVA4zAwAUSWwXcFiJIjYRMYkfEuQi4uUA4EgJX3HcVyzgZAvEl3JJS8/hcxMSBXQdli7d1NqaQffkZKVwBALDACYrmcln013SUtOZvBwAFu/8WTLi2tJFRbY0tba0NDQzMv2qUP91829K3NtFehn4uWcQrf+L7a/80hoAYMyJarPziy2uCoDOLQDI3fti0zgAgKSobx3Xv7oPTTwviQJBuo2xcVZWlhGXwzISF/QP/U+Hv6GvvmckPu6P8tBdOfFMYYqALq4bKy0lTcinZ6QzWRy64Z+H+B8H/nUeBkGceA6fwxNFhImmjMtLELWbx+YKuGk8Opf3n5r4D8P+pMW5FonS+BFQY4yA1HUqQH7tBygKESDR+8Vd/6NvvvgwIH554SqTi3P/7zf9Z8Gl4iWDm/A5ziUohM4S8jMX98TPEqABAUgCKpAHykAd6ABDYAasgC1wBG7AG/iDEBAJVgMWSASpgA+yQB7YBApBMdgJ9oBqUAcaQTNoBcdBJzgFzoNL4Bq4AW6D+2AUTIBnYBa8BgsQBGEhMkSB5CEVSBPSh8wgBmQPuUG+UBAUCcVCCRAPEkJ50GaoGCqDqqF6qBn6HjoJnYeuQIPQXWgMmoZ+h97BCEyCqbASrAUbwwzYCfaBQ+BVcAK8Bs6FC+AdcCXcAB+FO+Dz8DX4NjwKP4PnEIAQERqiihgiDMQF8UeikHiEj6xHipAKpAFpRbqRPuQmMorMIG9RGBQFRUcZomxRnqhQFAu1BrUeVYKqRh1GdaB6UTdRY6hZ1Ec0Ga2I1kfboL3QEegEdBa6EF2BbkK3oy+ib6Mn0K8xGAwNo42xwnhiIjFJmLWYEsw+TBvmHGYQM46Zw2Kx8lh9rB3WH8vECrCF2CrsUexZ7BB2AvsGR8Sp4Mxw7rgoHA+Xj6vAHcGdwQ3hJnELeCm8Jt4G749n43PwpfhGfDf+On4Cv0CQJmgT7AghhCTCJkIloZVwkfCA8JJIJKoRrYmBRC5xI7GSeIx4mThGfEuSIemRXEjRJCFpB+kQ6RzpLuklmUzWIjuSo8gC8g5yM/kC+RH5jQRFwkjCS4ItsUGiRqJDYkjiuSReUlPSSXK1ZK5kheQJyeuSM1J4KS0pFymm1HqpGqmTUiNSc9IUaVNpf+lU6RLpI9JXpKdksDJaMm4ybJkCmYMyF2TGKQhFneJCYVE2UxopFykTVAxVm+pFTaIWU7+jDlBnZWVkl8mGyWbL1sielh2lITQtmhcthVZKO04bpr1borTEaQlnyfYlrUuGlszLLZVzlOPIFcm1yd2WeydPl3eTT5bfJd8p/1ABpaCnEKiQpbBf4aLCzFLqUtulrKVFS48vvacIK+opBimuVTyo2K84p6Ss5KGUrlSldEFpRpmm7KicpFyufEZ5WoWiYq/CVSlXOavylC5Ld6Kn0CvpvfRZVUVVT1Whar3qgOqCmrZaqFq+WpvaQ3WCOkM9Xr1cvUd9VkNFw08jT6NF454mXpOhmai5V7NPc15LWytca6tWp9aUtpy2l3audov2Ax2yjoPOGp0GnVu6GF2GbrLuPt0berCehV6iXo3edX1Y31Kfq79Pf9AAbWBtwDNoMBgxJBk6GWYathiOGdGMfI3yjTqNnhtrGEcZ7zLuM/5oYmGSYtJoct9UxtTbNN+02/R3Mz0zllmN2S1zsrm7+QbzLvMXy/SXcZbtX3bHgmLhZ7HVosfig6WVJd+y1XLaSsMq1qrWaoRBZQQwShiXrdHWztYbrE9Zv7WxtBHYHLf5zdbQNtn2iO3Ucu3lnOWNy8ft1OyYdvV2o/Z0+1j7A/ajDqoOTIcGh8eO6o5sxybHSSddpySno07PnU2c+c7tzvMuNi7rXM65Iq4erkWuA24ybqFu1W6P3NXcE9xb3Gc9LDzWepzzRHv6eO7yHPFS8mJ5NXvNelt5r/Pu9SH5BPtU+zz21fPl+3b7wX7efrv9HqzQXMFb0ekP/L38d/s/DNAOWBPwYyAmMCCwJvBJkGlQXlBfMCU4JvhI8OsQ55DSkPuhOqHC0J4wybDosOaw+XDX8LLw0QjjiHUR1yIVIrmRXVHYqLCopqi5lW4r96yciLaILoweXqW9KnvVldUKq1NWn46RjGHGnIhFx4bHHol9z/RnNjDn4rziauNmWS6svaxnbEd2OXuaY8cp40zG28WXxU8l2CXsTphOdEisSJzhunCruS+SPJPqkuaT/ZMPJX9KCU9pS8Wlxqae5Mnwknm9acpp2WmD6frphemja2zW7Fkzy/fhN2VAGasyugRU0c9Uv1BHuEU4lmmfWZP5Jiss60S2dDYvuz9HL2d7zmSue+63a1FrWWt78lTzNuWNrXNaV78eWh+3vmeD+oaCDRMbPTYe3kTYlLzpp3yT/LL8V5vDN3cXKBVsLBjf4rGlpVCikF84stV2a9021DbutoHt5turtn8sYhddLTYprih+X8IqufqN6TeV33zaEb9joNSydP9OzE7ezuFdDrsOl0mX5ZaN7/bb3VFOLy8qf7UnZs+VimUVdXsJe4V7Ryt9K7uqNKp2Vr2vTqy+XeNc01arWLu9dn4fe9/Qfsf9rXVKdcV17w5wD9yp96jvaNBqqDiIOZh58EljWGPft4xvm5sUmoqbPhziHRo9HHS4t9mqufmI4pHSFrhF2DJ9NProje9cv+tqNWytb6O1FR8Dx4THnn4f+/3wcZ/jPScYJ1p/0Pyhtp3SXtQBdeR0zHYmdo52RXYNnvQ+2dNt293+o9GPh06pnqo5LXu69AzhTMGZT2dzz86dSz83cz7h/HhPTM/9CxEXbvUG9g5c9Ll4+ZL7pQt9Tn1nL9tdPnXF5srJq4yrndcsr3X0W/S3/2TxU/uA5UDHdavrXTesb3QPLh88M+QwdP6m681Lt7xuXbu94vbgcOjwnZHokdE77DtTd1PuvriXeW/h/sYH6AdFD6UeVjxSfNTws+7PbaOWo6fHXMf6Hwc/vj/OGn/2S8Yv7ycKnpCfVEyqTDZPmU2dmnafvvF05dOJZ+nPFmYKf5X+tfa5zvMffnP8rX82YnbiBf/Fp99LXsq/PPRq2aueuYC5R69TXy/MF72Rf3P4LeNt37vwd5MLWe+x7ys/6H7o/ujz8cGn1E+f/gUDmPP8kcBa2wAAADxQTFRFAAAAAAAAAgICBAQEBQUFBgYGBwcHCAgICQkJCgoKDQ0NExMTOTk5c3NzdXV1eHh4eXl5enp6e3t7fHx8rr9WJAAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gYMADMaKH8BrQAAAGVJREFUGNONkI0KwCAIhE+32n/b2vu/6yqYCRnshMCPS/SA/6Ikk5vQWXQ7gpL6H1KV54OMbCiuCk0n9rOdma3i1JteuIGIJ1bI60Se2dG4qFWDddQsSeiZpRkILfQ6Hcmvk2NPLzksA4TnEeNNAAAAAElFTkSuQmCC" /> 《如何变得有思想》</a></li>\r\n 	<li>社交媒体：<a href="https://twitter.com/ruanyf" target="_blank"><img style="border: 0;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAk1JREFUeNqsVc9rE0EU/mZ3dhPNJl2bVIk/Km09aFBE8GLvnrwJXvwLxIsgCP4Fnit6E8Gb0IMHwUsL9SSNgiAoooJIpE1Joo1h82uT7IxvxmRN3Q32kAdvdrI773vfe+/bDTu9WioDcDAda3Ja8piepQ1avCkCeny0Y+R9KenKwOmHHLvPaKn7AtVOoO8dOWDCMpg+41gMQv5FNEJACgoE8MsPNLDBhgfoutMOsJDmWLmU037C4TApciljwQ/kHoohQxV06+wMXNvE7WINuaSpvdYVKLgWnl3O4zAxU3Z1IYVGT+B5qYWV9z2kbQaT/cOwTsxOUUYF+mB5Dkmi8HG3h2q9hxsFNwRTdvQgxxnXRrMvIdkEhllis/qtiWuLDm4WZnBlPoWnXz28LHdw0uGR7m9Wu3j0qYGEubfn4UlBfXO4gTZltRNMg9w9f0i7kNFxllsBlS0x75gYfxyWTBUjT2W5CSMSPBrQuG21+hiMDS8CeCzF8eSLp13uQ3Ab1IqMFZN8tFHPmgOBF99bYP8Be1Xp6t7OJszJgKpPSiZvaj7uf2hguz2IBQuozDvFH6RDBjuK9wdQDvt0nMpW+8efGyh5UcAeZb2+UcHbnz5Jx4wdlp4yJYU3kLiQtfBwOYeLc8nIwfXtNu69q2Oz4mMxbemYOOOjKarhvq51KUjg3GwiFPIuvcNF6pnSnWK0lOEabNLgQh1aJFAhlGB9rG110B2+oyRNPc0sZbRNFltmLKDKqj4Qrm1ojzOxDz2pyPQ0P7CK4c40/wJ+CzAAGYrXsvfFXR4AAAAASUVORK5CYII=" /> twitter</a>，<a href="http://weibo.com/ruanyf" target="_blank"><img style="border: 0;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABPZJREFUeNqMyXtM1WUcx/FnNTdreAVCEEThyEFUrM2kwkpS05qVl8rugVpRUelaJdZaWWktdZKHssImgV04osgBCbwAa2Whm6GWoXHxcD1wHiI4t9/z/H68+wO3av1R3+217/b+CFStsHq/W2V1HW+wOmq8VkeN/E+dR/7SUSOtrmOnLc93jxA6LsTw71XLrUsHsNwHsdxl/09HGVb7QawOF1bn4ZF26QDDsmqNsH7be9psKcJs+fy/tRZjXvwM//678BVdT6BsMarhxZHeug+reW+TMC84+s0LDv4tH7PZgdXqwGrLx7yYP9KaHISOvUCwYh3+4iUMOiIJVmSMbBfy+4X581Zp/ryVfzi/FfPXd1AntxNwvkvg6zfQZ7Zg/rIV8/x7qB9fJlT/JPrcm4SOPctg3ihCR5dhNu2QQjfmSt2Yi27MRf+Uiz67Ef1TLv7Ct5CPZtMzJ4N2243Ij7Kwmjdhnt+EUZeFr/BmhvYkoBqewl8yD9/eCejGTVLoUzlSn8pBn8xBn85B/fAcf7z6PJ7rl9KdNBdP6nwuJc2jL+9+jJrXGNr1On9seZHgkQ0ESq8l4EzBOLKMod1XoE6slUKfXCd1wxp0Qxb6RBYDLzxGz8xb8aSm05u2kL4bF9N902I89yzHe986PEseoGP2YjqfvpNQeTr+4rmEKucz6LgS9f1jUuiy+VIfvxvz1GoGN99Hz8wFeGan0zl3Ae4lK3A/vJb2x7PpWPEI3bevoHfJKtypt9H1UgbDZx5E//goofJF+AtmoasWSaG2jZE6P5zg9hQ8Nyyie1Y6rQ+vpafMhdHXx7BpgjWMr7sbT5kL9/IHcUck0X3LtfgLVqAP3YAumoHeHYvaPkYKlRcudf54Bh5KpjP5Fi69tplgIMCQabK/rIxtO3bgqqxkmJHzdXbRknYbrWIcrWEJ9D8RjXaMRe2ciNo5QQr1QYRUjnC8C1Nxr1pD0O/HFwyQmZmJ3W4nLS0Nm83G+vXrsSwLgP6vS2kWo/lNjKN57gTMTyJRH0Si8iZKoXZdI5Ujkt55SXRtfBuAffv2sXLlSpxOJ9nZ2SQkJBAWFobX6wVgoPooLWI0v4hxuFeFY30ahdoVhcqLkEJ9GCV1QRTehZNxZ9wPQNGXX5KZmUlbWxspKSkIIUhPT0dZFibQvSaHJjGKxujxBHZGoT+ehPpwEsoRIYUqmCR1YTTBd2NoGxtOz4Y3CPoDrNuwnuhpU7lq/HgW3LGU5l4P2h+g55XNnBOjORM/jsH3ozGLYlAFMag90ahPI6VQxZOlKo5BOyfjey+GliljaL0uA7l9D2f37uess5KBoyfwbvmIJnsajVePouXeCIKFsZglsajiyX8pvEYKoySm33DGYTjj0OVxhEri6N84kfalY2i/NRb3AhvNN0+i9Y4wPC+H4yuMxTocjzoYj7F/ymVxI/+ryH5huKaeMVzxGK54QuXT8B+y4atIZqB8Nt6SVDzFqXi+mIO39Dp+PziHwdIZDJVOJ3gogZArHsM1BcMVj1E+BcMVe1GY38auNqqnYdQkEKpOJPBNEv7DdnyVdnwVdoYqki+bge9wCv6qFAJVyQS/mU6oJhHjSCJG9VSM6kRUfXi2GK6fJYy6+CyjNrHRqLP1GbWJ0qizSfV39Tap6qdLVW+Xqt4ujfokadRdVpvgNWpt54y6qc8MV44Sfw4An+t+Gj1AKyYAAAAASUVORK5CYII=" /> weibo</a></li>\r\n 	<li>Feed订阅： <a href="/feed.html" target="_blank"><img style="border: 0;" src="data:image/gif;base64,R0lGODlhFAAUANU2APV1GfmrePZ8IeR5VPq2ieNkLf7p3NpFJveCJ/NoFfibVPR1IexiJfvdzuZrNfXGuOhUEueTevaFOfzIpNxDGeZZJNU6IOubifiVTfOnid1aLuZpLOFSJf/28vJtIvGcefaLSd5kNu9iFv/z6//48//t4uFfLfNkCeJNGuGNc/rCof/+/PVxEeldI/V5KeKMbu9nIvB2OvzQtNxMKfOPXP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADYALAAAAAAUABQAAAb/QJstEjKZCsjCZsl0pIS2QWXaYsA8noVWIEAgFoNhhWNyMESi7Jbr/aZCFdRnZJAFJCwAt+vlOkwtEBk1hDUkExJ6bQJaGyYMLTQTDSOFHQF8jAseSFYiJwkuAQ2FE1xaHjBIMDAgARguJwABJIQTLJswDEgeIgSEJQQILAqVNQEiui1HHgkBhTUGCiwYtR0xLS0VJhtaEgoEBoQkGCfPNSoQY9xaCwAsCBPALgmkJA4cZN0CAAgY/PJqEIDwgVAECjM0bOAnwcAKGQJclKhRgoGDDjUeUDigkN8vQiBOfByAglSDAxw3IBCgYEU0FyJoEPpA4UGNDjMsaHDQR8EdPVYOMmQYQGHAhQgHLIRIsWAlgASsGMRBMWMGBQtYZ7yIsoBRKkhjOMxAiXJGGCEpHGxIYsSIhrcaQmy1EQQAOw==" /></a></li>\r\n</ul>\r\n</div>\r\n</article></div>','HTTPS的七个误解（译文）','','publish','open','open','','myths-about-https','','','2016-11-01 17:10:14','2016-11-01 09:10:14','',0,'https://blog-scottwang.rhcloud.com/?p=61',0,'post','',0),
 (63,1,'2016-11-01 17:14:36','2016-11-01 09:14:36','from:\r\n<a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank">http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html</a>\r\n<div id="alpha">\r\n<div id="alpha-inner">\r\n<div id="entry-1814" class="entry-asset asset hentry"><article class="hentry">\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n据说，Netscape公司当年设计<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank">SSL协议</a>的时候，有人提过，将互联网所有链接都变成HTTPs开头的加密链接。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n这个建议没有得到采纳，原因之一是HTTPs链接比不加密的HTTP链接慢很多。（另一个原因好像是，HTTPs链接默认不能缓存。）\r\n\r\n自从我知道这个掌故以后，脑袋中就有一个观念：HTTPs链接很慢。但是，它到底有多慢，我并没有一个精确的概念。直到今天我从一篇<a href="http://www.semicomplete.com/blog/geekery/ssl-latency.html" target="_blank">文章</a>中，学到了测量HTTPS链接耗时的方法。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014092401.jpg" alt="slow connection" />\r\n\r\n首先我解释一下，为什么HTTPs链接比较慢。\r\n\r\nHTTPs链接和HTTP链接都建立在TCP协议之上。HTTP链接比较单纯，使用三个握手数据包建立连接之后，就可以发送内容数据了。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014092402.png" alt="tcp handshake" />\r\n\r\n上图中，客户端首先发送SYN数据包，然后服务器发送SYN+ACK数据包，最后客户端发送ACK数据包，接下来就可以发送内容了。这三个数据包的发送过程，叫做TCP握手。\r\n\r\n再来看HTTPs链接，它也采用TCP协议发送数据，所以它也需要上面的这三步握手过程。而且，在这三步结束以后，它还有一个<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank">SSL握手</a>。\r\n\r\n总结一下，就是下面这两个式子。\r\n<blockquote>HTTP耗时 = TCP握手\r\n\r\nHTTPs耗时 = TCP握手 + SSL握手</blockquote>\r\n所以，HTTPs肯定比HTTP耗时，这就叫SSL延迟。\r\n\r\n命令行工具<a href="http://www.ruanyifeng.com/blog/2011/09/curl.html" target="_blank">curl</a>有一个w参数，可以用来测量TCP握手和SSL握手的具体耗时，以访问支付宝为例。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n\r\n$ curl <span class="token operator">-</span>w <span class="token string">"TCP handshake: %{time_connect}, SSL handshake: %{time_appconnect}\\n"</span> <span class="token operator">-</span>so <span class="token operator">/</span>dev<span class="token operator">/</span>null https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>alipay<span class="token punctuation">.</span>com\r\n\r\nTCP handshake<span class="token punctuation">:</span> <span class="token number">0.022</span><span class="token punctuation">,</span> SSL handshake<span class="token punctuation">:</span> <span class="token number">0.064</span>\r\n\r\n</code></pre>\r\n</blockquote>\r\n上面命令中的w参数表示指定输出格式，time_connect变量表示TCP握手的耗时，time_appconnect变量表示SSL握手的耗时（更多变量请查看<a href="http://curl.haxx.se/docs/manpage.html" target="_blank">文档</a>和<a href="https://josephscott.org/archives/2011/10/timing-details-with-curl/" target="_blank">实例</a>），s参数和o参数用来关闭标准输出。\r\n\r\n从运行结果可以看到，SSL握手的耗时（64毫秒）大概是TCP握手（22毫秒）的三倍。也就是说，在建立连接的阶段，HTTPs链接比HTTP链接要长3倍的时间，具体数字取决于CPU的快慢和网络状况。\r\n\r\n所以，如果是对安全性要求不高的场合，为了提高网页性能，建议不要采用保密强度很高的数字证书。一般场合下，1024位的证书已经足够了，2048位和4096位的证书将进一步延长SSL握手的耗时。\r\n\r\n（完）\r\n\r\n<!-- /div -->\r\n\r\n</div>\r\n<script src="/newwindow.js" type="text/javascript"></script>\r\n<div class="asset-footer"></div>\r\n</article></div>\r\n<div id="comments" class="comments">\r\n<div id="comments-open" class="comments-open">\r\n<div class="comments-open-content"><form id="comments-form" action="http://www.ruanyifeng.com/cgi-bin/mtos/mt-comments.cgi" method="post" name="comments_form">\r\n<div id="comments-open-footer"></div>\r\n</form></div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>','SSL延迟有多大?','','publish','open','open','','ssl-latency','','','2016-11-01 17:14:36','2016-11-01 09:14:36','',0,'https://blog-scottwang.rhcloud.com/?p=63',0,'post','',0),
 (65,1,'2016-11-01 17:17:19','2016-11-01 09:17:19','from:\r\n<a href="http://www.semicomplete.com/blog/geekery/ssl-latency.html" target="_blank">http://www.semicomplete.com/blog/geekery/ssl-latency.html</a>\r\n<div class="story-body">At work today, I started investigating the latency differences for similar\r\nrequests between HTTP and HTTPS. Historically, I was running with the assumption\r\nthat higher latency on HTTPS (SSL) traffic was to be expected since SSL handshakes\r\nare more CPU intensive. I didn\'t really think about the network consequences of\r\nSSL until today.It\'s all in the handshake.\r\n\r\n<a href="http://www.google.com/search?q=tcp+handshake">TCP handshake</a> is a\r\n3-packet event. The client sends 2 packets, the server sends 1. Best case,\r\nyou\'re looking at one round-trip for establishing your connection. We can show\r\nthis empirically by comparing ping and tcp connect times:\r\n<pre>% fping -q -c 5 www.csh.rit.edu\r\nwww.csh.rit.edu : xmt/rcv/%loss = 5/5/0%, min/avg/max = 112/115/123\r\n</pre>\r\nAverage is 115ms for ping round-trip. How about TCP? Let\'s ask curl how long tcp connect takes:\r\n<pre>% seq 5 | xargs -I@ -n1 curl -so /dev/null -w "%{time_connect}\\n" http://www.csh.rit.edu\r\n0.117\r\n0.116\r\n0.117\r\n0.116\r\n0.116\r\n</pre>\r\nThere\'s your best case. This is because when you (the client) receive the 2nd\r\npacket in the handshake (SYN+ACK), you reply with ACK and consider the\r\nconnection open. Exactly 1 round-trip is required before you can send your http\r\nrequest.\r\n\r\nWhat about when using SSL? Let\'s ask curl again:\r\n<pre>% curl -kso /dev/null -w "tcp:%{time_connect}, ssldone:%{time_appconnect}\\n" https://www.csh.rit.edu\r\ntcp:0.117, ssldone:0.408\r\n\r\n# How about to google?\r\n% curl -kso /dev/null -w "tcp:%{time_connect}, ssldone:%{time_appconnect}\\n" https://www.google.com\r\ntcp:0.021, ssldone:0.068\r\n\r\n</pre>\r\n3.5x jump in latency just for adding SSL to the mix, and this is before we sent\r\nthe http request.\r\n\r\nThe reason for this is easily shown with tcpdump. For this test, I\'ll use\r\ntcpdump to sniff https traffic and then use openssl s_client to simply connect\r\nto the http server over ssl and do nothing else. Start tcpdump first, then run\r\nopenssl s_client.\r\n<pre>terminal1 % sudo tcpdump -ttttt -i any \'port 443 and host www.csh.rit.edu\'\r\n...\r\n\r\nterminal2 % openssl s_client -connect www.csh.rit.edu:443\r\n...\r\n\r\nTcpdump output trimmed for content:\r\n\r\n# Start TCP Handshake\r\n00:00:00.000000 IP snack.home.40855 &gt; csh.rit.edu.https: Flags [S] ...\r\n00:00:00.114298 IP csh.rit.edu.https &gt; snack.home.40855: Flags [S.] ...\r\n00:00:00.114341 IP snack.home.40855 &gt; csh.rit.edu.https: Flags [.] ...\r\n# TCP Handshake complete.\r\n\r\n# Start SSL Handshake.\r\n00:00:00.114769 IP snack.home.40855 &gt; csh.rit.edu.https: Flags [P.] ...\r\n00:00:00.226456 IP csh.rit.edu.https &gt; snack.home.40855: Flags [.] ...\r\n00:00:00.261945 IP csh.rit.edu.https &gt; snack.home.40855: Flags [.] ...\r\n00:00:00.261960 IP csh.rit.edu.https &gt; snack.home.40855: Flags [P.] ...\r\n00:00:00.261985 IP snack.home.40855 &gt; csh.rit.edu.https: Flags [.] ...\r\n00:00:00.261998 IP snack.home.40855 &gt; csh.rit.edu.https: Flags [.] ...\r\n00:00:00.273284 IP snack.home.40855 &gt; csh.rit.edu.https: Flags [P.] ...\r\n00:00:00.398473 IP csh.rit.edu.https &gt; snack.home.40855: Flags [P.] ...\r\n00:00:00.436372 IP snack.home.40855 &gt; csh.rit.edu.https: Flags [.] ...\r\n\r\n# SSL handshake complete, ready to send HTTP request. \r\n# At this point, openssl s_client is sitting waiting for you to type something\r\n# into stdin.\r\n\r\n</pre>\r\nSummarizing the above tcpdump data for this ssl handshake:\r\n<ul>\r\n 	<li>12 packets for SSL, vs 3 for TCP alone</li>\r\n 	<li>TCP handshake took 114ms</li>\r\n 	<li>Total SSL handshake time was 436ms</li>\r\n 	<li>Number of network round-trips was 3.</li>\r\n 	<li>SSL portion took 322ms (network and crypto)</li>\r\n</ul>\r\nThe server tested above has a 2048 bit ssl cert. Running \'openssl speed rsa\' on\r\nthe webserver shows it can do a signature in 22ms:\r\n<pre>                  sign    verify    sign/s verify/s\r\nrsa 2048 bits 0.022382s 0.000542s     44.7   1845.4\r\n</pre>\r\nAnyway. The point is, no matter how fast your SSL accelerators (hardware\r\nloadbalancer, etc), if your SSL end points aren\'t near the user, then your\r\nfirst connect will be slow. As shown above, 22ms for the crypto piece of SSL\r\nhandshake, which means 300ms of the SSL portion above was likely network\r\nlatency and some other overhead.\r\n\r\nOnce SSL is established, though, it switches to a block cipher (3DES, etc)\r\nwhich is much faster and the resource (network, cpu) overhead is pretty tiny by\r\ncomparison.\r\n\r\nSummarizing from above: Using SSL incurs a 3.5x latency overhead for each\r\nhandshake, but afterwards it\'s generally fast like plain TCP. If you accept\r\nthis conclusion, let\'s examine how this can affect website performance.\r\n\r\nGot firebug? Open any website. Seriously. Watch the network activity. How many\r\nHTTP requests are made? Can you tell how many of those that go to the same\r\ndomain use http pipelining (or keepalive)? How many initiate new requests each\r\ntime? You can track this with tcpdump by looking for \'syn\' packets if you want\r\n(<code>tcpdump \'tcp[tcpflags] == tcp-syn\'</code>).\r\n\r\nWhat about the street wisdom for high-performance web servers? HAProxy\'s site\r\nsays:\r\n<blockquote>"If a site needs keep-alive, there is a real problem. Highly loaded sites\r\noften disable keep-alive to support the maximum number of simultaneous\r\nclients. The real downside of not having keep-alive is a slightly increased\r\nlatency to fetch objects. Browsers double the number of concurrent connections\r\non non-keepalive sites to compensate for this."</blockquote>\r\nDisabling keep-alive on SSL connections means every single http request is\r\ngoing to take 3 round-trips before even asking for data. If your server is\r\n100ms away, and you have 10 resources to serve on a single page, that\'s 3\r\nseconds of network latency before you include SSL crypto or resource transfer\r\ntime. With keep alive, you could eat that handshake cost only once instead of\r\n10 times.\r\n\r\nMany browsers will open multiple simultaneous connections to any given\r\nwebserver if it needs to fetch multiple resources. Idea is that parallelism\r\ngets you more tasty http resources in a shorter time. If the browser opens\r\ntwo connections in parallel, you\'ll still incur many sequential SSL handshakes\r\nthat slow your resource fetching down. More SSL handshakes in parallel means\r\nhigher CPU burden, too, and ultimately memory (per open connection) scales more\r\ncheaply than does CPU time - think: above, one active connection cost 22ms of\r\ntime (most of which is spent in CPU) and costs much more than that connection\r\nholds in memory resources and scales better (easier to grow memory than cpu).\r\n\r\nFor some data, Google and Facebook both permit keep-alive:\r\n<pre>% URL=https://s-static.ak.facebook.com/rsrc.php/zPET4/hash/9e65hu86.js\r\n% curl  -w "tcp: %{time_connect} ssl:%{time_appconnect}\\n" -sk -o /dev/null $URL -o /dev/null $URL\r\ntcp: 0.038 ssl:0.088\r\ntcp: 0.000 ssl:0.000\r\n\r\n% URL=https://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js\r\n% curl  -w "tcp: %{time_connect} ssl:%{time_appconnect}\\n" -sk -o /dev/null $URL -o /dev/null $URL\r\ntcp: 0.054 ssl:0.132\r\ntcp: 0.000 ssl:0.000\r\n</pre>\r\nThe 2nd line of output reports zero time spent in tcp and ssl handshaking.\r\nFurther, if you tell curl to output response headers (curl -D -) you\'ll see\r\n"Connection: keep-alive". This is data showing that at least some of big folks\r\nwith massive qps are using keep alive.\r\n\r\nRemember that new handshakes are high cpu usage, but existing SSL connections\r\ngenerally aren\'t as they are using a cheaper block cipher after the handshake.\r\nDisabling keep alive ensures that every request will incur an SSL handshake\r\nwhich can quickly overload a moderately-used server without SSL acceleration\r\nhardware if you have a large ssl key (2048 or 4096bit key).\r\n\r\nEven if you have SSL offloading to special hardware, you\'re still\r\nincuring the higher network latency that can\'t be compensated by faster\r\nhardware. Frankly, in most cases it\'s more cost effective to buy a weaker SSL\r\ncertificate (1024 bit) than it is to buy SSL hardware - See <a href="http://en.oreilly.com/velocity2010/public/schedule/detail/14217">Google\'s Velocity 2010 talk on SSL</a>.\r\n\r\nBy the way, on modern hardware you can do a decent number of SSL handshakes per\r\nsecond with 1024bit keys, but 2048bit and 4096bit keys are much harder:\r\n<pre># \'openssl speed rsa\' done on an Intel X5550 (2.66gHz)\r\nrsa 1024 bits 0.000496s 0.000027s   2016.3  36713.2\r\nrsa 2048 bits 0.003095s 0.000093s    323.1  10799.2\r\nrsa 4096 bits 0.021688s 0.000345s     46.1   2901.5\r\n</pre>\r\nFixing SSL latency is not totally trivial. The CPU intensive part can be\r\nhandled by special hardware if you can afford it, but the only way sure way to\r\nsolve network round-trip latency is to be closer to your user and/or to work on\r\nminimizing the total number of round-trips. You can be further from your users\r\nif you don\'t force things like keep-alive to be off, which can save you money\r\nin the long run by letting you have better choices of datacenter locations.\r\n\r\n</div>','SSL handshake latency and HTTPS optimizations','','publish','open','open','','ssl-handshake-latency-and-https-optimizations','','','2016-11-01 17:17:19','2016-11-01 09:17:19','',0,'https://blog-scottwang.rhcloud.com/?p=65',0,'post','',0),
 (67,1,'2016-11-01 17:19:56','2016-11-01 09:19:56','from:\r\n<a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank">http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html</a>\r\n\r\n<article class="hentry">\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n本文介绍如何将一个 HTTP 网站升级到 HTTPS 。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016082601.png" alt="" />\r\n<h2>一、获取证书</h2>\r\n升级到 HTTPS 协议的第一步，就是要获得一张证书。\r\n\r\n证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，要从经销商购买。\r\n<blockquote>\r\n<ul>\r\n 	<li><a href="https://www.gogetssl.com/" target="_blank">GoGetSSL</a></li>\r\n 	<li><a href="https://www.ssls.com/" target="_blank">SSLs.com</a></li>\r\n 	<li><a href="https://sslmate.com/" target="_blank">SSLmate.com</a></li>\r\n</ul>\r\n</blockquote>\r\n证书有很多类型，首先分为三种认证级别。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016082602.png" alt="" />\r\n<blockquote>\r\n<ul>\r\n 	<li><strong>域名认证</strong>（Domain Validation）：最低级别认证，可以确认申请人拥有这个域名。对于这种证书，浏览器会在地址栏显示一把锁。</li>\r\n 	<li><strong>公司认证</strong>（Company Validation）：确认域名所有人是哪一家公司，证书里面会包含公司信息。</li>\r\n 	<li><strong>扩展认证</strong>（Extended Validation）：最高级别的认证，浏览器地址栏会显示公司名。</li>\r\n</ul>\r\n</blockquote>\r\n还分为三种覆盖范围。\r\n<blockquote>\r\n<ul>\r\n 	<li><strong>单域名证书</strong>：只能用于单一域名，<code>foo.com</code>的证书不能用于<code>www.foo.com</code></li>\r\n 	<li><strong>通配符证书</strong>：可以用于某个域名及其所有一级子域名，比如<code>*.foo.com</code>的证书可以用于<code>foo.com</code>，也可以用于<code>www.foo.com</code></li>\r\n 	<li><strong>多域名证书</strong>：可以用于多个域名，比如<code>foo.com</code>和<code>bar.com</code></li>\r\n</ul>\r\n</blockquote>\r\n认证级别越高、覆盖范围越广的证书，价格越贵。\r\n\r\n还有一个免费证书的选择。为了推广HTTPS协议，电子前哨基金会EFF成立了 <a href="https://letsencrypt.org/" target="_blank">Let\'s Encrypt</a>，提供免费证书（<a href="https://www.digitalocean.com/community/tags/let-s-encrypt?type=tutorials" target="_blank">教程</a>和<a href="https://certbot.eff.org/" target="_blank">工具</a>）。\r\n\r\n拿到证书以后，可以用 <a href="https://tools.keycdn.com/ssl" target="_blank">SSL Certificate Check</a> 检查一下，信息是否正确。\r\n<h2>二、安装证书</h2>\r\n证书可以放在<code>/etc/ssl</code>目录（Linux 系统），然后根据你使用的Web服务器进行配置。\r\n<blockquote>\r\n<ul>\r\n 	<li><a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank">证书配置文件生成器</a>，by Mozilla</li>\r\n 	<li><a href="https://github.com/SSLMate/tlsconfigguide/tree/master/templates" target="_blank">配置文件模板</a>，by SSLMate</li>\r\n</ul>\r\n</blockquote>\r\n如果使用 Let\'s Encrypt 证书，请使用自动安装工具 <a href="https://certbot.eff.org/" target="_blank">Certbot</a>。\r\n\r\n安装成功后，使用 <a href="https://www.ssllabs.com/ssltest/analyze.html" target="_blank">SSL Labs Server Test</a> 检查一下证书是否生效。\r\n<h2>三、修改链接</h2>\r\n下一步，网页加载的 HTTP 资源，要全部改成 HTTPS 链接。因为加密网页内如果有非加密的资源，浏览器是不会加载那些资源的。\r\n<blockquote>\r\n<pre class=" language-markup"><code class=" language-markup">\r\n<span class="token script"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><a class="token url-link" href="http://foo.com/jquery.js">http://foo.com/jquery.js</a><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>\r\n</code></pre>\r\n</blockquote>\r\n上面这行加载命令，有两种改法。\r\n<blockquote>\r\n<pre class=" language-markup"><code class=" language-markup">\r\n<span class="token comment" spellcheck="true">&lt;!-- 改法一 --&gt;</span>\r\n<span class="token script"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><a class="token url-link" href="https://foo.com/jquery.js">https://foo.com/jquery.js</a><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>\r\n\r\n<span class="token comment" spellcheck="true">&lt;!-- 改法二 --&gt;</span>\r\n<span class="token script"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//foo.com/jquery.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>\r\n</code></pre>\r\n</blockquote>\r\n其中，改法二会根据当前网页的协议，加载相同协议的外部资源，更灵活一些。\r\n\r\n另外，如果页面头部用到了<code>rel="canonical"</code>，也要改成HTTPS网址。\r\n<blockquote>\r\n<pre class=" language-markup"><code class=" language-markup">\r\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>canonical<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><a class="token url-link" href="https://foo.com/bar.html">https://foo.com/bar.html</a><span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>四、301重定向</h2>\r\n下一步，修改 Web 服务器的配置文件，使用 301 重定向，将 HTTP 协议的访问导向 HTTPS 协议。\r\n\r\n<a href="https://serverfault.com/questions/67316/in-nginx-how-can-i-rewrite-all-http-requests-to-https-while-maintaining-sub-dom" target="_blank">Nginx 的写法</a>。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\nserver {\r\n  listen 80;\r\n  server_name domain.com www.domain.com;\r\n  return 301 <a class="token url-link" href="https://domain.com">https://domain.com</a>$request_uri;\r\n}\r\n</code></pre>\r\n</blockquote>\r\n<a href="https://httpd.apache.org/docs/2.4/rewrite/remapping.html#canonicalhost" target="_blank">Apache 的写法</a>（<code>.htaccess</code>文件）。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\nRewriteEngine On\r\nRewriteCond <span class="token operator">%</span><span class="token punctuation">{</span>HTTPS<span class="token punctuation">}</span> off\r\nRewriteRule <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">%</span><span class="token punctuation">{</span>HTTP_HOST<span class="token punctuation">}</span><span class="token operator">%</span><span class="token punctuation">{</span>REQUEST_URI<span class="token punctuation">}</span> <span class="token punctuation">[</span>R<span class="token operator">=</span><span class="token number">301</span><span class="token punctuation">,</span>L<span class="token punctuation">]</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>五、安全措施</h2>\r\n以下措施可以进一步保证通信安全。\r\n<h3>5.1 HTTP Strict Transport Security (HSTS)</h3>\r\n访问网站时，用户很少直接在地址栏输入<code>https://</code>，总是通过点击链接，或者3xx重定向，从<code>HTTP</code>页面进入<code>HTTPS</code>页面。攻击者完全可以在用户发出<code>HTTP</code>请求时，劫持并篡改该请求。\r\n\r\n另一种情况是恶意网站使用自签名证书，冒充另一个网站，这时浏览器会给出警告，但是许多用户会忽略警告继续访问。\r\n\r\n"HTTP严格传输安全"（简称 HSTS）的作用，就是强制浏览器只能发出<code>HTTPS</code>请求，并阻止用户接受不安全的证书。\r\n\r\n它在网站的响应头里面，加入一个强制性声明。以下例子摘自<a href="https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8" target="_blank">维基百科</a>。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Strict-Transport-Security:</span> max-age=31536000; includeSubDomains\r\n</code></pre>\r\n</blockquote>\r\n上面这段头信息有两个作用。\r\n<blockquote>（1）在接下来的一年（即31536000秒）中，浏览器只要向<code>example.com</code>或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。用户点击超链接或在地址栏输入<code>http://www.example.com/</code>，浏览器应当自动将<code>http</code>转写成<code>https</code>，然后直接向<code>https://www.example.com/</code>发送请求。\r\n\r\n（2）在接下来的一年中，如果<code>example.com</code>服务器发送的证书无效，用户不能忽略浏览器警告，将无法继续访问该网站。</blockquote>\r\nHSTS 很大程度上解决了 SSL 剥离攻击。只要浏览器曾经与服务器建立过一次安全连接，之后浏览器会强制使用<code>HTTPS</code>，即使链接被换成了<code>HTTP</code>。\r\n\r\n该方法的主要不足是，用户首次访问网站发出HTTP请求时，是不受HSTS保护的。\r\n\r\n如果想要全面分析网站的安全程度，可以使用 Mozilla 的 <a href="https://observatory.mozilla.org/" target="_blank">Observatory</a>。\r\n<h3>5.2 Cookie</h3>\r\n另一个需要注意的地方是，确保浏览器只在使用 HTTPS 时，才发送Cookie。\r\n\r\n网站响应头里面，<code>Set-Cookie</code>字段加上<code>Secure</code>标志即可。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n<span class="token keyword">Set-Cookie:</span> LSID=DQAAAK...Eaem_vYg; Secure\r\n</code></pre>\r\n</blockquote>\r\n<h2>六、参考链接</h2>\r\n<ul>\r\n 	<li><a href="https://docs.google.com/document/d/1oRXJUIttqQxuxmjj2tgYjj096IKw4Zcw6eAoIKWZ2oQ/edit#" target="_blank">How To Migrate To HTTPS</a>, by Chris Palmer</li>\r\n 	<li><a href="https://www.keycdn.com/blog/http-to-https/" target="_blank">Complete Guide - How to Migrate from HTTP to HTTPS</a>, by KeyCDN</li>\r\n 	<li><a href="http://smallbiztrends.com/2015/04/changing-from-http-to-https.html" target="_blank">What You Need to Know About Changing From Http to Https</a>, by Matt Mansfield</li>\r\n</ul>\r\n（完）\r\n\r\n</div>\r\n</article>','HTTPS升级指南','','publish','open','open','','migrate-from-http-to-https','','','2016-11-01 17:19:56','2016-11-01 09:19:56','',0,'https://blog-scottwang.rhcloud.com/?p=67',0,'post','',0),
 (69,1,'2016-11-01 17:26:30','2016-11-01 09:26:30','from:\r\n<a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html">http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n你遇到过性能很差的网页吗？\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n这种网页响应非常缓慢，占用大量的CPU和内存，浏览起来常常有卡顿，页面的动画效果也不流畅。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091508.jpg" alt="" />\r\n\r\n你会有什么反应？我猜想，大多数用户会关闭这个页面，改为访问其他网站。作为一个开发者，肯定不愿意看到这种情况，那么怎样才能提高性能呢？\r\n\r\n<strong>本文将详细介绍性能问题的出现原因，以及解决方法。</strong>\r\n<h2>一、网页生成的过程</h2>\r\n要理解网页性能为什么不好，就要了解网页是怎么生成的。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091501.png" alt="" />\r\n\r\n网页的生成过程，大致可以分成五步。\r\n<blockquote>\r\n<ol start="1">\r\n 	<li>HTML代码转化成DOM</li>\r\n 	<li>CSS代码转化成CSSOM（CSS Object Model）</li>\r\n 	<li>结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）</li>\r\n 	<li>生成布局（layout），即将所有渲染树的所有节点进行平面合成</li>\r\n 	<li>将布局绘制（paint）在屏幕上</li>\r\n</ol>\r\n</blockquote>\r\n这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。\r\n\r\n<strong>"生成布局"（flow）和"绘制"（paint）这两步，合称为"渲染"（render）。</strong>\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png" alt="" />\r\n<h2>二、重排和重绘</h2>\r\n<strong>网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。</strong>\r\n\r\n以下三种情况，会导致网页重新渲染。\r\n<blockquote>\r\n<ul>\r\n 	<li>修改DOM</li>\r\n 	<li>修改样式表</li>\r\n 	<li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li>\r\n</ul>\r\n</blockquote>\r\n<strong>重新渲染，就需要重新生成布局和重新绘制。前者叫做"重排"（reflow），后者叫做"重绘"（repaint）。</strong>\r\n\r\n需要注意的是，<strong>"重绘"不一定需要"重排"</strong>，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。但是，<strong>"重排"必然导致"重绘"</strong>，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。\r\n<h2>三、对于性能的影响</h2>\r\n重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。\r\n\r\n<strong>提高网页性能，就是要降低"重排"和"重绘"的频率和成本，尽量少触发重新渲染。</strong>\r\n\r\n前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\ndiv<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">\'blue\'</span><span class="token punctuation">;</span>\r\ndiv<span class="token punctuation">.</span>style<span class="token punctuation">.</span>marginTop <span class="token operator">=</span> <span class="token string">\'30px\'</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。\r\n\r\n如果写得不好，就会触发两次重排和重绘。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\ndiv<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">\'blue\'</span><span class="token punctuation">;</span>\r\n<span class="token keyword">var</span> margin <span class="token operator">=</span> <span class="token function">parseInt<span class="token punctuation">(</span></span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>marginTop<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\ndiv<span class="token punctuation">.</span>style<span class="token punctuation">.</span>marginTop <span class="token operator">=</span> <span class="token punctuation">(</span>margin <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">\'px\'</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。\r\n\r\n一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。\r\n<blockquote>\r\n<ul>\r\n 	<li>offsetTop/offsetLeft/offsetWidth/offsetHeight</li>\r\n 	<li>scrollTop/scrollLeft/scrollWidth/scrollHeight</li>\r\n 	<li>clientTop/clientLeft/clientWidth/clientHeight</li>\r\n 	<li>getComputedStyle()</li>\r\n</ul>\r\n</blockquote>\r\n所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">\r\n// bad\r\n</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetLeft <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>\r\ndiv<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetTop <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>\r\n<span class="token comment" spellcheck="true">\r\n// good\r\n</span><span class="token keyword">var</span> left <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>\r\n<span class="token keyword">var</span> top  <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>\r\ndiv<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>\r\ndiv<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> top <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n一般的规则是：\r\n<blockquote>\r\n<ul>\r\n 	<li>样式表越简单，重排和重绘就越快。</li>\r\n 	<li>重排和重绘的DOM元素层级越高，成本就越高。</li>\r\n 	<li>table元素的重排和重绘成本，要高于div元素</li>\r\n</ul>\r\n</blockquote>\r\n<h2>四、提高性能的九个技巧</h2>\r\n有一些技巧，可以降低浏览器重新渲染的频率和成本。\r\n\r\n<strong>第一条</strong>是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。\r\n\r\n<strong>第二条</strong>，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。\r\n\r\n<strong>第三条</strong>，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">\r\n// bad\r\n</span><span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\r\n<span class="token keyword">var</span> top <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\r\nel<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>\r\nel<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top  <span class="token operator">=</span> top  <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>\r\n<span class="token comment" spellcheck="true">\r\n// good \r\n</span>el<span class="token punctuation">.</span>className <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">" theclassname"</span><span class="token punctuation">;</span>\r\n<span class="token comment" spellcheck="true">\r\n// good\r\n</span>el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"; left: "</span> <span class="token operator">+</span> left <span class="token operator">+</span> <span class="token string">"px; top: "</span> <span class="token operator">+</span> top <span class="token operator">+</span> <span class="token string">"px;"</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n<strong>第四条</strong>，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。\r\n\r\n<strong>第五条</strong>，先将元素设为<code>display: none</code>（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。\r\n\r\n<strong>第六条</strong>，position属性为<code>absolute</code>或<code>fixed</code>的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。\r\n\r\n<strong>第七条</strong>，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，<code>visibility : hidden</code>的元素只对重绘有影响，不影响重排。\r\n\r\n<strong>第八条</strong>，使用虚拟DOM的脚本库，比如React等。\r\n\r\n<strong>第九条</strong>，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染（详见后文）。\r\n<h2>五、刷新率</h2>\r\n很多时候，密集的重新渲染是无法避免的，比如scroll事件的回调函数和网页动画。\r\n\r\n<strong>网页动画的每一帧（frame）都是一次重新渲染。</strong>每秒低于24帧的动画，人眼就能感受到停顿。<strong>一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。</strong>如果能达到每秒70帧甚至80帧，就会极其流畅。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091509.jpg" alt="" />\r\n\r\n大多数显示器的刷新频率是60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，刷新动画（如果可以做到的话）。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091510.jpg" alt="" />\r\n\r\n所以，如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，<strong>一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。</strong>\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091511.png" alt="" />\r\n\r\n<strong>一秒之间能够完成多少次重新渲染，这个指标就被称为"刷新率"，英文为FPS（frame per second）。</strong>60次重新渲染，就是60FPS。\r\n\r\n如果想达到60帧的刷新率，就意味着JavaScript线程每个任务的耗时，必须少于16毫秒。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。\r\n<h2>六、开发者工具的Timeline面板</h2>\r\nChrome浏览器开发者工具的Timeline面板，是查看"刷新率"的最佳工具。这一节介绍如何使用这个工具。\r\n\r\n首先，按下 F12 打开"开发者工具"，切换到Timeline面板。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091512.png" alt="" />\r\n\r\n左上角有一个灰色的圆点，这是录制按钮，按下它会变成红色。然后，在网页上进行一些操作，再按一次按钮完成录制。\r\n\r\nTimeline面板提供两种查看方式：横条的是"事件模式"（Event Mode），显示重新渲染的各种事件所耗费的时间；竖条的是"帧模式"（Frame Mode），显示每一帧的时间耗费在哪里。\r\n\r\n先看"事件模式"，你可以从中判断，性能问题发生在哪个环节，是JavaScript的执行，还是渲染？\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091514.png" alt="" />\r\n\r\n不同的颜色表示不同的事件。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091503.png" alt="" />\r\n<blockquote>\r\n<ul>\r\n 	<li>蓝色：网络通信和HTML解析</li>\r\n 	<li>黄色：JavaScript执行</li>\r\n 	<li>紫色：样式计算和布局，即重排</li>\r\n 	<li>绿色：重绘</li>\r\n</ul>\r\n</blockquote>\r\n哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091515.png" alt="" />\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091516.png" alt="" />\r\n\r\n帧模式（Frames mode）用来查看单个帧的耗时情况。每帧的色柱高度越低越好，表示耗时少。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091505.png" alt="" />\r\n\r\n你可以看到，帧模式有两条水平的参考线。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091517.png" alt="" />\r\n\r\n下面的一条是60FPS，低于这条线，可以达到每秒60帧；上面的一条是30FPS，低于这条线，可以达到每秒30次渲染。如果色柱都超过30FPS，这个网页就有性能问题了。\r\n\r\n此外，还可以查看某个区间的耗时情况。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091518.png" alt="" />\r\n\r\n或者点击每一帧，查看该帧的时间构成。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091519.png" alt="" />\r\n<h2>七、window.requestAnimationFrame()</h2>\r\n有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。\r\n\r\n其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token keyword">function</span> <span class="token function">doubleHeight<span class="token punctuation">(</span></span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>\r\n  <span class="token keyword">var</span> currentHeight <span class="token operator">=</span> element<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>\r\n  element<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token punctuation">(</span>currentHeight <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">\'px\'</span><span class="token punctuation">;</span>\r\n<span class="token punctuation">}</span>\r\nelements<span class="token punctuation">.</span><span class="token function">forEach<span class="token punctuation">(</span></span>doubleHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n上面的代码使用循环操作，将每个元素的高度都增加一倍。可是，每次循环都是，读操作后面跟着一个写操作。这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。\r\n\r\n我们可以使用<code>window.requestAnimationFrame()</code>，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token keyword">function</span> <span class="token function">doubleHeight<span class="token punctuation">(</span></span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>\r\n  <span class="token keyword">var</span> currentHeight <span class="token operator">=</span> element<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>\r\n  window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame<span class="token punctuation">(</span></span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\r\n    element<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token punctuation">(</span>currentHeight <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">\'px\'</span><span class="token punctuation">;</span>\r\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n<span class="token punctuation">}</span>\r\nelements<span class="token punctuation">.</span><span class="token function">forEach<span class="token punctuation">(</span></span>doubleHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n页面滚动事件（scroll）的监听函数，就很适合用 window.requestAnimationFrame() ，推迟到下一次重新渲染。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$<span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">\'scroll\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\r\n   window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame<span class="token punctuation">(</span></span>scrollHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n当然，最适用的场合还是网页动画。下面是一个旋转动画的例子，元素每一帧旋转1度。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token keyword">var</span> rAF <span class="token operator">=</span> window<span class="token punctuation">.</span>requestAnimationFrame<span class="token punctuation">;</span>\r\n\r\n<span class="token keyword">var</span> degrees <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\r\n<span class="token keyword">function</span> <span class="token function">update<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\r\n  div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>transform <span class="token operator">=</span> <span class="token string">"rotate("</span> <span class="token operator">+</span> degrees <span class="token operator">+</span> <span class="token string">"deg)"</span><span class="token punctuation">;</span>\r\n  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">\'updated to degrees \'</span> <span class="token operator">+</span> degrees<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n  degrees <span class="token operator">=</span> degrees <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\r\n  <span class="token function">rAF<span class="token punctuation">(</span></span>update<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n<span class="token punctuation">}</span>\r\n<span class="token function">rAF<span class="token punctuation">(</span></span>update<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>八、window.requestIdleCallback()</h2>\r\n还有一个函数<a href="https://w3c.github.io/requestidlecallback/" target="_blank">window.requestIdleCallback()</a>，也可以用来调节重新渲染。\r\n\r\n它指定只有当一帧的末尾有空闲时间，才会执行回调函数。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token function">requestIdleCallback<span class="token punctuation">(</span></span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。\r\n\r\n它还可以接受第二个参数，表示指定的毫秒数。如果在指定\r\n的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token function">requestIdleCallback<span class="token punctuation">(</span></span>fn<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n上面的代码表示，函数fn最迟会在5000毫秒之后执行。\r\n\r\n函数 fn 可以接受一个 deadline 对象作为参数。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token function">requestIdleCallback<span class="token punctuation">(</span></span><span class="token keyword">function</span> <span class="token function">someHeavyComputation<span class="token punctuation">(</span></span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>\r\n  <span class="token keyword">while</span><span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\r\n    <span class="token function">doWorkIfNeeded<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n  <span class="token punctuation">}</span>\r\n\r\n  <span class="token keyword">if</span><span class="token punctuation">(</span>thereIsMoreWorkToDo<span class="token punctuation">)</span> <span class="token punctuation">{</span>\r\n    <span class="token function">requestIdleCallback<span class="token punctuation">(</span></span>someHeavyComputation<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n  <span class="token punctuation">}</span>\r\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n上面代码中，回调函数 someHeavyComputation 的参数是一个 deadline 对象。\r\n\r\ndeadline对象有一个方法和一个属性：timeRemaining() 和 didTimeout。\r\n\r\n<strong>（1）timeRemaining() 方法</strong>\r\n\r\ntimeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮<code>requestIdleCallback</code>。\r\n\r\n前面的示例代码之中，只要当前帧还有空闲时间，就不断调用doWorkIfNeeded方法。一旦没有空闲时间，但是任务还没有全执行，就分配到下一轮<code>requestIdleCallback</code>。\r\n\r\n<strong>（2）didTimeout属性</strong>\r\n\r\ndeadline对象的 <code>didTimeout</code> 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。\r\n<blockquote>\r\n<ul>\r\n 	<li>timeRemaining方法返回0</li>\r\n 	<li>didTimeout 属性等于 true</li>\r\n</ul>\r\n</blockquote>\r\n因此，如果回调函数执行了，无非是两种原因：当前帧有空闲时间，或者指定时间到了。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token keyword">function</span> myNonEssentialWork <span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>\r\n  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> deadline<span class="token punctuation">.</span>didTimeout<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tasks<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\r\n    <span class="token function">doWorkIfNeeded<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n\r\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\r\n    <span class="token function">requestIdleCallback<span class="token punctuation">(</span></span>myNonEssentialWork<span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n<span class="token punctuation">}</span>\r\n\r\n<span class="token function">requestIdleCallback<span class="token punctuation">(</span></span>myNonEssentialWork<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\r\n</code></pre>\r\n</blockquote>\r\n上面代码确保了，doWorkIfNeeded 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。\r\n\r\nrequestIdleCallback 是一个很新的函数，刚刚引入标准，目前只有Chrome支持，不过其他浏览器可以用<a href="https://gist.github.com/paullewis/55efe5d6f05434a96c36" target="_blank">垫片库</a>。\r\n<h2>九、参考链接</h2>\r\n<ul>\r\n 	<li>Domenico De Felice, <a href="http://domenicodefelice.blogspot.sg/2015/08/how-browsers-work.html" target="_blank">How browsers work</a></li>\r\n 	<li>Stoyan Stefanov, <a href="http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/" target="_blank">Rendering: repaint, reflow/relayout, restyle</a></li>\r\n 	<li>Addy Osmani, <a href="http://addyosmani.com/blog/performance-optimisation-with-timeline-profiles/" target="_blank">Improving Web App Performance With the Chrome DevTools Timeline and Profiles</a></li>\r\n 	<li>Tom Wiltzius, <a href="http://www.html5rocks.com/en/tutorials/speed/rendering/" target="_blank">Jank Busting for Better Rendering Performance</a></li>\r\n 	<li>Paul Lewis, <a href="https://developers.google.com/web/updates/2015/08/27/using-requestidlecallback?hl=en" target="_blank">Using requestIdleCallback</a></li>\r\n</ul>\r\n（完）\r\n\r\n</div>\r\n</article>','网页性能管理详解','','publish','open','open','','web-page-performance-in-depth','','','2016-11-01 17:26:30','2016-11-01 09:26:30','',0,'https://blog-scottwang.rhcloud.com/?p=69',0,'post','',0),
 (71,1,'2016-11-01 17:29:29','2016-11-01 09:29:29','from:\r\n<a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">http://www.ruanyifeng.com/blog/2015/08/git-use-process.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。\r\n\r\n下面是<a href="https://github.com/thoughtbot/guides/tree/master/protocol/git" target="_blank">ThoughtBot</a> 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015080501.png" alt="" />\r\n<h2>第一步：新建分支</h2>\r\n首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank">《Git分支管理策略》</a>）。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 获取主干最新代码\r\n</span>$ git checkout master\r\n$ git pull\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个开发分支myfeature\r\n</span>$ git checkout <span class="token operator">-</span>b myfeature\r\n</code></pre>\r\n</blockquote>\r\n<h2>第二步：提交分支commit</h2>\r\n分支修改后，就可以提交commit了。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ git add <span class="token operator">--</span>all\r\n$ git status\r\n$ git commit <span class="token operator">--</span>verbose\r\n</code></pre>\r\n</blockquote>\r\ngit add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。\r\n\r\ngit status 命令，用来查看发生变动的文件。\r\n\r\ngit commit 命令的verbose参数，会列出 <a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank">diff</a> 的结果。\r\n<h2>第三步：撰写提交信息</h2>\r\n提交commit时，必须给出完整扼要的提交信息，下面是一个范本。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\nPresent<span class="token operator">-</span>tense summary under <span class="token number">50</span> characters\r\n\r\n<span class="token operator">*</span> More information about commit <span class="token punctuation">(</span>under <span class="token number">72</span> characters<span class="token punctuation">)</span><span class="token punctuation">.</span>\r\n<span class="token operator">*</span> More information about commit <span class="token punctuation">(</span>under <span class="token number">72</span> characters<span class="token punctuation">)</span><span class="token punctuation">.</span>\r\n\r\nhttp<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>project<span class="token punctuation">.</span>management<span class="token operator">-</span>system<span class="token punctuation">.</span>com<span class="token operator">/</span>ticket<span class="token operator">/</span><span class="token number">123</span>\r\n</code></pre>\r\n</blockquote>\r\n第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。\r\n<h2>第四步：与主干同步</h2>\r\n分支的开发过程中，要经常与主干保持同步。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ git fetch origin\r\n$ git rebase origin<span class="token operator">/</span>master\r\n</code></pre>\r\n</blockquote>\r\n<h2>第五步：合并commit</h2>\r\n分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。\r\n\r\n那么，怎样才能将多个commit合并呢？这就要用到 git rebase 命令。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ git rebase <span class="token operator">-</span>i origin<span class="token operator">/</span>master\r\n</code></pre>\r\n</blockquote>\r\ngit rebase命令的i参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。\r\n\r\n下面采用<a href="https://robots.thoughtbot.com/git-interactive-rebase-squash-amend-rewriting-history" target="_blank">Tute Costa</a>的例子，来解释怎么合并commit。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\npick 07c5abd Introduce OpenPGP and teach basic usage\r\npick de9b1eb Fix PostChecker<span class="token punctuation">:</span><span class="token punctuation">:</span>Post<span class="token comment" spellcheck="true">#urls\r\n</span>pick 3e7ee36 Hey kids<span class="token punctuation">,</span> stop all the highlighting\r\npick fa20af3 git interactive rebase<span class="token punctuation">,</span> squash<span class="token punctuation">,</span> amend\r\n\r\n<span class="token comment" spellcheck="true"># Rebase 8db7e8b..fa20af3 onto 8db7e8b\r\n</span><span class="token comment" spellcheck="true">#\r\n</span><span class="token comment" spellcheck="true"># Commands:\r\n</span><span class="token comment" spellcheck="true">#  p, pick = use commit\r\n</span><span class="token comment" spellcheck="true">#  r, reword = use commit, but edit the commit message\r\n</span><span class="token comment" spellcheck="true">#  e, edit = use commit, but stop for amending\r\n</span><span class="token comment" spellcheck="true">#  s, squash = use commit, but meld into previous commit\r\n</span><span class="token comment" spellcheck="true">#  f, fixup = like "squash", but discard this commit\'s log message\r\n</span><span class="token comment" spellcheck="true">#  x, exec = run command (the rest of the line) using shell\r\n</span><span class="token comment" spellcheck="true">#\r\n</span><span class="token comment" spellcheck="true"># These lines can be re-ordered; they are executed from top to bottom.\r\n</span><span class="token comment" spellcheck="true">#\r\n</span><span class="token comment" spellcheck="true"># If you remove a line here THAT COMMIT WILL BE LOST.\r\n</span><span class="token comment" spellcheck="true">#\r\n</span><span class="token comment" spellcheck="true"># However, if you remove everything, the rebase will be aborted.\r\n</span><span class="token comment" spellcheck="true">#\r\n</span><span class="token comment" spellcheck="true"># Note that empty commits are commented out\r\n</span></code></pre>\r\n</blockquote>\r\n上面的互动界面，先列出当前分支最新的4个commit（越下面越新）。每个commit前面有一个操作命令，默认是pick，表示该行commit被选中，要进行rebase操作。\r\n\r\n4个commit的下面是一大堆注释，列出可以使用的命令。\r\n<blockquote>\r\n<ul>\r\n 	<li>pick：正常选中</li>\r\n 	<li>reword：选中，并且修改提交信息；</li>\r\n 	<li>edit：选中，rebase时会暂停，允许你修改这个commit（参考<a href="https://schacon.github.io/gitbook/4_interactive_rebasing.html" target="_blank">这里</a>）</li>\r\n 	<li>squash：选中，会将当前commit与上一个commit合并</li>\r\n 	<li>fixup：与squash相同，但不会保存当前commit的提交信息</li>\r\n 	<li>exec：执行其他shell命令</li>\r\n</ul>\r\n</blockquote>\r\n上面这6个命令当中，squash和fixup可以用来合并commit。先把需要合并的commit前面的动词，改成squash（或者s）。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\npick 07c5abd Introduce OpenPGP and teach basic usage\r\ns de9b1eb Fix PostChecker<span class="token punctuation">:</span><span class="token punctuation">:</span>Post<span class="token comment" spellcheck="true">#urls\r\n</span>s 3e7ee36 Hey kids<span class="token punctuation">,</span> stop all the highlighting\r\npick fa20af3 git interactive rebase<span class="token punctuation">,</span> squash<span class="token punctuation">,</span> amend\r\n</code></pre>\r\n</blockquote>\r\n这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># This is a combination of 3 commits.\r\n</span><span class="token comment" spellcheck="true"># The first commit\'s message is:\r\n</span>Introduce OpenPGP and teach basic usage\r\n\r\n<span class="token comment" spellcheck="true"># This is the 2nd commit message:\r\n</span>Fix PostChecker<span class="token punctuation">:</span><span class="token punctuation">:</span>Post<span class="token comment" spellcheck="true">#urls\r\n</span>\r\n<span class="token comment" spellcheck="true"># This is the 3rd commit message:\r\n</span>Hey kids<span class="token punctuation">,</span> stop all the highlighting\r\n</code></pre>\r\n</blockquote>\r\n如果将第三行的squash命令改成fixup命令。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\npick 07c5abd Introduce OpenPGP and teach basic usage\r\ns de9b1eb Fix PostChecker<span class="token punctuation">:</span><span class="token punctuation">:</span>Post<span class="token comment" spellcheck="true">#urls\r\n</span>f 3e7ee36 Hey kids<span class="token punctuation">,</span> stop all the highlighting\r\npick fa20af3 git interactive rebase<span class="token punctuation">,</span> squash<span class="token punctuation">,</span> amend\r\n</code></pre>\r\n</blockquote>\r\n运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># This is a combination of 3 commits.\r\n</span><span class="token comment" spellcheck="true"># The first commit\'s message is:\r\n</span>Introduce OpenPGP and teach basic usage\r\n\r\n<span class="token comment" spellcheck="true"># This is the 2nd commit message:\r\n</span>Fix PostChecker<span class="token punctuation">:</span><span class="token punctuation">:</span>Post<span class="token comment" spellcheck="true">#urls\r\n</span>\r\n<span class="token comment" spellcheck="true"># This is the 3rd commit message:\r\n</span><span class="token comment" spellcheck="true"># Hey kids, stop all the highlighting\r\n</span></code></pre>\r\n</blockquote>\r\n<a href="http://ponyfoo.com/articles/git-github-hacks" target="_blank">Pony Foo</a>提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ git reset HEAD<span class="token operator">~</span><span class="token number">5</span>\r\n$ git add <span class="token punctuation">.</span>\r\n$ git commit <span class="token operator">-</span>am "Here\'s the bug fix that closes <span class="token comment" spellcheck="true">#28"\r\n</span>$ git push <span class="token operator">--</span>force\r\n</code></pre>\r\n</blockquote>\r\nsquash和fixup命令，还可以当作命令行参数使用，自动合并commit。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ git commit <span class="token operator">--</span>fixup  \r\n$ git rebase <span class="token operator">-</span>i <span class="token operator">--</span>autosquash \r\n</code></pre>\r\n</blockquote>\r\n这个用法请参考<a href="http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html" target="_blank">这篇文章</a>，这里就不解释了。\r\n<h2>第六步：推送到远程仓库</h2>\r\n合并commit后，就可以推送当前分支到远程仓库了。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ git push <span class="token operator">--</span>force origin myfeature\r\n</code></pre>\r\n</blockquote>\r\ngit push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送（参见<a href="http://willi.am/blog/2014/08/12/the-dark-side-of-the-force-push/" target="_blank">这里</a>）。\r\n<h2>第七步：发出Pull Request</h2>\r\n提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','Git使用规范流程','','publish','open','open','','how-to-git','','','2016-11-01 17:29:29','2016-11-01 09:29:29','',0,'https://blog-scottwang.rhcloud.com/?p=71',0,'post','',0),
 (73,1,'2016-11-01 17:32:36','2016-11-01 09:32:36','from:\r\n<a href="http://www.ruanyifeng.com/blog/2015/09/git-bitmap.html">http://www.ruanyifeng.com/blog/2015/09/git-bitmap.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n使用 Github 的时候，你有没有见过下面的提示？\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n$ git clone https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>torvalds<span class="token operator">/</span>linux\r\nCloning into <span class="token string">\'linux\'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\r\nremote<span class="token punctuation">:</span> Counting objects<span class="token punctuation">:</span> <span class="token number">4350078</span><span class="token punctuation">,</span> <span class="token keyword">done</span><span class="token punctuation">.</span>\r\nremote<span class="token punctuation">:</span> Compressing objects<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">4677</span><span class="token operator">/</span><span class="token number">4677</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">done</span><span class="token punctuation">.</span>\r\nReceiving objects<span class="token punctuation">:</span>   <span class="token number">4</span><span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">191786</span><span class="token operator">/</span><span class="token number">4350078</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">78.19</span> MiB <span class="token operator">|</span> <span class="token number">8.70</span> MiB<span class="token operator">/</span>s\r\n</code></pre>\r\n</blockquote>\r\n这段提示说，远程代码库一共有4350078个对象需要克隆。\r\n\r\n<strong>这就叫"清点对象"（counting objects），Github需要实时计算出来，需要克隆的对象总数。</strong>\r\n\r\n这个过程非常慢，根据Github的披露，像Linux kernel这样巨大的库，清点一次需要8分钟！也就是说，发出<code>git clone</code>命令后，会干等八分钟，然后才会开始真正的数据传输。这当然是无法忍受的。Github团队一直想解决这个问题。\r\n\r\n后来，他们终于发现了一种新的<a href="http://githubengineering.com/counting-objects/" target="_blank">算法</a>，现在清点一次只要3毫秒！\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015093001.png" alt="" />\r\n\r\n为了理解这个算法，你必须先知道，什么是Git的对象。简单说，对象就是文件，最重要的对象有三种。\r\n<blockquote>\r\n<ul>\r\n 	<li>快照对象（Commit）</li>\r\n 	<li>目录对象（Directory）</li>\r\n 	<li>文件对象（File）</li>\r\n</ul>\r\n</blockquote>\r\n每次提交代码的时候，会生成一个commit对象，里面有对应的当前"目录对象"的名字。"目录对象"保存了代码根目录所含有的子目录和文件信息。每一个子目录就是另一个"目录对象"，每一个文件则是"文件对象"，里面是具体的文件内容。\r\n\r\n<strong>所以，"清点对象"就是清点各种commit、目录、文件等。</strong><code>git clone</code>和<code>git fetch</code>操作都需要清点对象，因为需要知道，到底下载哪些对象文件。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015093002.png" alt="" />\r\n\r\n清点对象的原始算法如下。\r\n<blockquote>\r\n<ol start="1">\r\n 	<li>列出本地所有分支最新的一个commit</li>\r\n 	<li>列出远程所有分支最新的一个commit</li>\r\n 	<li>两者进行比较，只要有不同，就意味着分支发生变动</li>\r\n 	<li>每一个发生变动的commit，都清点其中具体变动的子目录和文件</li>\r\n 	<li>追溯到当前commit的父节点，重复第四步，直至本地与远程的历史一致为止</li>\r\n 	<li>加总所有需要变动的对象</li>\r\n</ol>\r\n</blockquote>\r\n上面的过程说明，"清点对象"是一个文件遍历算法，变动的对象会被一一清点到，这就意味着大量的文件读操作。对于大型代码库来说，这个过程非常慢。\r\n\r\n<strong>Github团队想到的新算法，是建立一个Bitmap索引，即为每一个commit生成一个二进制值。</strong>\r\n\r\n打开本地Github仓库的<code>.git/objects/pack/</code>目录，你会看到一个索引文件和一个数据文件，它们就是Bitmap。简单说，这两个文件索引了当前代码库的所有对象，然后使用一个二进制值代表这些对象。有多少个对象，这个二进制值就有多少位。它的第n位，就代表数据文件里面的第n个对象。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015093003.png" alt="" />\r\n\r\n每个commit都会有一个对应的二进制值，表示当前快照包含的所有对象。这些对象对应的二进制位都为1，其他二进制位都为0。\r\n\r\n这样做的好处是，不用读取commit对象，只要读取这个二进制值，就会知道当前commit包含了哪些节点。更妙的是，两个二进制值只要做一次XOR运算，就会知道哪些位（即哪些对象）发生了变动。而且，因为新的对象总是添加到现有二进制位的后面，所以只要读取多出来的那些位，就知道当前commit比上一次commit多出了哪些对象。\r\n\r\n这样一来，"清点对象"就变成了二进制值的比较运算，因此速度极快。进一步的介绍，请参看官方文档<a href="https://github.com/gitster/git/commit/fff4275" target="_blank">《Bitmap的解释》</a>，<a href="https://github.com/gitster/git/blob/master/Documentation/technical/bitmap-format.txt" target="_blank">《Bitmap的格式》</a>。\r\n\r\n目前，Github的生产环境已经部署了这套算法，用户再也不用为了清点对象，而苦苦等待了。而且，Github团队还把它合并进了Git，这意味着，从此所有Git实现都可以使用Bitmap功能了，因此将来肯定还会有更多好玩的用法出现。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','Github清点对象算法','','publish','open','open','','github-counting-object-algorithm','','','2016-11-01 17:32:36','2016-11-01 09:32:36','',0,'https://blog-scottwang.rhcloud.com/?p=73',0,'post','',0),
 (75,1,'2016-11-01 17:37:58','2016-11-01 09:37:58','from:\r\n<a href="http://githubengineering.com/counting-objects/">http://githubengineering.com/counting-objects/</a>\r\n<div style="font-size: 0.8em; font-style: italic;"></div>\r\n<div style="font-size: 0.8em; font-style: italic;">\r\n\r\nThe Systems Team at GitHub works to solve complex bugs and performance bottlenecks at the lowest levels of our infrastructure. Over the past two years we’ve undertaken a major project to improve the performance of Git network operations (like clones or fetches) for the repositories we host.\r\n\r\nTwo years ago, if you cloned a large repository from any Git host, you probably found yourself waiting several minutes before data started being sent to your machine, while the server proudly announced that it was <em>“counting objects”</em>.\r\n<div class="highlighter-rouge">\r\n<pre class="highlight"><code>$ git clone https://github.com/torvalds/linux\r\nCloning into \'linux\'...\r\nremote: Counting objects: 4350078, done.\r\nremote: Compressing objects: 100% (4677/4677), done.\r\nReceiving objects:   4% (191786/4350078), 78.19 MiB | 8.70 MiB/s\r\n</code></pre>\r\n</div>\r\nHowever, if you try to clone the equivalent repository hosted on GitHub.com today, or on a GitHub Enterprise instance, you’ll notice that data starts being sent immediately and the transfer is only limited by your available bandwidth to the server.\r\n\r\nInquiring minds may wonder: What are these <em>objects</em>, why did you have to count them <em>every single time</em>, and why are you not counting them anymore?\r\n<h3 id="the-objects">The objects</h3>\r\nAll data in a Git repository is stored in the shape of a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph</a>. The history of the repository is ordered throughout time by the way commits are linked to each other. Each commit has a link to its parent, the commit that came right before it; some commits have two parents, the result of merging two branches together. At the same time, each commit has a link to a tree. The tree is a snapshot of the contents of the working directory in the moment where the commit was created. It contains links to all the files in the root of your repository, and links to other subtrees which are the folders and recursively link to more files and subtrees.\r\n\r\n<img src="http://githubengineering.com/images/counting-objects/dag-sketch.001.png" alt="Git repository DAG organization" />\r\n\r\nThe result is a highly dense forest of interlinked nodes stored in the shape of a graph, but essentially <a href="http://git-scm.com/book/en/v2/Git-Internals-Git-Objects">accessed as a key-value store</a> (each object in the database is only indexed by the SHA1 of its contents).\r\n<h2 id="the-counting">The counting</h2>\r\nWhen you connect to a Git daemon to perform a fetch, the client and the server perform a<strong>negotiation</strong>. The server shows the tips of all the branches it has, and the client replies by comparing those against the tips of its own branches. “I’ve already got all these objects. I want those! And those!”\r\n\r\n<img src="http://githubengineering.com/images/counting-objects/dag-sketch.002.png" alt="Object negotiation in a Git repository" />\r\n\r\nThere’s a very specific case of a fetch operation: a fresh clone, where little negotiation is necessary. The server offers the tips of its branches, and the client wants <em>all</em> of them, because it doesn’t have any.\r\n\r\nThis is when this whole ordeal starts becoming expensive, because the server has little information on what to actually send. Git doesn’t keep a definite list of all objects reachable from the graph, and it cannot send every single object in its database as a whole, because it could very well be that some of those objects are not reachable at all in the repository and should be thrown away instead of sent to the client. The only thing Git knows are the tips of all branches, so its only option is to walk down the graph, all the way to the beginning of the history, listing every single object that needs to be sent.\r\n\r\nEach commit in the history is loaded and added to the list of objects to send, and from each commit its tree is also expanded, and blobs and subtrees are also added to the list. This process scales with the size of the history of the repository (i.e. the amount of commits) and the actual size of the repository. The more files that exist on the repository, the longer it takes to iterate through the trees of each commit to find the few blobs that haven’t been listed yet.\r\n\r\nThis is the “Counting Objects” phase, and as you may gather, some repositories have a pretty big graph, with lots of objects to count.\r\n<h2 id="the-problem">The problem</h2>\r\nAt GitHub we serve some of the highest-traffic Git repositories on the internet, repositories which generally are also very large. A clone of the Linux kernel can take up to 8 minutes of CPU time in our infrastucture. Besides the poor user experience of having to wait several minutes before you can start receiving data in a clone, a thundering herd of these operations could significantly impact the availability of our platform. This is why the Systems team made it a priority to start researching workarounds for this issue.\r\n\r\nOur initial attempts involved caching the result of every clone in order to replay it to other clients asking for the same data. We quickly found out that this approach was not elegant and definitely not scalable.\r\n\r\nWhen it comes to caching clones, the repositories that matter the most are the most active ones. This makes caching the full result of a clone pointless, since the state of the repository changes constantly. On top of that, the initial caching still takes the same unreasonable amount of CPU time, and the size of the cache is about the same as that of the repository on disk. Each cached response roughly doubles the amount of disk space needed by the repository.\r\n\r\nBecause of these reasons, we decided against pursuing the caching approach. Generally speaking, caching specific results to queries is a weak approach to performance in complex systems. What you want to do instead is caching intermediate steps of the computation, to be able to efficiently answer any kind of query. In this case, we were looking for a system that would not only allow us to serve clones efficiently, but also complex fetches. Caching responses cannot accomplish this.\r\n\r\nIn 2013 we organized and obviously attended Git Merge in Berlin, the yearly conference (previously known as GitTogether) where developers of all the different Git implementations meet, mingle and attempt to cope with the fact that it’s 2015 and we’re writing version control systems for a living.\r\n\r\nThere, we were delighted to learn about the “bitmap index” patchset that Google’s <a href="https://eclipse.org/jgit/">JGit</a>engineers had written for their open-source Java implementation of Git. Back then the patchset was still experimental, but the concept was sound and the performance implications were very promising, so we decided to tread down that path and attempt to port the patchset to Git, with the hopes of being able to run it in our infrastucture and push it upstream for the whole community to benefit.\r\n<h2 id="the-idea">The idea</h2>\r\nThe idea behind bitmap indexes is not particularly novel: it is the same method that databases (especially relational ones) have used since the 1970s to speed up their more complex queries.\r\n\r\nIn Git’s case, the queries we’re trying to perform are <em>reachability queries</em>: given a set of commits, what are all of the objects in the graph that can be reached from those commits? This is the operation that the “Counting Objects” phase of a fetch performs, but we want to find the set of reachable objects without having to traverse every single object on the way.\r\n\r\nTo do so, we create indexes (stored as bitmaps) that contain the information required to answer these queries. For any given commit, its bitmap index marks all the objects that can be reached from it. To find the objects that can be reached from a commit, we simply look up its bitmap and check the marked bits on it; the graph doesn’t need to be traversed anymore, and an operation that used to take several minutes of CPU time (loading and traversing every single object in the graph) now takes less than 3ms.\r\n\r\n<img src="http://githubengineering.com/images/counting-objects/dag-sketch.003.png" alt="Git index implementation" />\r\n\r\nOf course, a practial implementation of these indexes has many details to work around:\r\n\r\nFirst and foremost, we cannot create an index for every single commit in the repository. That would consume too much storage! Instead, we use heuristics to decide the set of commits that will receive bitmaps. We’re interested in indexing the most recent commits: the tips of all branches <em>need</em> an index, because those are the reachability computations that we will perform with a fresh clone. Besides that, we also add indexes to recent commits; it is likely that their reachability will be computed when people fetch into a clone that is slightly out of date. As we progress deeper into the commit graph, we decrease the frequency at which we pick commits to give indexes to. Towards the end of the graph, we pick one of every 3000 commits.\r\n\r\nLast, but not least, we minimize the amount of disk used by the indexes by compressing the bitmaps. JGit’s implementation originally used Daniel Lemire’s <a href="https://github.com/lemire/EWAHBoolArray">EWAH Bitmaps</a>, so we ported his C++ implementation to C to be backwards compatible <sup><a href="http://githubengineering.com/counting-objects/#footnote-1">[1]</a></sup>. EWAH Bitmaps offer a very reasonable amount of compression while still being extremely fast to decompress and work with. The end result is an index that takes between 5 and 10% of the original size of the repository – significantly less than caching the result of fetches, whilst allowing us to speed up <em>any</em> fetch negotiation, not only those of fresh clones.\r\n<h2 id="the-implementation">The implementation</h2>\r\nOnce we started working on the Git implementation, we found that JGit’s design was so dramatically different from Git’s that it was simply unfeasible to port or translate the patchset. JGit is after all a Java library, while Git is a collection of small binaries written in C.\r\n\r\nWhat we did instead was take the idea of bitmap indexes and re-implement it from scratch, using only the on-disk format of JGit’s bitmap indexes as reference (as to ensure interoperability between the two implementations).\r\n\r\nThe first iteration of the patchset took about 2 months of work, and was drastically different from the original JGit implementation. But it seemed to be compatible. We could open and query bitmap indexes generated by JGit. We did several rounds of synthetic benchmarks, which showed that our implementation was slightly faster than JGit’s (mostly because of performance differences between the languages, not between the different designs).\r\n\r\nSo we started testing cloning real production repositories in a staging environment. The benchmarks showed an exciting improvement of 40%… In the wrong direction. The bitmap-based code was about 40% slower to generate the packfile for a repository.\r\n\r\n<img src="http://githubengineering.com/images/counting-objects/dag-sketch.005.png" alt="Packing objects run in torvalds/linux" />\r\n\r\nThese results raised many questions: how can a clone operation be significantly slower than in vanilla Git, when we’ve already tested that the bitmap indexes are being queried instantly? Did we really spend 3 months writing 5000 lines of C that make clones slower instead of faster? Should we have majored in Math instead of Computer Science?\r\n\r\nOur existential crisis vanished swiftly with some in-depth profiling. If you break down the graph by the amount of time spent during each phase of the cloning operation you can see that, indeed, we’ve managed to reduce an operation that took minutes to mere miliseconds, but unfortunately we’ve made another operation – seemingly unrelated – three times slower.\r\n\r\n<img src="http://githubengineering.com/images/counting-objects/dag-sketch.006.png" alt="Packing objects run in torvalds/linux (breakdown)" />\r\n<h2 id="deltas-all-the-way-down">Deltas all the way down</h2>\r\nThe job of a Version Control System is tracking changes on a set of files over time; hence, it needs to keep a snapshot of every single file in the repository at every changeset: thousands of versions of thousands of different files which, if stored individually, would take up an incredible amount of space on disk.\r\n\r\nBecause of this, all version control systems use smarter techniques to store all these different versions of files. Usually, files are stored as the delta (i.e. difference) between the previous version of a file and its current one. This delta is then compressed to further reduce the amount of size it takes on disk.\r\n\r\nIn Git’s case, every snapshot of a file (which we call a blob) is stored together with all the other objects (the tags, commits and trees that link them together) in what we call a “packfile”.\r\n\r\nWhen trying to minimize the size of a packfile, however, Git mostly disregards history and considers blobs in isolation. To find a delta base for a given blob, Git blindly scans for blobs that look similar to it. Sometimes it will choose the previous version of the same file, but very often it’s a blob from an unrelated part of the history.\r\n\r\nIn general, Git’s aggressive approach of delta-ing blobs against <em>anything</em> is very efficient and will often be able to find smaller deltas. Hence the size of a Git repository on-disk will often be smaller than its Subversion or Mercurial equivalent.\r\n\r\nThis same process is also performed when serving a fetch negotiation. Once Git has the full list of objects it needs to send, it needs to compress them into a single packfile (Git always sends packfiles over the network). If the packfile on disk has a given object X stored as a delta against an object Y, it could very well be the case that object X needs to be sent, but object Y doesn’t. In this case, object X needs to be decompressed and delta’ed against an object that <em>does</em> need to be sent in the resulting packfile.\r\n\r\nThis is a pretty frequent ocurrence when negotiating a small fetch, because we’re sending few objects, all from the tip of the repository, and these objects will usually be delta’ed against older objects that won’t be sent. Therefore, Git tries to find new delta bases for these objects.\r\n\r\nThe issue here is that we were actually serving <em>full clones</em>, and our benchmarks were showing that we were recompressing <em>almost every single object in the clone</em>, which really makes no sense. The point of a clone is sending all the objects in a repository! When we send <em>all</em> objects, we shouldn’t need to find new delta bases for them, because their existing delta bases will be sent too!\r\n\r\nAnd yet the profiling did not lie. There was something fishy going on the compression phase.\r\n<h2 id="your-very-own-fork-of-rails">Your very own fork of Rails</h2>\r\nVery early on we figured out that actually <em>forking</em> people’s repositories was not sustainable. For instance, there are almost 11,000 forks of <a href="https://github.com/rails/rails">Rails</a> hosted on GitHub: if each one of them were its own copy of the repository, that would imply an incredible amount of redundant disk space, requiring several times more fileservers than the ones we have in our infrastructure.\r\n\r\nThat’s why we decided to use a feature of Git called <a href="http://git-scm.com/docs/gitrepository-layout">alternates</a>. When you fork a repository on GitHub, we create a shallow copy of it. This copy has no objects of its own, but it has access to all the objects of an alternate, a root repository we call <code class="highlighter-rouge">network.git</code> and which contains the objects for all the forks in the network. When you push to your repository, eventually we move over the objects you pushed to the <code class="highlighter-rouge">network.git</code> root, so they’re already available in case you decide to create a Pull Request against the original repository.\r\n\r\nWith all the repositories in the network sharing the same pool of objects, we can keep all the objects inside of a single packfile, and hence minimize the on-disk size of the repository network by not storing all the duplicated objects between the forks.\r\n\r\nHere’s the issue though: when we <em>delta</em> two objects inside this packfile (a packfile that is shared between all the forks of a repository), Git uses the straightforward, aggressive heuristic of “finding an object that looks alike”. As stated earlier, this is very effective for minimizing the size of a packfile on disk, but like all simple things in life, this comes back to bite us.\r\n\r\nWhat happens when you delta an object of a fork against an object of another fork? Well, when you clone that fork, that object cannot be sent as a delta, because <em>its base</em> is not going to be sent as part of the clone. The object needs to be blown up (recomposed from its original delta), and then delta’ed on the fly against an object that is actually going to be sent on the clone.\r\n\r\nThis is the reason why the “Compressing Objects” phase of our fetches was recompressing all the objects and taking so long to run: yes, we were sending a whole repository in the clone, but the objects in that repository were delta’ed against objects of a different fork altogether. They <em>did</em> need to be recompressed on the fly. Ouch!\r\n<h2 id="the-missing-optimization">The missing optimization</h2>\r\nWe had a solid explanation of why we were seeing all these objects being recompressed, but something was still off. The “compressing objects” phase is completely independent of the “counting objects” phase, and our bitmap changes didn’t affect it at all.\r\n\r\nThe behavior of this compression phase is dictated by the way we store forks jointly on disk, so it made no sense that it would take twice as long after our patch, again considering these code paths were not touched. Why was object compression suddenly so slow?\r\n\r\nHere’s what happens: when traversing the graph during the “Counting Objects” phase, traditional Git collected metadata about blobs, like their filenames, sizes and paths. During the compression phase, it used this metadata as part of its heuristics for finding good delta bases.\r\n\r\nHowever, after three months of work in our bitmap index changes, we could now find the list of all the objects to send through the bitmap index, without having to actually load a single one of them. This was great for removing the intense CPU requirements of the “counting objects” phase, but it had unintended side effects when it was time to to compress the objects.\r\n\r\nWhen Git noticed that none of the objects on the list could be sent because they were delta’ed against other objects that were <em>not</em> in the list, it was forced to re-delta these objects. But without any metadata to hint at the size or contents of the objects, it had to randomly compare them against each other (obviously by loading them and forfeiting all the benefits that the bitmap index had in the first place) until it was able to find similar objects to delta against and piece together a packfile that wasn’t outrageously large.\r\n\r\nThis is how we were losing all the benefits of our optimization, and in fact making the process of generating a packfile 40% slower than it was before, despite the fact that the most expensive phase of the process was essentially optimized away.\r\n<h2 id="the-performance-fix">The performance fix</h2>\r\nOur dooming performance issue was being caused, again, because we were merging several forks of a repository in the same packfile, but unfortunately, splitting these forks into individual packs was not an option because it would multiply up the storage costs of repositories several times.\r\n\r\nAfter some thought, we agreed that the bitmap index approach was too promising to give up on, despite the fact it could not run properly with our current infrastucture. Therefore, we started looking for a workaround in the way we store the different forks of repositories on disk.\r\n\r\nThe idea of “forks” is foreign to Git’s storage layer: when creating the packfile for a network of forks, Git only sees hundreds of thousands of objects and is not aware of the fact that they actually come from different forks of the same repository.\r\n\r\nHowever, <em>we</em> are aware of the source of the objects as we add them to the packfile for delta’ing, and we can influence the way that Git will delta these packfiles.\r\n\r\nWhat we did was “paint” the graph of all forks, starting from the roots, with a different color for each fork. The “painting” was performed by marking a bit on each object for each fork that contained the object.\r\n\r\n<img src="http://githubengineering.com/images/counting-objects/dag-sketch.004.png" alt="Git repository repack marking" />\r\n\r\nWith this, it’s trivial to propagate the markings to the descendant objects, and change the delta-base heuristic to only consider a parent object as a base if its marking were a strict superset of the markings of the child object (i.e. if sending the child object would always imply sending also the parent, for all forks).\r\n\r\nAs the markings trickle down, the final packfile will only have objects that can be sent as-is, because when cloning any of the forks in the network, every object will only be delta’ed against another object that <em>will also</em> be sent in the clone.\r\n<h2 id="the-results">The results</h2>\r\nWith this new heuristic, we repacked the original repository for our benchmarks (which in our case meant repacking the whole network of forks that contained the repository), and ran the packfile generation test again.\r\n\r\n<img src="http://githubengineering.com/images/counting-objects/dag-sketch.007.png" alt="Packing objects run in torvalds/linux (with perf fix)" />\r\n\r\nThe first thing we verified is that our heuristics worked, and that we had to re-compress exactly 0 objects during the “Compressing Objects” phase. That was the case. As for the performance of the pack generation phase… Well, let’s just say we hit our performance target.\r\n\r\nIt took another couple months to work around the kinks in our implementation, but we eventually deployed the patchset to production, where the average CPU time spent on Git network operations was reduced by more than 90% – an order of magnitude faster than the old implementation.\r\n\r\nShortly after our initial deploy, we also started the process of upstreaming the changes to Git so the whole community could benefit from them. The bitmap-index patchset <sup><a href="http://githubengineering.com/counting-objects/#footnote-2">[2]</a></sup> finally shipped in the much anticipated <a href="https://git.kernel.org/cgit/git/git.git/tree/Documentation/RelNotes/2.0.0.txt">Git 2.0 release</a>, and now Git network operations from most major Git hosts are enjoying the overhaul.\r\n\r\nSince the initial deployment of our patchset more than a year ago, it has already saved our users roughly a <em>century</em> of waiting for their fetches to complete (and the equivalent amount of CPU time in our fileservers).\r\n\r\nBut this is only the beginning: now that bitmap indexes are widely available, they can be used to accelerate many other Git operations. We’ve implemented a number of such improvements which we already run on production, and we are preparing them for submission to the open source Git project.\r\n\r\nThe story behind these second generation optimizations, however, will have to wait until another day and another blog <em>post.</em>\r\n\r\n<hr />\r\n\r\n<div>\r\n\r\n<a name="footnote-1"></a>1. Daniel Lemire was extremely helpful assisting us with questions regarding his EWAH compression algorithm, and allowed us to relicense our C port under the GPLv2 to make it compatible with Git. His state-of-the-art<a href="https://github.com/lemire">research on bitmap and array compression</a> is used in a lot of open-source and commercial software.\r\n\r\n<a name="footnote-2"></a>2. The final series that made it upstream was composed of 14 commits. They include thorough documentation of the whole implementation in their commit messages. The key parts of the design are explained in<a href="https://github.com/gitster/git/commit/e127310"><code>compressed bitmap implementation</code></a>, <a href="https://github.com/gitster/git/commit/0d4455a"><code>add documentation for the bitmap format</code></a>, <a href="https://github.com/gitster/git/commit/fff4275"><code>add support for bitmap indexes</code></a>, <a href="https://github.com/gitster/git/commit/6b8fda2"><code>use bitmaps when packing objects</code></a> and <a href="https://github.com/gitster/git/commit/7cc8f97"><code>implement bitmap writing</code></a>.\r\n\r\n</div>\r\n</div>','Git Counting Objects','','publish','open','open','','git-counting-objects','','','2016-11-01 17:37:58','2016-11-01 09:37:58','',0,'https://blog-scottwang.rhcloud.com/?p=75',0,'post','',0),
 (79,1,'2016-11-01 17:59:20','2016-11-01 09:59:20','from:\r\n<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n我每天使用 Git ，但是很多命令记不住。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\r\n\r\n<img style="width: 800px;" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" />\r\n\r\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\r\n<blockquote>\r\n<ul>\r\n 	<li>Workspace：工作区</li>\r\n 	<li>Index / Stage：暂存区</li>\r\n 	<li>Repository：仓库区（或本地仓库）</li>\r\n 	<li>Remote：远程仓库</li>\r\n</ul>\r\n</blockquote>\r\n<h2>一、新建代码库</h2>\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 在当前目录新建一个Git代码库\r\n</span>$ git init\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个目录，将其初始化为Git代码库\r\n</span>$ git init <span class="token punctuation">[</span>project<span class="token operator">-</span>name<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 下载一个项目和它的整个代码历史\r\n</span>$ git clone <span class="token punctuation">[</span>url<span class="token punctuation">]</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>二、配置</h2>\r\nGit的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 显示当前的Git配置\r\n</span>$ git config <span class="token operator">--</span>list\r\n\r\n<span class="token comment" spellcheck="true"># 编辑Git配置文件\r\n</span>$ git config <span class="token operator">-</span>e <span class="token punctuation">[</span><span class="token operator">--</span>global<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 设置提交代码时的用户信息\r\n</span>$ git config <span class="token punctuation">[</span><span class="token operator">--</span>global<span class="token punctuation">]</span> user<span class="token punctuation">.</span>name <span class="token string">"[name]"</span>\r\n$ git config <span class="token punctuation">[</span><span class="token operator">--</span>global<span class="token punctuation">]</span> user<span class="token punctuation">.</span>email <span class="token string">"[email address]"</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>三、增加/删除文件</h2>\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 添加指定文件到暂存区\r\n</span>$ git add <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\r\n\r\n<span class="token comment" spellcheck="true"># 添加指定目录到暂存区，包括子目录\r\n</span>$ git add <span class="token punctuation">[</span>dir<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 添加当前目录的所有文件到暂存区\r\n</span>$ git add <span class="token punctuation">.</span>\r\n\r\n<span class="token comment" spellcheck="true"># 添加每个变化前，都会要求确认\r\n</span><span class="token comment" spellcheck="true"># 对于同一个文件的多处变化，可以实现分次提交\r\n</span>$ git add <span class="token operator">-</span>p\r\n\r\n<span class="token comment" spellcheck="true"># 删除工作区文件，并且将这次删除放入暂存区\r\n</span>$ git rm <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\r\n\r\n<span class="token comment" spellcheck="true"># 停止追踪指定文件，但该文件会保留在工作区\r\n</span>$ git rm <span class="token operator">--</span>cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 改名文件，并且将这个改名放入暂存区\r\n</span>$ git mv <span class="token punctuation">[</span>file<span class="token operator">-</span>original<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token operator">-</span>renamed<span class="token punctuation">]</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>四、代码提交</h2>\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 提交暂存区到仓库区\r\n</span>$ git commit <span class="token operator">-</span>m <span class="token punctuation">[</span>message<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 提交暂存区的指定文件到仓库区\r\n</span>$ git commit <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">-</span>m <span class="token punctuation">[</span>message<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 提交工作区自上次commit之后的变化，直接到仓库区\r\n</span>$ git commit <span class="token operator">-</span>a\r\n\r\n<span class="token comment" spellcheck="true"># 提交时显示所有diff信息\r\n</span>$ git commit <span class="token operator">-</span>v\r\n\r\n<span class="token comment" spellcheck="true"># 使用一次新的commit，替代上一次提交\r\n</span><span class="token comment" spellcheck="true"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息\r\n</span>$ git commit <span class="token operator">--</span>amend <span class="token operator">-</span>m <span class="token punctuation">[</span>message<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 重做上一次commit，并包括指定文件的新变化\r\n</span>$ git commit <span class="token operator">--</span>amend <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>五、分支</h2>\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 列出所有本地分支\r\n</span>$ git branch\r\n\r\n<span class="token comment" spellcheck="true"># 列出所有远程分支\r\n</span>$ git branch <span class="token operator">-</span>r\r\n\r\n<span class="token comment" spellcheck="true"># 列出所有本地分支和远程分支\r\n</span>$ git branch <span class="token operator">-</span>a\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个分支，但依然停留在当前分支\r\n</span>$ git branch <span class="token punctuation">[</span>branch<span class="token operator">-</span>name<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个分支，并切换到该分支\r\n</span>$ git checkout <span class="token operator">-</span>b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个分支，指向指定commit\r\n</span>$ git branch <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个分支，与指定的远程分支建立追踪关系\r\n</span>$ git branch <span class="token operator">--</span>track <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote<span class="token operator">-</span>branch<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 切换到指定分支，并更新工作区\r\n</span>$ git checkout <span class="token punctuation">[</span>branch<span class="token operator">-</span>name<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 切换到上一个分支\r\n</span>$ git checkout <span class="token operator">-</span>\r\n\r\n<span class="token comment" spellcheck="true"># 建立追踪关系，在现有分支与指定的远程分支之间\r\n</span>$ git branch <span class="token operator">--</span><span class="token keyword">set</span><span class="token operator">-</span>upstream <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote<span class="token operator">-</span>branch<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 合并指定分支到当前分支\r\n</span>$ git merge <span class="token punctuation">[</span>branch<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 选择一个commit，合并进当前分支\r\n</span>$ git cherry<span class="token operator">-</span>pick <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 删除分支\r\n</span>$ git branch <span class="token operator">-</span>d <span class="token punctuation">[</span>branch<span class="token operator">-</span>name<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 删除远程分支\r\n</span>$ git push origin <span class="token operator">--</span>delete <span class="token punctuation">[</span>branch<span class="token operator">-</span>name<span class="token punctuation">]</span>\r\n$ git branch <span class="token operator">-</span>dr <span class="token punctuation">[</span>remote<span class="token operator">/</span>branch<span class="token punctuation">]</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>六、标签</h2>\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 列出所有tag\r\n</span>$ git tag\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个tag在当前commit\r\n</span>$ git tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个tag在指定commit\r\n</span>$ git tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 删除本地tag\r\n</span>$ git tag <span class="token operator">-</span>d <span class="token punctuation">[</span>tag<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 删除远程tag\r\n</span>$ git push origin <span class="token punctuation">:</span>refs<span class="token operator">/</span>tags<span class="token operator">/</span><span class="token punctuation">[</span>tagName<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 查看tag信息\r\n</span>$ git show <span class="token punctuation">[</span>tag<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 提交指定tag\r\n</span>$ git push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 提交所有tag\r\n</span>$ git push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token operator">--</span>tags\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个分支，指向某个tag\r\n</span>$ git checkout <span class="token operator">-</span>b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>七、查看信息</h2>\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 显示有变更的文件\r\n</span>$ git status\r\n\r\n<span class="token comment" spellcheck="true"># 显示当前分支的版本历史\r\n</span>$ git log\r\n\r\n<span class="token comment" spellcheck="true"># 显示commit历史，以及每次commit发生变更的文件\r\n</span>$ git log <span class="token operator">--</span>stat\r\n\r\n<span class="token comment" spellcheck="true"># 搜索提交历史，根据关键词\r\n</span>$ git log <span class="token operator">-</span>S <span class="token punctuation">[</span>keyword<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，每个commit占据一行\r\n</span>$ git log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD <span class="token operator">--</span>pretty<span class="token operator">=</span>format<span class="token punctuation">:</span><span class="token operator">%</span>s\r\n\r\n<span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\r\n</span>$ git log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD <span class="token operator">--</span>grep feature\r\n\r\n<span class="token comment" spellcheck="true"># 显示某个文件的版本历史，包括文件改名\r\n</span>$ git log <span class="token operator">--</span>follow <span class="token punctuation">[</span>file<span class="token punctuation">]</span>\r\n$ git whatchanged <span class="token punctuation">[</span>file<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示指定文件相关的每一次diff\r\n</span>$ git log <span class="token operator">-</span>p <span class="token punctuation">[</span>file<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示过去5次提交\r\n</span>$ git log <span class="token operator">-</span><span class="token number">5</span> <span class="token operator">--</span>pretty <span class="token operator">--</span>oneline\r\n\r\n<span class="token comment" spellcheck="true"># 显示所有提交过的用户，按提交次数排序\r\n</span>$ git shortlog <span class="token operator">-</span>sn\r\n\r\n<span class="token comment" spellcheck="true"># 显示指定文件是什么人在什么时间修改过\r\n</span>$ git blame <span class="token punctuation">[</span>file<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示暂存区和工作区的差异\r\n</span>$ git diff\r\n\r\n<span class="token comment" spellcheck="true"># 显示暂存区和上一个commit的差异\r\n</span>$ git diff <span class="token operator">--</span>cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示工作区与当前分支最新commit之间的差异\r\n</span>$ git diff HEAD\r\n\r\n<span class="token comment" spellcheck="true"># 显示两次提交之间的差异\r\n</span>$ git diff <span class="token punctuation">[</span>first<span class="token operator">-</span>branch<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span>second<span class="token operator">-</span>branch<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示今天你写了多少行代码\r\n</span>$ git diff <span class="token operator">--</span>shortstat <span class="token string">"@{0 day ago}"</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示某次提交的元数据和内容变化\r\n</span>$ git show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示某次提交发生变化的文件\r\n</span>$ git show <span class="token operator">--</span>name<span class="token operator">-</span>only <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示某次提交时，某个文件的内容\r\n</span>$ git show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">[</span>filename<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示当前分支的最近几次提交\r\n</span>$ git reflog\r\n</code></pre>\r\n</blockquote>\r\n<h2>八、远程同步</h2>\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 下载远程仓库的所有变动\r\n</span>$ git fetch <span class="token punctuation">[</span>remote<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 显示所有远程仓库\r\n</span>$ git remote <span class="token operator">-</span>v\r\n\r\n<span class="token comment" spellcheck="true"># 显示某个远程仓库的信息\r\n</span>$ git remote show <span class="token punctuation">[</span>remote<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 增加一个新的远程仓库，并命名\r\n</span>$ git remote add <span class="token punctuation">[</span>shortname<span class="token punctuation">]</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 取回远程仓库的变化，并与本地分支合并\r\n</span>$ git pull <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 上传本地指定分支到远程仓库\r\n</span>$ git push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 强行推送当前分支到远程仓库，即使有冲突\r\n</span>$ git push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token operator">--</span>force\r\n\r\n<span class="token comment" spellcheck="true"># 推送所有分支到远程仓库\r\n</span>$ git push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token operator">--</span>all\r\n</code></pre>\r\n</blockquote>\r\n<h2>九、撤销</h2>\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 恢复暂存区的指定文件到工作区\r\n</span>$ git checkout <span class="token punctuation">[</span>file<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 恢复某个commit的指定文件到暂存区和工作区\r\n</span>$ git checkout <span class="token punctuation">[</span>commit<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 恢复暂存区的所有文件到工作区\r\n</span>$ git checkout <span class="token punctuation">.</span>\r\n\r\n<span class="token comment" spellcheck="true"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\r\n</span>$ git reset <span class="token punctuation">[</span>file<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 重置暂存区与工作区，与上一次commit保持一致\r\n</span>$ git reset <span class="token operator">--</span>hard\r\n\r\n<span class="token comment" spellcheck="true"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\r\n</span>$ git reset <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\r\n</span>$ git reset <span class="token operator">--</span>hard <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变\r\n</span>$ git reset <span class="token operator">--</span>keep <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 新建一个commit，用来撤销指定commit\r\n</span><span class="token comment" spellcheck="true"># 后者的所有变化都将被前者抵消，并且应用到当前分支\r\n</span>$ git revert <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>\r\n\r\n<span class="token comment" spellcheck="true"># 暂时将未提交的变化移除，稍后再移入\r\n</span>$ git stash\r\n$ git stash pop\r\n</code></pre>\r\n</blockquote>\r\n<h2>十、其他</h2>\r\n<blockquote>\r\n<pre class=" language-bash"><code class=" language-bash">\r\n<span class="token comment" spellcheck="true"># 生成一个可供发布的压缩包\r\n</span>$ git archive\r\n</code></pre>\r\n</blockquote>\r\n（完）\r\n\r\n</div>\r\n</article>','常用Git命令清单','','publish','open','open','','git-cmd','','','2016-11-01 17:59:20','2016-11-01 09:59:20','',0,'https://blog-scottwang.rhcloud.com/?p=79',0,'post','',0),
 (81,1,'2016-11-01 18:01:49','2016-11-01 10:01:49','from:\r\n<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">http://www.ruanyifeng.com/blog/2015/12/git-workflow.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\nGit 作为一个源码管理系统，不可避免涉及到多人协作。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。"工作流程"在英语里，叫做"workflow"或者"flow"，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015122301.png" alt="" />\r\n\r\n本文介绍三种广泛使用的工作流程：\r\n<blockquote>\r\n<ul>\r\n 	<li>Git flow</li>\r\n 	<li>Github flow</li>\r\n 	<li>Gitlab flow</li>\r\n</ul>\r\n</blockquote>\r\n如果你对Git还不是很熟悉，可以先阅读下面的文章。\r\n<blockquote>\r\n<ul>\r\n 	<li><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank">《Git 使用规范流程》</a></li>\r\n 	<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank">《常用 Git 命令清单》</a></li>\r\n 	<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank">《Git 远程操作详解》</a></li>\r\n</ul>\r\n</blockquote>\r\n<h2>一、功能驱动</h2>\r\n本文的三种工作流程，有一个共同点：都采用<a href="https://en.wikipedia.org/wiki/Feature-driven_development" target="_blank">"功能驱动式开发"</a>（Feature-driven development，简称FDD）。\r\n\r\n它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。\r\n<h2>二、Git flow</h2>\r\n最早诞生、并得到广泛采用的一种工作流程，就是<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank">Git flow</a> 。\r\n<h3>2.1 特点</h3>\r\n它最主要的特点有两个。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015122302.png" alt="" />\r\n\r\n首先，项目存在两个长期分支。\r\n<blockquote>\r\n<ul>\r\n 	<li>主分支<code>master</code></li>\r\n 	<li>开发分支<code>develop</code></li>\r\n</ul>\r\n</blockquote>\r\n前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放最新的开发版。\r\n\r\n其次，项目存在三种短期分支。\r\n<blockquote>\r\n<ul>\r\n 	<li>功能分支（feature branch）</li>\r\n 	<li>补丁分支（hotfix branch）</li>\r\n 	<li>预发分支（release branch）</li>\r\n</ul>\r\n</blockquote>\r\n一旦完成开发，它们就会被合并进<code>develop</code>或<code>master</code>，然后被删除。\r\n\r\nGit flow 的详细介绍，请阅读我翻译的中文版<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank">《Git 分支管理策略》</a>。\r\n<h3>2.2 评价</h3>\r\nGit flow的优点是清晰可控，缺点是相对复杂，需要同时维护两个长期分支。大多数工具都将<code>master</code>当作默认分支，可是开发是在<code>develop</code>分支进行的，这导致经常要切换分支，非常烦人。\r\n\r\n更大问题在于，这个模式是基于"版本发布"的，目标是一段时间以后产出一个新版本。但是，很多网站项目是"持续发布"，代码一有变动，就部署一次。这时，<code>master</code>分支和<code>develop</code>分支的差别不大，没必要维护两个长期分支。\r\n<h2>三、Github flow</h2>\r\n<a href="http://scottchacon.com/2011/08/31/github-flow.html" target="_blank">Github flow</a> 是Git flow的简化版，专门配合"持续发布"。它是 Github.com 使用的工作流程。\r\n<h3>3.1 流程</h3>\r\n它只有一个长期分支，就是<code>master</code>，因此用起来非常简单。\r\n\r\n官方推荐的<a href="https://guides.github.com/introduction/flow/index.html" target="_blank">流程</a>如下。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015122305.png" alt="" />\r\n<blockquote>第一步：根据需求，从<code>master</code>拉出新分支，不区分功能分支或补丁分支。\r\n\r\n第二步：新分支开发完成后，或者需要讨论的时候，就向<code>master</code>发起一个<a href="https://help.github.com/articles/using-pull-requests/" target="_blank">pull request</a>（简称PR）。\r\n\r\n第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。\r\n\r\n第四步：你的Pull Request被接受，合并进<code>master</code>，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</blockquote>\r\n<h3>3.2 评价</h3>\r\nGithub flow 的最大优点就是简单，对于"持续发布"的产品，可以说是最合适的流程。\r\n\r\n问题在于它的假设：<code>master</code>分支的更新与产品的发布是一致的。也就是说，<code>master</code>分支的最新代码，默认就是当前的线上代码。\r\n\r\n可是，有些时候并非如此，代码合并进入<code>master</code>分支，并不代表它就能立刻发布。比如，苹果商店的APP提交审核以后，等一段时间才能上架。这时，如果还有新的代码提交，<code>master</code>分支就会与刚发布的版本不一致。另一个例子是，有些公司有发布窗口，只有指定时间才能发布，这也会导致线上版本落后于<code>master</code>分支。\r\n\r\n上面这种情况，只有<code>master</code>一个主分支就不够用了。通常，你不得不在<code>master</code>分支以外，另外新建一个<code>production</code>分支跟踪线上版本。\r\n<h2>四、Gitlab flow</h2>\r\n<a href="http://doc.gitlab.com/ee/workflow/gitlab_flow.html" target="_blank">Gitlab flow</a> 是 Git flow 与 Github flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。\r\n<h3>4.1 上游优先</h3>\r\nGitlab flow 的最大原则叫做"上游优先"（upsteam first），即只存在一个主分支<code>master</code>，它是所有其他分支的"上游"。只有上游分支采纳的代码变化，才能应用到其他分支。\r\n\r\n<a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/upstream-first" target="_blank">Chromium项目</a>就是一个例子，它明确规定，上游分支依次为：\r\n<blockquote>\r\n<ol start="1">\r\n 	<li>Linus Torvalds的分支</li>\r\n 	<li>子系统（比如netdev）的分支</li>\r\n 	<li>设备厂商（比如三星）的分支</li>\r\n</ol>\r\n</blockquote>\r\n<h3>4.2 持续发布</h3>\r\nGitlab flow 分成两种情况，适应不同的开发流程。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015122306.png" alt="" />\r\n\r\n对于"持续发布"的项目，它建议在<code>master</code>分支以外，再建立不同的环境分支。比如，"开发环境"的分支是<code>master</code>，"预发环境"的分支是<code>pre-production</code>，"生产环境"的分支是<code>production</code>。\r\n\r\n开发分支是预发分支的"上游"，预发分支又是生产分支的"上游"。代码的变化，必须由"上游"向"下游"发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到<code>master</code>，确认没有问题，再<code>cherry-pick</code>到<code>pre-production</code>，这一步也没有问题，才进入<code>production</code>。\r\n\r\n只有紧急情况，才允许跳过上游，直接合并到下游分支。\r\n<h3>4.3 版本发布</h3>\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015122307.png" alt="" />\r\n\r\n对于"版本发布"的项目，建议的做法是每一个稳定版本，都要从<code>master</code>分支拉出一个分支，比如<code>2-3-stable</code>、<code>2-4-stable</code>等等。\r\n\r\n以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。\r\n<h2>五、一些小技巧</h2>\r\n<h3>5.1 Pull Request</h3>\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015122310.png" alt="" />\r\n\r\n功能分支合并进<code>master</code>分支，必须通过Pull Request（Gitlab里面叫做 Merge Request）。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015122308.png" alt="" />\r\n\r\n前面说过，Pull Request本质是一种对话机制，你可以在提交的时候，<code>@</code>相关<a href="https://github.com/blog/1004-mention-autocompletion" target="_blank">人员</a>或<a href="https://github.com/blog/1121-introducing-team-mentions" target="_blank">团队</a>，引起他们的注意。\r\n<h3>5.2 Protected branch</h3>\r\n<code>master</code>分支应该受到保护，不是每个人都可以修改这个分支，以及拥有审批 Pull Request 的权力。\r\n\r\n<a href="https://help.github.com/articles/about-protected-branches/" target="_blank">Github</a> 和 <a href="http://doc.gitlab.com/ce/permissions/permissions.html" target="_blank">Gitlab</a> 都提供"保护分支"（Protected branch）这个功能。\r\n<h3>5.3 Issue</h3>\r\nIssue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。\r\n\r\n功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如"15-require-a-password-to-change-it"。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015122311.png" alt="" />\r\n\r\n开发完成后，在提交说明里面，可以写上"fixes #14"或者"closes #67"。Github规定，只要commit message里面有下面这些<a href="https://help.github.com/articles/closing-issues-via-commit-messages/" target="_blank">动词</a> + 编号，就会关闭对应的issue。\r\n<blockquote>\r\n<ul>\r\n 	<li>close</li>\r\n 	<li>closes</li>\r\n 	<li>closed</li>\r\n 	<li>fix</li>\r\n 	<li>fixes</li>\r\n 	<li>fixed</li>\r\n 	<li>resolve</li>\r\n 	<li>resolves</li>\r\n 	<li>resolved</li>\r\n</ul>\r\n</blockquote>\r\n这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是<code>username/repository#issue_number</code>。\r\n\r\nPull Request被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。\r\n<h3>5.4 Merge节点</h3>\r\nGit有两种合并：一种是"直进式合并"（fast forward），不生成单独的合并节点；另一种是"非直进式合并"（none fast-forword），会生成单独节点。\r\n\r\n前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用<code>--no-ff</code>参数）。只要发生合并，就要有一个单独的合并节点。\r\n<h3>5.5 Squash 多个commit</h3>\r\n为了便于他人阅读你的提交，也便于<code>cherry-pick</code>或撤销代码变化，在发起Pull Request之前，应该把多个commit合并成一个。（前提是，该分支只有你一个人开发，且没有跟<code>master</code>合并过。）\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015122309.png" alt="" />\r\n\r\n这可以采用<code>rebase</code>命令附带的<code>squash</code>操作，具体方法请参考我写的<a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank">《Git 使用规范流程》</a>。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','Git工作流程','','publish','open','open','','git-workflow','','','2016-11-01 18:01:49','2016-11-01 10:01:49','',0,'https://blog-scottwang.rhcloud.com/?p=81',0,'post','',0),
 (83,1,'2016-11-01 18:04:19','2016-11-01 10:04:19','from:\r\n<a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">http://www.ruanyifeng.com/blog/2014/06/git_remote.html</a>\r\n<div id="entry-1807" class="entry-asset asset hentry"><article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n<a href="http://zh.wikipedia.org/wiki/Git" target="_blank">Git</a>是目前最流行的<a href="http://www.ruanyifeng.com/blog/2008/12/a_visual_guide_to_version_control.html" target="_blank">版本管理系统</a>，学会Git几乎成了开发者的必备技能。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\nGit有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。\r\n<ul>\r\n 	<li>git clone</li>\r\n 	<li>git remote</li>\r\n 	<li>git fetch</li>\r\n 	<li>git pull</li>\r\n 	<li>git push</li>\r\n</ul>\r\n本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014061202.jpg" alt="git" />\r\n<h2>一、git clone</h2>\r\n远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git clone <span class="token operator">&lt;</span>版本库的网址<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n比如，克隆jQuery的版本库。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git clone https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>jquery<span class="token operator">/</span>jquery<span class="token punctuation">.</span>git\r\n</code></pre>\r\n</blockquote>\r\n该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为<code>git clone</code>命令的第二个参数。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git clone <span class="token operator">&lt;</span>版本库的网址<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>本地目录名<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n<code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git clone http<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com<span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token regex">/repo.git/</span>\r\n$ git clone ssh<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com<span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token regex">/repo.git/</span>\r\n$ git clone git<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com<span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token regex">/repo.git/</span>\r\n$ git clone <span class="token operator">/</span>opt<span class="token operator">/</span>git<span class="token operator">/</span>project<span class="token punctuation">.</span>git \r\n$ git clone file<span class="token punctuation">:</span><span class="token comment" spellcheck="true">///opt/git/project.git\r\n</span>$ git clone ftp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com<span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token regex">/repo.git/</span>\r\n$ git clone rsync<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com<span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token regex">/repo.git/</span>\r\n</code></pre>\r\n</blockquote>\r\nSSH协议还有另一种写法。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git clone <span class="token punctuation">[</span>user@<span class="token punctuation">]</span>example<span class="token punctuation">.</span>com<span class="token punctuation">:</span>path<span class="token operator">/</span>to<span class="token regex">/repo.git/</span>\r\n</code></pre>\r\n</blockquote>\r\n通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考<a href="http://git-scm.com/book/en/Git-on-the-Server-The-Protocols" target="_blank">官方文档</a>。\r\n<h2>二、git remote</h2>\r\n为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。\r\n\r\n不带选项的时候，<code>git remote</code>命令列出所有远程主机。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git remote\r\norigin\r\n</code></pre>\r\n</blockquote>\r\n使用<code>-v</code>选项，可以参看远程主机的网址。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git remote <span class="token operator">-</span>v\r\norigin  <a class="token email-link" href="mailto:git@github">git@github</a><span class="token punctuation">.</span>com<span class="token punctuation">:</span>jquery<span class="token operator">/</span>jquery<span class="token punctuation">.</span>git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>\r\norigin  <a class="token email-link" href="mailto:git@github">git@github</a><span class="token punctuation">.</span>com<span class="token punctuation">:</span>jquery<span class="token operator">/</span>jquery<span class="token punctuation">.</span>git <span class="token punctuation">(</span>push<span class="token punctuation">)</span>\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。\r\n\r\n克隆版本库的时候，所使用的远程主机自动被Git命名为<code>origin</code>。如果想用其他的主机名，需要用<code>git clone</code>命令的<code>-o</code>选项指定。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git clone <span class="token operator">-</span>o jQuery https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>jquery<span class="token operator">/</span>jquery<span class="token punctuation">.</span>git\r\n$ git remote\r\njQuery\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，克隆的时候，指定远程主机叫做jQuery。\r\n\r\n<code>git remote show</code>命令加上主机名，可以查看该主机的详细信息。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git remote show <span class="token operator">&lt;</span>主机名<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n<code>git remote add</code>命令用于添加远程主机。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git remote add <span class="token operator">&lt;</span>主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>网址<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n<code>git remote rm</code>命令用于删除远程主机。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git remote rm <span class="token operator">&lt;</span>主机名<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n<code>git remote rename</code>命令用于远程主机的改名。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git remote rename <span class="token operator">&lt;</span>原主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>新主机名<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>三、git fetch</h2>\r\n一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n上面命令将某个远程主机的更新，全部取回本地。\r\n\r\n<code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。\r\n\r\n默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>分支名<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n比如，取回<code>origin</code>主机的<code>master</code>分支。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git fetch origin master\r\n</code></pre>\r\n</blockquote>\r\n所取回的更新，在本地主机上要用"远程主机名/分支名"的形式读取。比如<code>origin</code>主机的<code>master</code>，就要用<code>origin/master</code>读取。\r\n\r\n<code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git branch <span class="token operator">-</span>r\r\norigin<span class="token operator">/</span>master\r\n\r\n$ git branch <span class="token operator">-</span>a\r\n<span class="token operator">*</span> master\r\n  remotes<span class="token operator">/</span>origin<span class="token operator">/</span>master\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。\r\n\r\n取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git checkout <span class="token operator">-</span>b newBrach origin<span class="token operator">/</span>master\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，在<code>origin/master</code>的基础上，创建一个新分支。\r\n\r\n此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git merge origin<span class="token operator">/</span>master\r\n# 或者\r\n$ git rebase origin<span class="token operator">/</span>master\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示在当前分支上，合并<code>origin/master</code>。\r\n<h2>四、git pull</h2>\r\n<code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git pull <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git pull origin next<span class="token punctuation">:</span>master\r\n</code></pre>\r\n</blockquote>\r\n如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git pull origin next\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再做<code>git merge</code>。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git fetch origin\r\n$ git merge origin<span class="token operator">/</span>next\r\n</code></pre>\r\n</blockquote>\r\n在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动"追踪"<code>origin/master</code>分支。\r\n\r\nGit也允许手动建立追踪关系。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\ngit branch <span class="token operator">--</span>set<span class="token operator">-</span>upstream master origin<span class="token operator">/</span>next\r\n</code></pre>\r\n</blockquote>\r\n上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。\r\n\r\n如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git pull origin\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机"追踪分支"（remote-tracking branch）进行合并。\r\n\r\n如果当前分支只有一个追踪分支，连远程主机名都可以省略。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git pull\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，当前分支自动与唯一一个追踪分支进行合并。\r\n\r\n如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git pull <span class="token operator">--</span>rebase <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。\r\n\r\n但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git pull <span class="token operator">-</span>p\r\n# 等同于下面的命令\r\n$ git fetch <span class="token operator">--</span>prune origin \r\n$ git fetch <span class="token operator">-</span>p\r\n</code></pre>\r\n</blockquote>\r\n<h2>五、git push</h2>\r\n<code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git push <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>远程分支名<span class="token operator">&gt;</span>\r\n</code></pre>\r\n</blockquote>\r\n注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。\r\n\r\n如果省略远程分支名，则表示将本地分支推送与之存在"追踪关系"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git push origin master\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。\r\n\r\n如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git push origin <span class="token punctuation">:</span>master\r\n# 等同于\r\n$ git push origin <span class="token operator">--</span>delete master\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示删除<code>origin</code>主机的<code>master</code>分支。\r\n\r\n如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git push origin\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，将当前分支推送到<code>origin</code>主机的对应分支。\r\n\r\n如果当前分支只有一个追踪分支，那么主机名都可以省略。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git push\r\n</code></pre>\r\n</blockquote>\r\n如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git push <span class="token operator">-</span>u origin master\r\n</code></pre>\r\n</blockquote>\r\n上面命令将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定<code>origin</code>为默认主机，后面就可以不加任何参数使用<code>git push</code>了。\r\n\r\n不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用<code>git config</code>命令。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git config <span class="token operator">--</span>global push<span class="token punctuation">.</span>default matching\r\n# 或者\r\n$ git config <span class="token operator">--</span>global push<span class="token punctuation">.</span>default simple\r\n</code></pre>\r\n</blockquote>\r\n还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<code>--all</code>选项。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git push <span class="token operator">--</span>all origin\r\n</code></pre>\r\n</blockquote>\r\n上面命令表示，将所有本地分支都推送到<code>origin</code>主机。\r\n\r\n如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>--force</code>选项。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git push <span class="token operator">--</span>force origin \r\n</code></pre>\r\n</blockquote>\r\n上面命令使用<code>--force</code>选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用<code>--force</code>选项。\r\n\r\n最后，<code>git push</code>不会推送标签（tag），除非使用<code>--tags</code>选项。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n$ git push origin <span class="token operator">--</span>tags\r\n</code></pre>\r\n</blockquote>\r\n（完）\r\n\r\n</div>\r\n</article></div>','Git远程操作详解','','publish','open','open','','git-remote-operation','','','2016-11-01 18:04:19','2016-11-01 10:04:19','',0,'https://blog-scottwang.rhcloud.com/?p=83',0,'post','',0),
 (85,1,'2016-11-01 18:06:26','2016-11-01 10:06:26','from:\r\n<a href="http://www.ruanyifeng.com/blog/2008/12/a_visual_guide_to_version_control.html">http://www.ruanyifeng.com/blog/2008/12/a_visual_guide_to_version_control.html</a>\r\n<div id="entry-1173" class="entry-asset asset hentry"><article class="hentry">\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n我知道版本控制系统（VCS）很有用。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n但是，我平时只是业余写一些小程序，感觉特地装一个VCS太麻烦，所以一直没有用。最近，因为想认真做一个中等规模的项目，所以决心好好学一下怎么用。\r\n\r\n下面就是我翻译的一篇入门教程，主要解释了VCS的一些主要概念。\r\n\r\n======================\r\n\r\n<strong>A Visual Guide to Version Control</strong>\r\n\r\n<strong>版本控制入门插图教程</strong>\r\n\r\n作者：Kalid Azad\r\n\r\n译者：阮一峰\r\n\r\n原文网址：<a href="http://betterexplained.com/articles/a-visual-guide-to-version-control/" target="_blank">http://betterexplained.com/articles/a-visual-guide-to-version-control/</a>\r\n\r\n<img src="http://lh4.ggpht.com/_6p3hNkUNWrQ/SVoLDpsr1iI/AAAAAAAAAfI/e37QkOlWGyQ/s800/version_control_intro_small.png" />\r\n\r\n版本控制（Version Control）的作用是追踪文件的变化。为什么需要版本控制？简单说，就是当你出错了，可以很容易地回到没出错时的状态。\r\n\r\n你可能已经在不知不觉中，布置了自己的版本控制系统。比如，创建了类似下面这样的文件名：\r\n<blockquote>\r\n<div>\r\n\r\n* KalidAzadResumeOct2006.doc\r\n\r\n* KalidAzadResumeMar2007.doc\r\n\r\n* instacalc-logo3.png\r\n\r\n* instacalc-logo4.png\r\n\r\n* logo-old.png\r\n\r\n</div></blockquote>\r\n这就是软件中为什么有"Save As"命令的原因。它使得你可以在不破坏源文件的基础上，得到一个类似的新文件。文件的多版本保存是一个常见问题，通常的解决办法是这样的：\r\n<blockquote>\r\n<div>\r\n\r\n* 做一个文件备份（比如Document.old.txt）。\r\n\r\n* 在文件名中加入版本号或日期（比如Document_V1.txt，DocumentMarch2007.txt）。\r\n\r\n* 在多人编辑的环境下，共享一个文件目录，并且要求每个人编辑完以后，在文件上做出标识。\r\n\r\n</div></blockquote>\r\n<strong>什么是版本控制系统（VCS）？</strong>\r\n\r\n通过文件名识别版本，对于小型项目或者单个文件也许可行。但是对于软件开发来说，是不适用的。\r\n\r\n你能想像吗，要是Windows操作系统的源文件，是在一个叫做"Windows2007-Latest-UPDATED!!"的共享目录中开发的，并且每个程序员都可以编辑，都有一个自己的子目录，那会发生什么情况？那么，Windows就根本不可能被制造出来。\r\n\r\n大型的、频繁修改的、多人编写的软件项目，需要一个版本控制系统（简称VCS，行话叫做"文件数据库"），追踪文件的变化，避免出现混乱。一个好的VCS应该做到以下几点：\r\n<blockquote>\r\n<div>\r\n\r\n* 备份（Backup）和恢复（Restore）。文件的每一次编辑都得到保存，可以恢复到任意一个日期。需要2007年2月23日的版本？没问题。\r\n\r\n* 同步（Synchronization）。让不同用户随时都能得到文件的最新版本。\r\n\r\n* 短期撤销（Short-term undo）。文件被你搞乱了，怎么办？那就撤销编辑，回到最近一次的无差错版本。\r\n\r\n* 长期撤销（Long-term undo）。有时候，你会过了很久才发现出错了。如果你想撤销一年前的一次编辑，怎么办？那就去取回一年之前的那个版本。\r\n\r\n* 追踪修改（Track Changes）。文件的每一次编辑，你都可以写下注解，解释编辑的原因。（这些信息储存在VCS中，而不是文件中。）这样就很容易看出，长期中文件变化的脉络和原因。\r\n\r\n* 追踪权限（Track Ownership）。VCS会记录每一次提交新版本的用户名。这样就容易追踪责任。\r\n\r\n* 试验功能（Sandboxing）。当你对文件做出重大变更时，你可以把编辑内容暂时性地保存在一个单独的区域，不断进行测试和除错。等到确认正确以后，再加入主版本。\r\n\r\n* 分支（Branching）和合并（merging）。分支功能可以看成是一个更大的测试版本。你将整个的代码做一份拷贝，然后再起一个独立的名字，追踪其变化，与原版本脱离关系，这就是分支。以后，你还可以将分支版本再并入源版本，这就是合并。\r\n\r\n</div></blockquote>\r\n虽然共享文件夹操作起来更快速和简单，但是它做不到上面这些功能。\r\n\r\n<strong>一些术语</strong>\r\n\r\n大多数VCS都有下面一些共同的概念，不过名字可能会稍有不同。\r\n\r\n基本概念\r\n<blockquote>\r\n<div>\r\n\r\n* Repository (repo): 储存文件的数据库。\r\n\r\n* Server: 储存repo的计算机。\r\n\r\n* Client: 连接repo的计算机。\r\n\r\n* Working Set/Working Copy: 当你编辑文件时，编辑对象所在的本地文件目录。\r\n\r\n* Trunk/Main: repo中储存代码文件的主位置。你可以把代码想像成一棵家族树，"trunk"就是主线的那条树干。\r\n\r\n</div></blockquote>\r\n基本操作\r\n<blockquote>\r\n<div>\r\n\r\n* Add: 将一个文件第一次加入repo，也就是开始用VCS追踪这个文件。\r\n\r\n* Revision: 文件的版本编号（即v1, v2, v3等等）。\r\n\r\n* Head: repo中保存的文件最新版本。\r\n\r\n* Check out：从repo中下载一个文件。\r\n\r\n* Check in: 上传文件进入repo（如果文件发生了变化）。这个文件将得到一个新的版本编号，用户将可以"check out"这个文件。\r\n\r\n* Checkin Message: 描述所做修改的短说明。\r\n\r\n* Changelog/History: 一个记录文件自从创建开始所有变动的清单。\r\n\r\n* Update/Sync: 将你本地的文件同repo中最新版本进行同步的过程。这将使得本地文件始终能够跟上最新的变动。\r\n\r\n* Revert: 放弃对文件所做的编辑，从repo中重新获得未编辑前的版本。\r\n\r\n</div></blockquote>\r\n高级操作\r\n<blockquote>\r\n<div>\r\n\r\n* Branch: 在repo中对一个文件或文件目录，创建一个独立的拷贝。Branch在这里既是动词（branch the code），又是名词（Which branch is it in?）。\r\n\r\n* Diff/Change/Delta: 找出两个文件之间的差别。对于比较不同版本之间的变动很有用。\r\n\r\n* Merge (or patch): 将一个文件上的改动，应用于另一个文件，使得两者保持相同。比如，你可以将一个branch中的功能merge到另一个branch中。\r\n\r\n* Conflict: 当你check in的时候，你所做的变动可能与其他用户发生冲突。（这时双方的编辑都不会生效。）\r\n\r\n* Resolve: 修改互相冲突的变动，check in正确的版本。\r\n\r\n* Locking: 取得一个文件的"控制权"，使得在你解锁之前，其他人不能编辑这个文件。有些VCS用这个功能避免conflict。\r\n\r\n* Breaking the lock: 强制解锁一个文件，使得你可以对其进行编辑。比如，某人lock了一个文件，但是他又去度假了。\r\n\r\n* Check out for edit: Check out到一个文件"可编辑"的版本。有些VCS默认允许编辑，另一些要求明确发出命令后，才提供可编辑的版本。\r\n\r\n</div></blockquote>\r\n一次典型的使用过程是这样的：\r\n<blockquote>\r\n<div>\r\n\r\n爱丽丝add一个文件（list.txt）进入repo。然后，她又把这个文件check out，做了一次编辑（在文件中加入milk这个单词）。接着，她将修改后的文件check in，并附有一条checking message（"加入了新的条目"）。第二天早上，鲍勃update了他本地的working set，看到了list.txt的最新修订版，其中包含了单词"milk"。如果他使用changelog或diff，都可以发现前一天爱丽丝加入"milk"这个词。\r\n\r\n</div></blockquote>\r\n下面，我们用一些例子，来讲解VCS的使用。\r\n\r\n<strong>Check in</strong>\r\n\r\n最简单的情况是，check in一个文件（list.txt），然后经常修改它。\r\n\r\n<img src="http://lh6.ggpht.com/_6p3hNkUNWrQ/SVoLDsjRN-I/AAAAAAAAAfQ/tSToYHiWfjY/s800/basic_checkin.png" />\r\n\r\n在subversion系统中的命令是：\r\n<blockquote>\r\n<div>\r\n\r\nsvn add list.txt\r\n(modify the file)\r\nsvn ci list.txt -m "Changed the list"\r\n\r\n</div></blockquote>\r\n最后一个命令中的-m标识，表示check in时附带的message。\r\n\r\n<strong>Check out和编辑</strong>\r\n\r\n你不一定总是Check in文件，有时候你需要check out，进行编辑，然后再check in。这个过程可以用下图表示：\r\n\r\n<img src="http://lh6.ggpht.com/_6p3hNkUNWrQ/SVoLDgv1CWI/AAAAAAAAAfY/ZFJMKyEdu3w/s800/checkout_edit.png" />\r\n\r\n如果你对自己的编辑不满意，想要从头开始，你可以revert到上一个版本。当你check out的时候，默认情况下，你总是会得到最新版本。如果你想得到以前的版本，你可以在命令中指定版本号。在Subversion中，运行下面的命令：\r\n<blockquote>\r\n<div>\r\n\r\nsvn co list.txt (get latest version)\r\n...edit file...\r\nsvn revert list.txt (throw away changes)\r\n\r\nsvn co -r2 list.txt (check out particular version)\r\n\r\n</div></blockquote>\r\n<strong>Diff</strong>\r\n\r\nDiff就是你编辑时所做的变动。你可以想象一下，单独将变动部分保存下来，然后将它们应用到一个文件上：\r\n\r\n<img src="http://lh3.ggpht.com/_6p3hNkUNWrQ/SVoLD0AVtHI/AAAAAAAAAfg/UwtiCFmut7Y/s800/basic_diffs.png" />\r\n\r\n比如，从r1版到r2版，我们加入eggs（+Eggs）。你可以将这个过程想象成，单独将图中红色的部分保存下来，然后将它应用到r1上，就可以得到r2。\r\n\r\n从r2版到r3版，我们加入了Juice（+Juice）。从r3版到r4版，我们删去了Juice加入了Soup（-Juice, +Soup）。\r\n\r\n大多数版本控制系统，只保存diff，而不是文件的完整版本。这样可以节省磁盘空间。你做了4次修改，不意味着系统保留了4份拷贝。实际上，系统内只有1份拷贝和4个diff。在SVN中，我们用下面的命令diff一个文件的两个版本：\r\n<blockquote>\r\n<div>\r\n\r\nsvn diff -r3:4 list.txt\r\n\r\n</div></blockquote>\r\n<strong>Branch</strong>\r\n\r\nBranch可以将源文件做一份拷贝，保存在VCS的另一个位置，然后我们对拷贝进行修改，不会影响到源文件。\r\n\r\n<img src="http://lh3.ggpht.com/_6p3hNkUNWrQ/SVoLEf3n8mI/AAAAAAAAAfo/fcsr3yV4-8M/s800/first_branch.png" />\r\n\r\n比如，上图中我们创建了一个branch，在其中加入了Rice，而在trunk上加入的是Bread。有的VCS在创建Branch时，可能会修改版本号。\r\n\r\n在Subversion中，创建branch的命令很简单，只要从一个目录拷贝到另一个目录就可以了。\r\n<blockquote>\r\n<div>\r\n\r\nsvn copy http://path/to/trunk http://path/to/branch\r\n\r\n</div></blockquote>\r\n所以，branch并不难理解，你只要想像将代码拷贝到不同目录就行了。它的好处在于，不管你做错了什么，你总可以回到一个安全的版本。\r\n\r\n<strong>Merge</strong>\r\n\r\n如果你要将一个branch中的变动，并入另一个branch，这可不太简单。\r\n\r\n比如，我们要将Rice这个词从一个branch，并入主线中的文件。我们应该怎么做？Diff一下r6和r7，然后再并入主线？\r\n\r\n错了。我们只需要找到branch所做的变动就可以了。也就是说，我们只要diff一下r5和r6，然后再应用到trunk上就可以了。\r\n\r\n<img src="http://lh6.ggpht.com/_6p3hNkUNWrQ/SVoLYIanO4I/AAAAAAAAAfw/tvJUwLe2LSs/s800/merging.png" />\r\n\r\n如果我们diff了r6和r7，我们就会漏掉"Bread"这个已经在主干中的词。这是很微妙的一个地方，branch中的变动在于Rice这个词（+Rice），只要将这个词加入主干就可以了。主干文件中也许还有其他变化，不过这不要紧，我们所要的只是插入Rice这个特性。\r\n\r\n在Subversion中，merge命令与diff很类似。在一个主干中，运行下面的命令：\r\n<blockquote>\r\n<div>\r\n\r\nsvn merge -r5:6 http://path/to/branch\r\n\r\n</div></blockquote>\r\n这个命令diff了r5和r6，然后将其加入当前位置的文件中。不幸的是，Subversion没有提供一种容易的途径，追踪merge中到底有什么变动。所以如果你不小心的话，你可能将同样的变动应用两次。SVN已经计划提供这个功能，但是目前的建议还是，保留一份changelog message，提醒你r5-r6已经并入了主干。\r\n\r\n<strong>Conflict</strong>\r\n\r\nConflict往往来自不同用户，同时对同一个内容做出了不同的修改。Joe想删除eggs，加入cheese（-eggs, +cheese），Sue想删除eggs，加入hot dog（-eggs, +hot dog）。\r\n\r\n<img src="http://lh4.ggpht.com/_6p3hNkUNWrQ/SVoLYbEQnvI/AAAAAAAAAf4/lOqpIo24lxU/s800/vcs_conflict.png" />\r\n\r\n从某个角度看，这有点像一场比赛：如果Joe首先check in，那么他的编辑将写入文件。（Sue的编辑将被拒绝。）\r\n\r\n如果他们同时提交了这种互相冲突的变动，VCS将报告一个conflict，不允许check in。由你来决定，是check in一个更新的版本，还是就地解决这个冲突。下面是一些可能的办法：\r\n<blockquote>\r\n<div>\r\n\r\n* 重做一遍编辑。首先，将文件Sync到最新的版本（r4），这时cheese已经在文件中了。你再重做一遍剪辑，加上hot dog。\r\n\r\n* 覆盖掉他人的修改。将文件check out到最新的版本（r4），用你的版本将这个版本覆盖，再check in。也就是说，你等于删掉了cheese，替换为hot dog。\r\n\r\n</div></blockquote>\r\nConflict不是很常见，但是处理起来很麻烦。通常，我会选择上面第一种处理方法。\r\n\r\n<strong>Tag</strong>\r\n\r\n大概不会有人想到VCS早就符合Web 2.0的潮流吧？许多VCS允许你对任意编辑做一个标签（label），方便以后的引用。这样一来，你就可以用"Release 1.0"，指代内部的版本号码。\r\n\r\n<img src="http://lh5.ggpht.com/_6p3hNkUNWrQ/SVoLYnXYHOI/AAAAAAAAAgA/bg6tScYWws8/s800/tagging.png" />\r\n\r\n在Subversion中，tag其实是不再让你编辑的branche，它们只是方便为了以后的使用，让你能够明确看到1.0版中到底包含了哪些东西。因此它们就停顿在那里，不再变动了。\r\n<blockquote>\r\n<div>\r\n\r\n(in trunk)\r\nsvn copy http://path/to/revision http://path/to/tag\r\n\r\n</div></blockquote>\r\n<strong>一个实际的例子：管理Windows源码</strong>\r\n\r\n我们前面说过，微软公司不用共享文件夹管理代码，那么他们怎么管理呢？\r\n<blockquote>\r\n<div>\r\n\r\n* 首先有一条main line，专门保存稳定版本的Windows。\r\n\r\n* 然后，每个开发小组（网络、用户界面、媒体播放器等等）都有各自的branch，来添加新功能。这些新功能还在开发当中，并不稳定。\r\n\r\n</div></blockquote>\r\n你在你的branch中，开发了一个新功能。然后，你用"Reverse Integrate (RI)"，将它并入主版本。接着，你再用"Forward Integrate"，你再去得到最新的主版本，将它并入你的branch。\r\n\r\n<img src="http://lh5.ggpht.com/_6p3hNkUNWrQ/SVoLYh54wwI/AAAAAAAAAgI/uPWUHHD2T_c/s800/windows.png" />\r\n\r\n假设老版本是Media Player 10和IE 6。Media Player开发小组，在他们的branch中制作了第11版，然后他们用一个10 - 11的补丁，将第11版加入老版本中。这是一个reverse integration，从branch到trunk。IE开发小组也是同样的步骤。\r\n\r\n接着，Media Player开发小组从其他小组（比如IE小组）得到最新的代码。在这个例子中，Media Player从trunk得到最新的补丁，运用到他们的branch中，这叫做forward integration。\r\n\r\nreverse integration和forward integration，分别简称RI和FI。这样的安排让变动主要在branch中发生，而使得主干保持相对不受影响。\r\n在微软实际运作中，有很多层的branch和sub-branch，还有许多质量控制标准，确定什么时候才可以进行RI。这里只是希望帮助你建立一个想法，那就是branch有助于管理复杂的项目。现在，你应该明白了世界上最大的软件项目之一，是怎么进行组织的。\r\n\r\n<strong>结束语</strong>\r\n\r\n如果你以前没有用过VCS，我建议你使用它。因为它是一种很好的工具，即使你不打算写一个操作系统，单单就是为了备份，也值得用它。\r\n\r\n网上有许多VCS软件可供选择，并且都有详细的教程或手册，比如<a href="http://svnbook.red-bean.com/" target="_blank">SVN</a>、<a href="http://wwwasd.web.cern.ch/wwwasd/cvs/tutorial/cvs_tutorial_toc.html" target="_blank">CVS</a>、<a href="http://agave.garden.org/~aaronh/rcs/tutorial.html" target="_blank">RCS</a>、<a href="http://www.kernel.org/pub/software/scm/git/docs/tutorial.html" target="_blank">Git</a>、<a href="http://public.perforce.com/public/tutorial.html" target="_blank">Perforce</a>等等。Eric Sink写过一个详细的<a href="http://www.ericsink.com/scm/source_control.html" target="_blank">version control guide</a>可供参考。\r\n\r\n（完）\r\n\r\n</div>\r\n</article></div>','版本控制入门','','publish','open','open','','source-control','','','2016-11-01 18:06:26','2016-11-01 10:06:26','',0,'https://blog-scottwang.rhcloud.com/?p=85',0,'post','',0),
 (87,1,'2016-11-01 18:08:01','2016-11-01 10:08:01','from:\r\n<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a>\r\n<div id="entry-1805" class="entry-asset asset hentry"><article class="hentry">\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现<a href="http://www.google.com.hk/search?q=API+first" target="_blank">"API First"</a>的设计思想。<a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">RESTful API</a>是目前比较成熟的一套互联网应用程序的API设计理论。我以前写过一篇<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank">《理解RESTful架构》</a>，探讨如何理解这个概念。\r\n\r\n今天，我将介绍RESTful API的设计细节，探讨如何设计一套合理、好用的API。我的主要参考了两篇文章（<a href="http://codeplanet.io/principles-good-restful-api-design/" target="_blank">1</a>，<a href="https://bourgeois.me/rest/" target="_blank">2</a>）。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014052201.png" alt="RESTful API" />\r\n<h2>一、协议</h2>\r\nAPI与用户的通信协议，总是使用<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank">HTTPs协议</a>。\r\n<h2>二、域名</h2>\r\n应该尽量将API部署在专用域名之下。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\nhttps<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>example<span class="token punctuation">.</span>com\r\n</code></pre>\r\n</blockquote>\r\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\nhttps<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>org<span class="token regex">/api/</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>三、版本（Versioning）</h2>\r\n应该将API的版本号放入URL。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\nhttps<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>example<span class="token punctuation">.</span>com<span class="token regex">/v1/</span>\r\n</code></pre>\r\n</blockquote>\r\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<a href="https://developer.github.com/v3/media/#request-specific-version" target="_blank">Github</a>采用这种做法。\r\n<h2>四、路径（Endpoint）</h2>\r\n路径又称"终点"（endpoint），表示API的具体网址。\r\n\r\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的"集合"（collection），所以API中的名词也应该使用复数。\r\n\r\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\r\n<blockquote>\r\n<ul>\r\n 	<li>https://api.example.com/v1/zoos</li>\r\n 	<li>https://api.example.com/v1/animals</li>\r\n 	<li>https://api.example.com/v1/employees</li>\r\n</ul>\r\n</blockquote>\r\n<h2>五、HTTP动词</h2>\r\n对于资源的具体操作类型，由HTTP动词表示。\r\n\r\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\r\n<blockquote>\r\n<ul>\r\n 	<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\r\n 	<li>POST（CREATE）：在服务器新建一个资源。</li>\r\n 	<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\r\n 	<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\r\n 	<li>DELETE（DELETE）：从服务器删除资源。</li>\r\n</ul>\r\n</blockquote>\r\n还有两个不常用的HTTP动词。\r\n<blockquote>\r\n<ul>\r\n 	<li>HEAD：获取资源的元数据。</li>\r\n 	<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\r\n</ul>\r\n</blockquote>\r\n下面是一些例子。\r\n<blockquote>\r\n<ul>\r\n 	<li>GET /zoos：列出所有动物园</li>\r\n 	<li>POST /zoos：新建一个动物园</li>\r\n 	<li>GET /zoos/ID：获取某个指定动物园的信息</li>\r\n 	<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\r\n 	<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\r\n 	<li>DELETE /zoos/ID：删除某个动物园</li>\r\n 	<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\r\n 	<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\r\n</ul>\r\n</blockquote>\r\n<h2>六、过滤信息（Filtering）</h2>\r\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\r\n\r\n下面是一些常见的参数。\r\n<blockquote>\r\n<ul>\r\n 	<li>?limit=10：指定返回记录的数量</li>\r\n 	<li>?offset=10：指定返回记录的开始位置。</li>\r\n 	<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\r\n 	<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\r\n 	<li>?animal_type_id=1：指定筛选条件</li>\r\n</ul>\r\n</blockquote>\r\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\r\n<h2>七、状态码（Status Codes）</h2>\r\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\r\n<blockquote>\r\n<ul>\r\n 	<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\r\n 	<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\r\n 	<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\r\n 	<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\r\n 	<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\r\n 	<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\r\n 	<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\r\n 	<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\r\n 	<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\r\n 	<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\r\n 	<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\r\n 	<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\r\n</ul>\r\n</blockquote>\r\n状态码的完全列表参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank">这里</a>。\r\n<h2>八、错误处理（Error handling）</h2>\r\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token punctuation">{</span>\r\n    error<span class="token punctuation">:</span> <span class="token string">"Invalid API key"</span>\r\n<span class="token punctuation">}</span>\r\n</code></pre>\r\n</blockquote>\r\n<h2>九、返回结果</h2>\r\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\r\n<blockquote>\r\n<ul>\r\n 	<li>GET /collection：返回资源对象的列表（数组）</li>\r\n 	<li>GET /collection/resource：返回单个资源对象</li>\r\n 	<li>POST /collection：返回新生成的资源对象</li>\r\n 	<li>PUT /collection/resource：返回完整的资源对象</li>\r\n 	<li>PATCH /collection/resource：返回完整的资源对象</li>\r\n 	<li>DELETE /collection/resource：返回一个空文档</li>\r\n</ul>\r\n</blockquote>\r\n<h2>十、Hypermedia API</h2>\r\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\r\n\r\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token punctuation">{</span><span class="token string">"link"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\r\n  <span class="token string">"rel"</span><span class="token punctuation">:</span>   <span class="token string">"collection <a class="token url-link" href="https://www.example.com/zoos">https://www.example.com/zoos</a>"</span><span class="token punctuation">,</span>\r\n  <span class="token string">"href"</span><span class="token punctuation">:</span>  <span class="token string">"<a class="token url-link" href="https://api.example.com/zoos">https://api.example.com/zoos</a>"</span><span class="token punctuation">,</span>\r\n  <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"List of zoos"</span><span class="token punctuation">,</span>\r\n  <span class="token string">"type"</span><span class="token punctuation">:</span>  <span class="token string">"application/vnd.yourformat+json"</span>\r\n<span class="token punctuation">}</span><span class="token punctuation">}</span>\r\n</code></pre>\r\n</blockquote>\r\n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\r\n\r\nHypermedia API的设计被称为<a href="http://en.wikipedia.org/wiki/HATEOAS" target="_blank">HATEOAS</a>。Github的API就是这种设计，访问<a href="https://api.github.com/" target="_blank">api.github.com</a>会得到一个所有可用API的网址列表。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token punctuation">{</span>\r\n  <span class="token string">"current_user_url"</span><span class="token punctuation">:</span> <span class="token string">"<a class="token url-link" href="https://api.github.com/user">https://api.github.com/user</a>"</span><span class="token punctuation">,</span>\r\n  <span class="token string">"authorizations_url"</span><span class="token punctuation">:</span> <span class="token string">"<a class="token url-link" href="https://api.github.com/authorizations">https://api.github.com/authorizations</a>"</span><span class="token punctuation">,</span>\r\n <span class="token comment" spellcheck="true"> // ...\r\n</span><span class="token punctuation">}</span>\r\n</code></pre>\r\n</blockquote>\r\n从上面可以看到，如果想获取当前用户的信息，应该去访问<a href="https://api.github.com/user" target="_blank">api.github.com/user</a>，然后就得到了下面结果。\r\n<blockquote>\r\n<pre class=" language-javascript"><code class=" language-javascript">\r\n<span class="token punctuation">{</span>\r\n  <span class="token string">"message"</span><span class="token punctuation">:</span> <span class="token string">"Requires authentication"</span><span class="token punctuation">,</span>\r\n  <span class="token string">"documentation_url"</span><span class="token punctuation">:</span> <span class="token string">"<a class="token url-link" href="https://developer.github.com/v3">https://developer.github.com/v3</a>"</span>\r\n<span class="token punctuation">}</span>\r\n</code></pre>\r\n</blockquote>\r\n上面代码表示，服务器给出了提示信息，以及文档的网址。\r\n<h2>十一、其他</h2>\r\n（1）API的身份认证应该使用<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank">OAuth 2.0</a>框架。\r\n\r\n（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。\r\n\r\n（完）\r\n\r\n</div>\r\n</article></div>','RESTful API设计指南','','publish','open','open','','restful-api','','','2016-11-01 18:08:01','2016-11-01 10:08:01','',0,'https://blog-scottwang.rhcloud.com/?p=87',0,'post','',0),
 (89,1,'2016-11-01 18:09:29','2016-11-01 10:09:29','from:\r\n<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>\r\n<div id="entry-1804" class="entry-asset asset hentry"><article class="hentry">\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n<a href="http://en.wikipedia.org/wiki/OAuth" target="_blank">OAuth</a>是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a href="http://www.rfcreader.com/#rfc6749" target="_blank">RFC 6749</a>。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014051201.png" alt="OAuth Logo" />\r\n<h2>一、应用场景</h2>\r\n为了理解OAuth的适用场合，让我举一个假设的例子。\r\n\r\n有一个"云冲印"的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让"云冲印"读取自己储存在Google上的照片。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014051202.png" alt="云冲印" />\r\n\r\n问题是只有得到用户的授权，Google才会同意"云冲印"读取这些照片。那么，"云冲印"怎样获得用户的授权呢？\r\n\r\n传统方法是，用户将自己的Google用户名和密码，告诉"云冲印"，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。\r\n<blockquote>（1）"云冲印"为了后续的服务，会保存用户的密码，这样很不安全。\r\n\r\n（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。\r\n\r\n（3）"云冲印"拥有了获取用户储存在Google所有资料的权力，用户没法限制"云冲印"获得授权的范围和有效期。\r\n\r\n（4）用户只有修改密码，才能收回赋予"云冲印"的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。\r\n\r\n（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</blockquote>\r\nOAuth就是为了解决上面这些问题而诞生的。\r\n<h2>二、名词定义</h2>\r\n在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。\r\n<blockquote>（1） <strong>Third-party application</strong>：第三方应用程序，本文中又称"客户端"（client），即上一节例子中的"云冲印"。\r\n\r\n（2）<strong>HTTP service</strong>：HTTP服务提供商，本文中简称"服务提供商"，即上一节例子中的Google。\r\n\r\n（3）<strong>Resource Owner</strong>：资源所有者，本文中又称"用户"（user）。\r\n\r\n（4）<strong>User Agent</strong>：用户代理，本文中就是指浏览器。\r\n\r\n（5）<strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。\r\n\r\n（6）<strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</blockquote>\r\n知道了上面这些名词，就不难理解，OAuth的作用就是让"客户端"安全可控地获取"用户"的授权，与"服务商提供商"进行互动。\r\n<h2>三、OAuth的思路</h2>\r\nOAuth在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。\r\n\r\n"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。\r\n<h2>四、运行流程</h2>\r\nOAuth 2.0的运行流程如下图，摘自RFC 6749。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014051203.png" alt="OAuth运行流程" />\r\n<blockquote>（A）用户打开客户端以后，客户端要求用户给予授权。\r\n\r\n（B）用户同意给予客户端授权。\r\n\r\n（C）客户端使用上一步获得的授权，向认证服务器申请令牌。\r\n\r\n（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。\r\n\r\n（E）客户端使用令牌，向资源服务器申请获取资源。\r\n\r\n（F）资源服务器确认令牌无误，同意向客户端开放资源。</blockquote>\r\n不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。\r\n\r\n下面一一讲解客户端获取授权的四种模式。\r\n<h2>五、客户端的授权模式</h2>\r\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。\r\n<ul>\r\n 	<li>授权码模式（authorization code）</li>\r\n 	<li>简化模式（implicit）</li>\r\n 	<li>密码模式（resource owner password credentials）</li>\r\n 	<li>客户端模式（client credentials）</li>\r\n</ul>\r\n<h2>六、授权码模式</h2>\r\n授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014051204.png" alt="授权码模式" />\r\n\r\n它的步骤如下：\r\n<blockquote>（A）用户访问客户端，后者将前者导向认证服务器。\r\n\r\n（B）用户选择是否给予客户端授权。\r\n\r\n（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI"（redirection URI），同时附上一个授权码。\r\n\r\n（D）客户端收到授权码，附上早先的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。\r\n\r\n（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</blockquote>\r\n下面是上面这些步骤所需要的参数。\r\n\r\nA步骤中，客户端申请认证的URI，包含以下参数：\r\n<ul>\r\n 	<li>response_type：表示授权类型，必选项，此处的值固定为"code"</li>\r\n 	<li>client_id：表示客户端的ID，必选项</li>\r\n 	<li>redirect_uri：表示重定向URI，可选项</li>\r\n 	<li>scope：表示申请的权限范围，可选项</li>\r\n 	<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>\r\n</ul>\r\n下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\nGET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz\r\n        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\r\n<span class="token keyword">Host:</span> server.example.com\r\n\r\n</code></pre>\r\n</blockquote>\r\nC步骤中，服务器回应客户端的URI，包含以下参数：\r\n<ul>\r\n 	<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>\r\n 	<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>\r\n</ul>\r\n下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\nHTTP/1.1 302 Found\r\n<span class="token keyword">Location:</span> <a class="token url-link" href="https://client.example.com/cb">https://client.example.com/cb</a>?code=SplxlOBeZQQYbYS6WxSbIA\r\n          &amp;state=xyz\r\n\r\n</code></pre>\r\n</blockquote>\r\nD步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：\r\n<ul>\r\n 	<li>grant_type：表示使用的授权模式，必选项，此处的值固定为"authorization_code"。</li>\r\n 	<li>code：表示上一步获得的授权码，必选项。</li>\r\n 	<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>\r\n 	<li>client_id：表示客户端ID，必选项。</li>\r\n</ul>\r\n下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\nPOST /token HTTP/1.1\r\n<span class="token keyword">Host:</span> server.example.com\r\n<span class="token keyword">Authorization:</span> Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\r\n<span class="token keyword">Content-Type:</span> application/x-www-form-urlencoded\r\n\r\ngrant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA\r\n&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\r\n\r\n</code></pre>\r\n</blockquote>\r\nE步骤中，认证服务器发送的HTTP回复，包含以下参数：\r\n<ul>\r\n 	<li>access_token：表示访问令牌，必选项。</li>\r\n 	<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>\r\n 	<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>\r\n 	<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>\r\n 	<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>\r\n</ul>\r\n下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n     HTTP/1.1 200 OK\r\n     Content-Type: application/json;charset=UTF-8\r\n     Cache-Control: no-store\r\n     Pragma: no-cache<span class="token application/json">\r\n\r\n     <span class="token punctuation">{</span>\r\n       <span class="token string">"access_token"</span><span class="token punctuation">:</span><span class="token string">"2YotnFZFEjr1zCsicMWpAA"</span><span class="token punctuation">,</span>\r\n       <span class="token string">"token_type"</span><span class="token punctuation">:</span><span class="token string">"example"</span><span class="token punctuation">,</span>\r\n       <span class="token string">"expires_in"</span><span class="token punctuation">:</span><span class="token number">3600</span><span class="token punctuation">,</span>\r\n       <span class="token string">"refresh_token"</span><span class="token punctuation">:</span><span class="token string">"tGzv3JOkF0XG5Qx2TlKWIA"</span><span class="token punctuation">,</span>\r\n       <span class="token string">"example_parameter"</span><span class="token punctuation">:</span><span class="token string">"example_value"</span>\r\n     <span class="token punctuation">}</span>\r\n\r\n</span></code></pre>\r\n</blockquote>\r\n从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。\r\n<h2>七、简化模式</h2>\r\n简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014051205.png" alt="简化模式" />\r\n\r\n它的步骤如下：\r\n<blockquote>（A）客户端将用户导向认证服务器。\r\n\r\n（B）用户决定是否给于客户端授权。\r\n\r\n（C）假设用户给予授权，认证服务器将用户导向客户端指定的"重定向URI"，并在URI的Hash部分包含了访问令牌。\r\n\r\n（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。\r\n\r\n（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。\r\n\r\n（F）浏览器执行上一步获得的脚本，提取出令牌。\r\n\r\n（G）浏览器将令牌发给客户端。</blockquote>\r\n下面是上面这些步骤所需要的参数。\r\n\r\nA步骤中，客户端发出的HTTP请求，包含以下参数：\r\n<ul>\r\n 	<li>response_type：表示授权类型，此处的值固定为"token"，必选项。</li>\r\n 	<li>client_id：表示客户端的ID，必选项。</li>\r\n 	<li>redirect_uri：表示重定向的URI，可选项。</li>\r\n 	<li>scope：表示权限范围，可选项。</li>\r\n 	<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>\r\n</ul>\r\n下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n    GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz\r\n        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\r\n    Host: server.example.com\r\n\r\n</code></pre>\r\n</blockquote>\r\nC步骤中，认证服务器回应客户端的URI，包含以下参数：\r\n<ul>\r\n 	<li>access_token：表示访问令牌，必选项。</li>\r\n 	<li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li>\r\n 	<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>\r\n 	<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>\r\n 	<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>\r\n</ul>\r\n下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n     HTTP/1.1 302 Found\r\n     Location: <a class="token url-link" href="http://example.com/cb">http://example.com/cb</a>#access_token=2YotnFZFEjr1zCsicMWpAA\r\n               &amp;state=xyz&amp;token_type=example&amp;expires_in=3600\r\n\r\n</code></pre>\r\n</blockquote>\r\n在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。\r\n\r\n根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。\r\n<h2>八、密码模式</h2>\r\n密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。\r\n\r\n在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014051206.png" alt="密码模式" />\r\n\r\n它的步骤如下：\r\n<blockquote>（A）用户向客户端提供用户名和密码。\r\n\r\n（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。\r\n\r\n（C）认证服务器确认无误后，向客户端提供访问令牌。</blockquote>\r\nB步骤中，客户端发出的HTTP请求，包含以下参数：\r\n<ul>\r\n 	<li>grant_type：表示授权类型，此处的值固定为"password"，必选项。</li>\r\n 	<li>username：表示用户名，必选项。</li>\r\n 	<li>password：表示用户的密码，必选项。</li>\r\n 	<li>scope：表示权限范围，可选项。</li>\r\n</ul>\r\n下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n     POST /token HTTP/1.1\r\n     Host: server.example.com\r\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\r\n     Content-Type: application/x-www-form-urlencoded\r\n\r\n     grant_type=password&amp;username=johndoe&amp;password=A3ddj3w\r\n\r\n</code></pre>\r\n</blockquote>\r\nC步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n     HTTP/1.1 200 OK\r\n     Content-Type: application/json;charset=UTF-8\r\n     Cache-Control: no-store\r\n     Pragma: no-cache<span class="token application/json">\r\n\r\n     <span class="token punctuation">{</span>\r\n       <span class="token string">"access_token"</span><span class="token punctuation">:</span><span class="token string">"2YotnFZFEjr1zCsicMWpAA"</span><span class="token punctuation">,</span>\r\n       <span class="token string">"token_type"</span><span class="token punctuation">:</span><span class="token string">"example"</span><span class="token punctuation">,</span>\r\n       <span class="token string">"expires_in"</span><span class="token punctuation">:</span><span class="token number">3600</span><span class="token punctuation">,</span>\r\n       <span class="token string">"refresh_token"</span><span class="token punctuation">:</span><span class="token string">"tGzv3JOkF0XG5Qx2TlKWIA"</span><span class="token punctuation">,</span>\r\n       <span class="token string">"example_parameter"</span><span class="token punctuation">:</span><span class="token string">"example_value"</span>\r\n     <span class="token punctuation">}</span>\r\n\r\n</span></code></pre>\r\n</blockquote>\r\n上面代码中，各个参数的含义参见《授权码模式》一节。\r\n\r\n整个过程中，客户端不得保存用户的密码。\r\n<h2>九、客户端模式</h2>\r\n客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。\r\n\r\n<img title="" src="http://image.beekka.com/blog/2014/bg2014051207.png" alt="客户端模式" />\r\n\r\n它的步骤如下：\r\n<blockquote>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。\r\n\r\n（B）认证服务器确认无误后，向客户端提供访问令牌。</blockquote>\r\nA步骤中，客户端发出的HTTP请求，包含以下参数：\r\n<ul>\r\n 	<li>grant<em>type：表示授权类型，此处的值固定为"client</em>credentials"，必选项。</li>\r\n 	<li>scope：表示权限范围，可选项。</li>\r\n</ul>\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n     POST /token HTTP/1.1\r\n     Host: server.example.com\r\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\r\n     Content-Type: application/x-www-form-urlencoded\r\n\r\n     grant_type=client_credentials\r\n\r\n</code></pre>\r\n</blockquote>\r\n认证服务器必须以某种方式，验证客户端身份。\r\n\r\nB步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n     HTTP/1.1 200 OK\r\n     Content-Type: application/json;charset=UTF-8\r\n     Cache-Control: no-store\r\n     Pragma: no-cache<span class="token application/json">\r\n\r\n     <span class="token punctuation">{</span>\r\n       <span class="token string">"access_token"</span><span class="token punctuation">:</span><span class="token string">"2YotnFZFEjr1zCsicMWpAA"</span><span class="token punctuation">,</span>\r\n       <span class="token string">"token_type"</span><span class="token punctuation">:</span><span class="token string">"example"</span><span class="token punctuation">,</span>\r\n       <span class="token string">"expires_in"</span><span class="token punctuation">:</span><span class="token number">3600</span><span class="token punctuation">,</span>\r\n       <span class="token string">"example_parameter"</span><span class="token punctuation">:</span><span class="token string">"example_value"</span>\r\n     <span class="token punctuation">}</span>\r\n\r\n</span></code></pre>\r\n</blockquote>\r\n上面代码中，各个参数的含义参见《授权码模式》一节。\r\n<h2>十、更新令牌</h2>\r\n如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。\r\n\r\n客户端发出更新令牌的HTTP请求，包含以下参数：\r\n<ul>\r\n 	<li>grant<em>type：表示使用的授权模式，此处的值固定为"refresh</em>token"，必选项。</li>\r\n 	<li>refresh_token：表示早前收到的更新令牌，必选项。</li>\r\n 	<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>\r\n</ul>\r\n下面是一个例子。\r\n<blockquote>\r\n<pre class=" language-http"><code class=" language-http">\r\n     POST /token HTTP/1.1\r\n     Host: server.example.com\r\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\r\n     Content-Type: application/x-www-form-urlencoded\r\n\r\n     grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\r\n\r\n</code></pre>\r\n</blockquote>\r\n（完）\r\n\r\n</div>\r\n</article></div>','理解OAuth2.0','','publish','open','open','','oauth2','','','2016-11-01 18:09:29','2016-11-01 10:09:29','',0,'https://blog-scottwang.rhcloud.com/?p=89',0,'post','',0),
 (91,1,'2016-11-01 18:11:55','2016-11-01 10:11:55','from:\r\n<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">http://www.ruanyifeng.com/blog/2012/07/git.html</a>\r\n<div id="entry-1730" class="entry-asset asset hentry"><article class="hentry">\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n如果你严肃对待编程，就必定会使用"<a href="http://www.ruanyifeng.com/blog/2008/12/a_visual_guide_to_version_control.html" target="_blank">版本管理系统</a>"（Version Control System）。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n眼下最流行的"版本管理系统"，非<a href="http://git-scm.com/" target="_blank">Git</a>莫属。\r\n\r\n<img style="border: none;" src="http://image.beekka.com/blog/201207/bg2012070501.png" />\r\n\r\n相比同类软件，Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称"快照"）的指针，因此非常快捷易用。\r\n\r\n但是，太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。\r\n\r\n<img src="http://image.beekka.com/blog/201207/bg2012070502.png" />\r\n\r\n<a href="http://nvie.com" target="_blank">Vincent Driessen</a>提出了一个分支管理的<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank">策略</a>，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用，Git只是用来举例而已。如果你不熟悉Git，跳过举例部分就可以了。\r\n\r\n<strong>一、主分支Master</strong>\r\n\r\n首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。\r\n\r\n<img src="http://image.beekka.com/blog/201207/bg2012070503.png" />\r\n\r\nGit主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。\r\n\r\n<strong>二、开发分支Develop</strong>\r\n\r\n主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。\r\n\r\n<img src="http://image.beekka.com/blog/201207/bg2012070504.png" />\r\n\r\n这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行"合并"（merge）。\r\n\r\nGit创建Develop分支的命令：\r\n<blockquote>　　git checkout -b develop master</blockquote>\r\n将Develop分支发布到Master分支的命令：\r\n<blockquote>　　# 切换到Master分支\r\ngit checkout master\r\n\r\n# 对Develop分支进行合并\r\ngit merge --no-ff develop</blockquote>\r\n这里稍微解释一下，上一条命令的--no-ff参数是什么意思。默认情况下，Git执行"快进式合并"（fast-farward merge），会直接将Master分支指向Develop分支。\r\n\r\n<img src="http://image.beekka.com/blog/201207/bg2012070505.png" />\r\n\r\n使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。关于合并的更多解释，请参考Benjamin Sandofsky的<a href="http://sandofsky.com/blog/git-workflow.html" target="_blank">《Understanding the Git Workflow》</a>。\r\n\r\n<img src="http://image.beekka.com/blog/201207/bg2012070506.png" />\r\n\r\n<strong>三、临时性分支</strong>\r\n\r\n前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。\r\n\r\n但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：\r\n<blockquote>　　* 功能（feature）分支\r\n\r\n* 预发布（release）分支\r\n\r\n* 修补bug（fixbug）分支</blockquote>\r\n这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。\r\n\r\n<strong>四、 功能分支</strong>\r\n\r\n接下来，一个个来看这三种"临时性分支"。\r\n\r\n第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。\r\n\r\n<img src="http://image.beekka.com/blog/201207/bg2012070507.png" />\r\n\r\n功能分支的名字，可以采用feature-*的形式命名。\r\n\r\n创建一个功能分支：\r\n<blockquote>　　git checkout -b feature-x develop</blockquote>\r\n开发完成后，将功能分支合并到develop分支：\r\n<blockquote>　　git checkout develop\r\n\r\ngit merge --no-ff feature-x</blockquote>\r\n删除feature分支：\r\n<blockquote>　　git branch -d feature-x</blockquote>\r\n<strong>五、预发布分支</strong>\r\n\r\n第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。\r\n\r\n预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。\r\n\r\n创建一个预发布分支：\r\n<blockquote>　　git checkout -b release-1.2 develop</blockquote>\r\n确认没有问题后，合并到master分支：\r\n<blockquote>　　git checkout master\r\n\r\ngit merge --no-ff release-1.2\r\n\r\n# 对合并生成的新节点，做一个标签\r\ngit tag -a 1.2</blockquote>\r\n再合并到develop分支：\r\n<blockquote>　　git checkout develop\r\n\r\ngit merge --no-ff release-1.2</blockquote>\r\n最后，删除预发布分支：\r\n<blockquote>　　git branch -d release-1.2</blockquote>\r\n<strong>六、修补bug分支</strong>\r\n\r\n最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。\r\n\r\n修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。\r\n\r\n<img src="http://image.beekka.com/blog/201207/bg2012070508.png" />\r\n\r\n创建一个修补bug分支：\r\n<blockquote>　　git checkout -b fixbug-0.1 master</blockquote>\r\n修补结束后，合并到master分支：\r\n<blockquote>　　git checkout master\r\n\r\ngit merge --no-ff fixbug-0.1\r\n\r\ngit tag -a 0.1.1</blockquote>\r\n再合并到develop分支：\r\n<blockquote>　　git checkout develop\r\n\r\ngit merge --no-ff fixbug-0.1</blockquote>\r\n最后，删除"修补bug分支"：\r\n<blockquote>　　git branch -d fixbug-0.1</blockquote>\r\n（完）\r\n\r\n</div>\r\n</article></div>','Git分支管理策略','','publish','open','open','','git-branch-manage','','','2016-11-01 18:12:40','2016-11-01 10:12:40','',0,'https://blog-scottwang.rhcloud.com/?p=91',0,'post','',0),
 (95,1,'2016-11-01 18:14:12','2016-11-01 10:14:12','from:\r\n<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">http://www.ruanyifeng.com/blog/2011/09/restful.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n越来越多的人开始意识到，<strong>网站即软件</strong>，而且是一种新型的软件。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n这种"互联网软件"采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。\r\n\r\n网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，<strong>现在我们必须考虑，如何开发在互联网环境中使用的软件。</strong>\r\n\r\n<img src="http://image.beekka.com/blog/201109/bg2011091202.jpg" />\r\n\r\nRESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。\r\n\r\n但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。\r\n\r\n<strong>一、起源</strong>\r\n\r\nREST这个词，是<a href="http://en.wikipedia.org/wiki/Roy_Fielding" target="_blank">Roy Thomas Fielding</a>在他2000年的<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank">博士论文</a>中提出的。\r\n\r\n<img src="http://image.beekka.com/blog/201109/bg2011091201.jpg" />\r\n\r\nFielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。\r\n\r\n他这样介绍论文的写作目的：\r\n<blockquote>"本文研究计算机科学两大前沿----软件和网络----的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。<strong>我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。</strong>"\r\n\r\n(This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. )</blockquote>\r\n<strong>二、名称</strong>\r\n\r\nFielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是"表现层状态转化"。\r\n\r\n如果一个架构符合REST原则，就称它为RESTful架构。\r\n\r\n<strong>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\r\n\r\n<strong>三、资源（Resources）</strong>\r\n\r\nREST的名称"表现层状态转化"中，省略了主语。"表现层"其实指的是"资源"（Resources）的"表现层"。\r\n\r\n<strong>所谓"资源"，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。\r\n\r\n所谓"上网"，就是与互联网上一系列的"资源"互动，调用它的URI。\r\n\r\n<strong>四、表现层（Representation）</strong>\r\n\r\n"资源"是一种信息实体，它可以有多种外在表现形式。<strong>我们把"资源"具体呈现出来的形式，叫做它的"表现层"（Representation）。</strong>\r\n\r\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\r\n\r\nURI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而URI应该只代表"资源"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。\r\n\r\n<strong>五、状态转化（State Transfer）</strong>\r\n\r\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\r\n\r\n互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。</strong>\r\n\r\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong>\r\n\r\n<strong>六、综述</strong>\r\n\r\n综合上面的解释，我们总结一下什么是RESTful架构：\r\n\r\n（1）每一个URI代表一种资源；\r\n\r\n（2）客户端和服务器之间，传递这种资源的某种表现层；\r\n\r\n（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。\r\n\r\n<strong>七、误区</strong>\r\n\r\nRESTful架构有一些典型的设计误区。\r\n\r\n<strong>最常见的一种设计错误，就是URI包含动词。</strong>因为"资源"表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。\r\n\r\n举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。\r\n\r\n如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：\r\n<blockquote>　　POST /accounts/1/transfer/500/to/2</blockquote>\r\n正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：\r\n<blockquote>　　POST /transaction HTTP/1.1\r\nHost: 127.0.0.1\r\n\r\nfrom=1&amp;to=2&amp;amount=500.00</blockquote>\r\n<strong>另一个设计误区，就是在URI中加入版本号</strong>：\r\n<blockquote>　　http://www.example.com/app/1.0/foo\r\n\r\nhttp://www.example.com/app/1.1/foo\r\n\r\nhttp://www.example.com/app/2.0/foo</blockquote>\r\n因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460" target="_blank">Versioning REST Services</a>）：\r\n<blockquote>　　Accept: vnd.example-com.foo+json; version=1.0\r\n\r\nAccept: vnd.example-com.foo+json; version=1.1\r\n\r\nAccept: vnd.example-com.foo+json; version=2.0</blockquote>\r\n（完）\r\n\r\n</div>\r\n</article>','理解RESTful架构','','publish','open','open','','restful','','','2016-11-01 18:14:12','2016-11-01 10:14:12','',0,'https://blog-scottwang.rhcloud.com/?p=95',0,'post','',0),
 (97,1,'2016-11-01 18:17:12','2016-11-01 10:17:12','from:\r\n<a href="http://www.ruanyifeng.com/blog/2011/09/curl.html">http://www.ruanyifeng.com/blog/2011/09/curl.html</a>\r\n\r\n<article class="hentry">\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n&nbsp;\r\n\r\n<a href="http://curl.haxx.se/" target="_blank">curl</a>是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在"标准输出"（stdout）上面。\r\n\r\n它支持多种协议，下面举例讲解如何将它用于网站开发。\r\n\r\n<strong>一、查看网页源码</strong>\r\n\r\n直接在curl命令后加上网址，就可以看到网页源码。我们以网址www.sina.com为例（选择该网址，主要因为它的网页代码较短）：\r\n<blockquote>　　$ curl www.sina.com</blockquote>\r\n<blockquote>　　&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;\r\n&lt;html&gt;&lt;head&gt;\r\n&lt;title&gt;301 Moved Permanently&lt;/title&gt;\r\n&lt;/head&gt;&lt;body&gt;\r\n&lt;h1&gt;Moved Permanently&lt;/h1&gt;\r\n&lt;p&gt;The document has moved &lt;a href="http://www.sina.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;\r\n&lt;/body&gt;&lt;/html&gt;</blockquote>\r\n如果要把这个网页保存下来，可以使用`-o`参数，这就相当于使用wget命令了。\r\n<blockquote>　　$ curl -o [文件名] www.sina.com</blockquote>\r\n<strong>二、自动跳转</strong>\r\n\r\n有的网址是自动跳转的。使用`-L`参数，curl就会跳转到新的网址。\r\n<blockquote>　　$ curl -L www.sina.com</blockquote>\r\n键入上面的命令，结果就自动跳转为www.sina.com.cn。\r\n\r\n<strong>三、显示头信息</strong>\r\n\r\n`-i`参数可以显示http response的头信息，连同网页代码一起。\r\n<blockquote>　　$ curl -i www.sina.com</blockquote>\r\n<blockquote>　　HTTP/1.0 301 Moved Permanently\r\nDate: Sat, 03 Sep 2011 23:44:10 GMT\r\nServer: Apache/2.0.54 (Unix)\r\nLocation: http://www.sina.com.cn/\r\nCache-Control: max-age=3600\r\nExpires: Sun, 04 Sep 2011 00:44:10 GMT\r\nVary: Accept-Encoding\r\nContent-Length: 231\r\nContent-Type: text/html; charset=iso-8859-1\r\nAge: 3239\r\nX-Cache: HIT from sh201-9.sina.com.cn\r\nConnection: close\r\n\r\n&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;\r\n&lt;html&gt;&lt;head&gt;\r\n&lt;title&gt;301 Moved Permanently&lt;/title&gt;\r\n&lt;/head&gt;&lt;body&gt;\r\n&lt;h1&gt;Moved Permanently&lt;/h1&gt;\r\n&lt;p&gt;The document has moved &lt;a href="http://www.sina.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;\r\n&lt;/body&gt;&lt;/html&gt;</blockquote>\r\n`-I`参数则是只显示http response的头信息。\r\n\r\n<strong>四、显示通信过程</strong>\r\n\r\n`-v`参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。\r\n<blockquote>　　$ curl -v www.sina.com</blockquote>\r\n<blockquote>　　* About to connect() to www.sina.com port 80 (#0)\r\n* Trying 61.172.201.195... connected\r\n* Connected to www.sina.com (61.172.201.195) port 80 (#0)\r\n&gt; GET / HTTP/1.1\r\n&gt; User-Agent: curl/7.21.3 (i686-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18\r\n&gt; Host: www.sina.com\r\n&gt; Accept: */*\r\n&gt;\r\n* HTTP 1.0, assume close after body\r\n&lt; HTTP/1.0 301 Moved Permanently\r\n&lt; Date: Sun, 04 Sep 2011 00:42:39 GMT\r\n&lt; Server: Apache/2.0.54 (Unix)\r\n&lt; Location: http://www.sina.com.cn/\r\n&lt; Cache-Control: max-age=3600\r\n&lt; Expires: Sun, 04 Sep 2011 01:42:39 GMT\r\n&lt; Vary: Accept-Encoding\r\n&lt; Content-Length: 231\r\n&lt; Content-Type: text/html; charset=iso-8859-1\r\n&lt; X-Cache: MISS from sh201-19.sina.com.cn\r\n&lt; Connection: close\r\n&lt;\r\n&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;\r\n&lt;html&gt;&lt;head&gt;\r\n&lt;title&gt;301 Moved Permanently&lt;/title&gt;\r\n&lt;/head&gt;&lt;body&gt;\r\n&lt;h1&gt;Moved Permanently&lt;/h1&gt;\r\n&lt;p&gt;The document has moved &lt;a href="http://www.sina.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;\r\n&lt;/body&gt;&lt;/html&gt;\r\n* Closing connection #0</blockquote>\r\n如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。\r\n<blockquote>　　$ curl --trace output.txt www.sina.com</blockquote>\r\n或者\r\n<blockquote>　　$ curl --trace-ascii output.txt www.sina.com</blockquote>\r\n运行后，请打开output.txt文件查看。\r\n\r\n<strong>五、发送表单信息</strong>\r\n\r\n发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。\r\n<blockquote>　　$ curl example.com/form.cgi?data=xxx</blockquote>\r\nPOST方法必须把数据和网址分开，curl就要用到--data参数。\r\n<blockquote>　　$ curl -X POST --data "data=xxx" example.com/form.cgi</blockquote>\r\n如果你的数据没有经过表单编码，还可以让curl为你编码，参数是`--data-urlencode`。\r\n<blockquote>　　$ curl -X POST--data-urlencode "date=April 1" example.com/form.cgi</blockquote>\r\n<strong>六、HTTP动词</strong>\r\n\r\ncurl默认的HTTP动词是GET，使用`-X`参数可以支持其他动词。\r\n<blockquote>　　$ curl -X POST www.example.com</blockquote>\r\n<blockquote>　　$ curl -X DELETE www.example.com</blockquote>\r\n<strong>七、文件上传</strong>\r\n\r\n假定文件上传的表单是下面这样：\r\n<blockquote>　　&lt;form method="POST" enctype=\'multipart/form-data\' action="upload.cgi"&gt;\r\n&lt;input type=file name=upload&gt;\r\n&lt;input type=submit name=press value="OK"&gt;\r\n&lt;/form&gt;</blockquote>\r\n你可以用curl这样上传文件：\r\n<blockquote>　　$ curl --form upload=@localfilename --form press=OK [URL]</blockquote>\r\n<strong>八、Referer字段</strong>\r\n\r\n有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。\r\n<blockquote>　　$ curl --referer http://www.example.com http://www.example.com</blockquote>\r\n<strong>九、User Agent字段</strong>\r\n\r\n这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。\r\n\r\niPhone4的User Agent是\r\n<blockquote>　　Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</blockquote>\r\ncurl可以这样模拟：\r\n<blockquote>　　$ curl --user-agent "[User Agent]" [URL]</blockquote>\r\n<strong>十、cookie</strong>\r\n\r\n使用`--cookie`参数，可以让curl发送cookie。\r\n<blockquote>　　$ curl --cookie "name=xxx" www.example.com</blockquote>\r\n至于具体的cookie的值，可以从http response头信息的`Set-Cookie`字段中得到。\r\n\r\n`-c cookie-file`可以保存服务器返回的cookie到文件，`-b cookie-file`可以使用这个文件作为cookie信息，进行后续的请求。\r\n<blockquote>　　$ curl -c cookies http://example.com\r\n$ curl -b cookies http://example.com</blockquote>\r\n<strong>十一、增加头信息</strong>\r\n\r\n有时需要在http request之中，自行增加一个头信息。`--header`参数就可以起到这个作用。\r\n<blockquote>　　$ curl --header "Content-Type:application/json" http://example.com</blockquote>\r\n<strong>十二、HTTP认证</strong>\r\n\r\n有些网域需要HTTP认证，这时curl需要用到`--user`参数。\r\n<blockquote>　　$ curl --user name:password example.com</blockquote>\r\n<strong>【参考资料】</strong>\r\n\r\n* <a href="http://curl.haxx.se/docs/httpscripting.html" target="_blank">Using cURL to automate HTTP jobs</a>\r\n\r\n* <a href="http://bbs.et8.net/bbs/showthread.php?t=568472" target="_blank">教你学用CURL</a>\r\n\r\n* <a href="https://httpkit.com/resources/HTTP-from-the-Command-Line/" target="_blank">9 uses for cURL worth knowing</a>\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','关于curl','','publish','open','open','','about-curl','','','2016-11-01 18:17:56','2016-11-01 10:17:56','',0,'https://blog-scottwang.rhcloud.com/?p=97',0,'post','',0),
 (100,1,'2016-11-01 18:56:10','2016-11-01 10:56:10','from:\r\n<a href="http://www.ruanyifeng.com/blog/2009/05/data_types_and_json.html">http://www.ruanyifeng.com/blog/2009/05/data_types_and_json.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n前几天，我才知道有一种简化的数据交换格式，叫做<a href="http://www.yaml.org/" target="_blank">yaml</a>。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n我翻了一遍它的<a href="http://www.yaml.org/spec/" target="_blank">文档</a>，看懂的地方不多，但是有一句话令我茅塞顿开。\r\n\r\n它说，<strong>从结构上看，所有的数据（data）最终都可以分解成三种类型</strong>：\r\n<blockquote>\r\n<div>\r\n\r\n第一种类型是<strong>标量</strong>（scalar），也就是一个单独的字符串（string）或数字（numbers），比如"北京"这个单独的词。\r\n\r\n第二种类型是<strong>序列</strong>（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如"北京，上海"。\r\n\r\n第三种类型是<strong>映射</strong>（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）或字典（dictionary），比如"首都：北京"。\r\n\r\n</div></blockquote>\r\n我恍然大悟，数据构成的最小单位原来如此简单！难怪在编程语言中，只要有了数组（array）和对象（object）就能够储存一切数据了。\r\n\r\n2.\r\n\r\n我马上想到了<a href="http://www.json.org/json-zh.html" target="_blank">json</a>。\r\n\r\n21世纪初，Douglas Crockford寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是XML，但是Douglas Crockford觉得XML的生成和解析都太麻烦，所以他提出了一种简化格式，也就是Json。\r\n\r\nJson的规格非常简单，只用一个页面几百个字就能说清楚，而且Douglas Crockford声称这个规格永远不必升级，因为该规定的都规定了。\r\n<blockquote>\r\n<div>\r\n\r\n1） 并列的数据之间用逗号（", "）分隔。\r\n\r\n2） 映射用冒号（": "）表示。\r\n\r\n3） 并列数据的集合（数组）用方括号("[]")表示。\r\n\r\n4） 映射的集合（对象）用大括号（"{}"）表示。\r\n\r\n</div></blockquote>\r\n上面四条规则，就是Json格式的所有内容。\r\n\r\n比如，下面这句话：\r\n<blockquote>\r\n<div>\r\n\r\n"北京市的面积为16800平方公里，常住人口1600万人。上海市的面积为6400平方公里，常住人口1800万。"\r\n\r\n</div></blockquote>\r\n写成json格式就是这样：\r\n<blockquote>\r\n<div>\r\n\r\n[\r\n{"城市":"北京","面积":16800,"人口":1600},\r\n{"城市":"上海","面积":6400,"人口":1800}\r\n]\r\n\r\n</div></blockquote>\r\n如果事先知道数据的结构，上面的写法还可以进一步简化：\r\n<blockquote>\r\n<div>\r\n\r\n[\r\n["北京",16800,1600],\r\n["上海",6400,1800]\r\n]\r\n\r\n</div></blockquote>\r\n由此可以看到，json非常易学易用。所以，在短短几年中，它就取代xml，成为了互联网上最受欢迎的数据交换格式。\r\n\r\n我猜想，Douglas Crockford一定事先就知道，数据结构可以简化成三种形式，否则怎么可能将json定义得如此精炼呢！\r\n\r\n3.\r\n\r\n学习javascript的时候，我曾经一度搞不清楚"数组"(array)和"对象"(object)的根本区别在哪里，两者都可以用来表示数据的集合。\r\n\r\n比如有一个数组a=[1,2,3,4]，还有一个对象a={0:1,1:2,2:3,3:4}，然后你运行alert(a[1])，两种情况下的运行结果是相同的！这就是说，数据集合既可以用数组表示，也可以用对象表示，那么我到底该用哪一种呢？\r\n\r\n我后来才知道，数组表示有序数据的集合，而对象表示无序数据的集合。如果数据的顺序很重要，就用数组，否则就用对象。\r\n\r\n4.\r\n\r\n当然，数组和对象的另一个区别是，数组的数据没有"名称"（name），对象的数据有"名称"（name）。\r\n\r\n但是问题是，很多编程语言中，都有一种叫做"关联数组"（associative array）的东西。这种数组中的数据是有名称的。\r\n\r\n比如在javascript中，可以这样定义一个对象：\r\n<blockquote>\r\n<div>\r\n\r\nvar a={"城市":"北京","面积":16800,"人口":1600};\r\n\r\n</div></blockquote>\r\n但是，也可以定义成一个关联数组：\r\n<blockquote>\r\n<div>\r\n\r\na["城市"]="北京";\r\na["面积"]=16800;\r\na["人口"]=1600;\r\n\r\n</div></blockquote>\r\n这起初也加剧了我对数组和对象的混淆，后来才明白，在Javascript语言中，关联数组就是对象，对象就是关联数组。这一点与php语言完全不同，在php中，关联数组也是数组。\r\n\r\n比如运行下面这段javascript：\r\n<blockquote>\r\n<div>\r\n\r\nvar a=[1,2,3,4];\r\n\r\na[\'foo\']=\'Hello World\';\r\n\r\nalert(a.length);\r\n\r\n</div></blockquote>\r\n最后的结果是4，也就是说，数组a的元素个数是4个。\r\n\r\n但是，运行同样内容的php代码就不一样了：\r\n<blockquote>\r\n<div>\r\n\r\n&lt;?php\r\n\r\n$a=array(1,2,3,4);\r\n\r\n$a["foo"]="Hello world";\r\n\r\necho count($a);\r\n\r\n?&gt;\r\n\r\n</div></blockquote>\r\n最后的结果是5，也就是说，数组a的元素个数是5个。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','数据类型和Json格式','','publish','open','open','','data-type-and-json','','','2016-11-01 18:56:10','2016-11-01 10:56:10','',0,'https://blog-scottwang.rhcloud.com/?p=100',0,'post','',0),
 (102,1,'2016-11-01 18:58:02','2016-11-01 10:58:02','from:\r\n<a href="http://www.ruanyifeng.com/blog/2009/03/tcp-ip_model.html">http://www.ruanyifeng.com/blog/2009/03/tcp-ip_model.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\nTCP/IP模型是互联网的基础。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n想要理解互联网，就必须理解<a href="http://en.wikipedia.org/wiki/TCP/IP_model" target="_blank">这个模型</a>。但是，它不好懂，我就从来没有搞懂过。\r\n\r\n前几天，<a href="http://betterexplained.com/articles/a-simple-introduction-to-computer-networking/" target="_blank">BetterExplained</a>上有一篇文章，很通俗地解释了这个模型。我读后有一种恍然大悟的感觉，第一次感到自己理解了互联网的总体架构。\r\n\r\n下面，我按照自己的理解，写一下互联网到底是怎么搭建起来的。说得不对的地方，欢迎指正。\r\n\r\n<strong>什么是TCP/IP模型？</strong>\r\n\r\nTCP/IP模型是一系列网络协议的总称，这些协议的目的，就是使计算机之间可以进行信息交换。\r\n\r\n所谓"协议"可以理解成机器之间交谈的语言，每一种协议都有自己的目的。TCP/IP模型一共包括几百种协议，对互联网上交换信息的各个方面都做了规定。\r\n\r\n<strong>TCP/IP模型的四层结构</strong>\r\n\r\n这些协议可以大致分成四个层次，上一层的协议都以下一层的协议为基础。就像下面这张图：\r\n\r\n<img src="http://lh4.ggpht.com/_6p3hNkUNWrQ/ScObKm-azpI/AAAAAAAAA78/52k38xkD9j4/s800/bg2009032002.jpg" />\r\n\r\n从下到上的四层，分别为连接层（Link Layer）、网络层（Internet Layer）、传输层（Transport Layer）、应用层（Application Layer）。\r\n\r\n可以这样理解它们的作用：\r\n<blockquote>\r\n<div>\r\n\r\n1）连接层负责建立<strong>电路连接</strong>，是整个网络的物理基础，典型的协议包括以太网、ADSL等等；\r\n\r\n2）网络层负责分配地址和传送<strong>二进制数据</strong>，主要协议是IP协议；\r\n\r\n3）传输层负责传送<strong>文本数据</strong>，主要协议是TCP协议；\r\n\r\n4）应用层负责传送各种<strong>最终形态的数据</strong>，是直接与用户打交道的层，典型协议是HTTP、FTP等。\r\n\r\n</div></blockquote>\r\n理解这个结构的关键，在于理解科学家在70年代设计互联网的原始目的，就是为了传输文本。所有协议最初都是为了这个目标而设计的，互联网架构的核心就是文本对话。\r\n\r\n<strong>实例：用Telnet建立HTTP对话</strong>\r\n\r\n为了观察文本在互联网上是如何传输的，我们做一个小实验。\r\n\r\n<strong>第一步：在"开始"菜单中，点击"运行"命令，输入"telnet google.com 80"。</strong>\r\n\r\n<img src="http://lh6.ggpht.com/_6p3hNkUNWrQ/ScObKQOp_yI/AAAAAAAAA70/8qHj3eH9SOQ/s800/bg2009032001.jpg" />\r\n\r\ntelnet命令本身就是一个应用层协议，它的作用是在两台主机间，建立一个TCP连接，也就是打开两台主机间文本传输的一个通道。\r\n\r\n"telnet google.com 80"表示建立本机与google.com在80端口的一个文本传输通道。所谓"端口"其实是TCP协议的一个参数，用来帮助TCP协议判断对方主机传来的文本，到底使用的是哪一种应用层协议。80端口是HTTP协议的端口，就是我们平时浏览网页的端口。常见端口列表可以参考<a href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers" target="_blank">这里</a>。\r\n\r\n另外，与Windows 2000和Windows XP不同，Vista系统默认没有安装Telnet客户端，大家可以参考微软公司的<a href="http://windowshelp.microsoft.com/Windows/zh-CN/Help/81b6d4b7-905e-4d70-8379-7934913fedb02052.mspx" target="_blank">安装说明</a>自行安装。如果你使用的是Linux系统，那么可以直接在命令行窗口中，输入上面的命令。\r\n\r\n<strong>第二步：打开本地显示。</strong>（非Windows系统跳过此步。）\r\n\r\n请按以下步骤操作：在Telnet窗口中按下"Ctrl+]"；然后，输入"set localecho"命令，再连续按下两次回车键。\r\n\r\n<img src="http://lh4.ggpht.com/_6p3hNkUNWrQ/ScObKqQ2ixI/AAAAAAAAA8E/y_bni9WGzUo/s800/bg2009032003.jpg" />\r\n\r\n好了，这个时候你就可以直接同google.com主机进行对话了。\r\n\r\n<strong>第三步：你可以试着同Google随便说句话，看看有什么反应。</strong>\r\n\r\n我输入了"Hello World！"。\r\n\r\n<img src="http://lh6.ggpht.com/_6p3hNkUNWrQ/ScObKqqEFiI/AAAAAAAAA8M/q7S2Htybp0k/s800/bg2009032004.jpg" />\r\n\r\n结果，Google的回答是这样的：\r\n\r\n<img src="http://lh5.ggpht.com/_6p3hNkUNWrQ/ScObK-x6ZBI/AAAAAAAAA8U/MZnptNO4lHg/s800/bg2009032005.jpg" />\r\n\r\n"400 Bad Request"说明Google看不懂你的发言。这是毫不奇怪的，因为这时你是在TCP文本通道中，进行HTTP对话。所以，你的发言必须遵守HTTP协议，这样Google才能看懂。\r\n\r\n<strong>第四步：输入"GET / HTTP/1.1"，表示向google索要首页根文件，使用的协议是HTTP的1.1版本。</strong>\r\n\r\nGoogle的回应如下：\r\n\r\n<img src="http://lh6.ggpht.com/_6p3hNkUNWrQ/ScObYMDOWuI/AAAAAAAAA8c/q5xB9qzAfyM/s800/bg2009032006.jpg" />\r\n\r\n"200 OK"表示要求数据成功。在头部信息的下面，就是google在浏览器中显示的首页文件的源代码。\r\n\r\n<strong>总结</strong>\r\n\r\n上面这个例子用的是HTTP协议，如果要使用其他"应用层协议"与主机进行对话，你只要改变端口就行了。比如，"telnet ftp.website.com 21"，表示用ftp协议进行对话。\r\n\r\n所有这些对话的底层协议，都是TCP协议，因为这是负责文本传输的协议；而TCP协议又必须依靠IP协议，进行二进制数据的传输；而二进制数据的传输，离不开最底层负责网络连接的物理协议。\r\n\r\n所以，通过这样四层的网络架构，就实现了整个互联网的通信。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','TCP/IP模型的简单解释','','publish','open','open','','tcpip-model','','','2016-11-01 18:58:02','2016-11-01 10:58:02','',0,'https://blog-scottwang.rhcloud.com/?p=102',0,'post','',0),
 (104,1,'2016-11-01 18:59:54','2016-11-01 10:59:54','from:\r\n<a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html">http://www.ruanyifeng.com/blog/2009/03/css_selectors.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<strong>一、基本选择器</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>1.</td>\r\n<td><strong>*</strong></td>\r\n<td>通用元素选择器，匹配任何元素</td>\r\n</tr>\r\n<tr>\r\n<td>2.</td>\r\n<td><strong>E</strong></td>\r\n<td>标签选择器，匹配所有使用E标签的元素</td>\r\n</tr>\r\n<tr>\r\n<td>3.</td>\r\n<td><strong>.info</strong></td>\r\n<td>class选择器，匹配所有class属性中包含info的元素</td>\r\n</tr>\r\n<tr>\r\n<td>4.</td>\r\n<td><strong>#footer</strong></td>\r\n<td>id选择器，匹配所有id属性等于footer的元素</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\n* { margin:0; padding:0; }\r\n\r\np { font-size:2em; }\r\n\r\n.info { background:#ff0; }\r\n\r\np.info { background:#ff0; }\r\n\r\np.info.error { color:#900; font-weight:bold; }\r\n\r\n#info { background:#ff0; }\r\n\r\np#info { background:#ff0; }\r\n\r\n</div></blockquote>\r\n<strong>二、多元素的组合选择器</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>5.</td>\r\n<td>E,F</td>\r\n<td>多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔</td>\r\n</tr>\r\n<tr>\r\n<td>6.</td>\r\n<td>E F</td>\r\n<td>后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔</td>\r\n</tr>\r\n<tr>\r\n<td>7.</td>\r\n<td>E &gt; F</td>\r\n<td>子元素选择器，匹配所有E元素的子元素F</td>\r\n</tr>\r\n<tr>\r\n<td>8.</td>\r\n<td>E + F</td>\r\n<td>毗邻元素选择器，匹配所有紧随E元素之后的同级元素F</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\ndiv p { color:#f00; }\r\n\r\n#nav li { display:inline; }\r\n\r\n#nav a { font-weight:bold; }\r\n\r\ndiv &gt; strong { color:#f00; }\r\n\r\np + p { color:#f00; }\r\n\r\n</div></blockquote>\r\n<strong>三、CSS 2.1 属性选择器</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>9.</td>\r\n<td>E[att]</td>\r\n<td>匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如"[cheacked]"。以下同。）</td>\r\n</tr>\r\n<tr>\r\n<td>10.</td>\r\n<td>E[att=val]</td>\r\n<td>匹配所有att属性等于"val"的E元素</td>\r\n</tr>\r\n<tr>\r\n<td>11.</td>\r\n<td>E[att~=val]</td>\r\n<td>匹配所有att属性具有多个空格分隔的值、其中一个值等于"val"的E元素</td>\r\n</tr>\r\n<tr>\r\n<td>12.</td>\r\n<td>E[att|=val]</td>\r\n<td>匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以"val"开头的E元素，主要用于lang属性，比如"en"、"en-us"、"en-gb"等等</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\np[title] { color:#f00; }\r\n\r\ndiv[class=error] { color:#f00; }\r\n\r\ntd[headers~=col1] { color:#f00; }\r\n\r\np[lang|=en] { color:#f00; }\r\n\r\nblockquote[class=quote][cite] { color:#f00; }\r\n\r\n</div></blockquote>\r\n<strong>四、CSS 2.1中的伪类</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>13.</td>\r\n<td>E:first-child</td>\r\n<td>匹配父元素的第一个子元素</td>\r\n</tr>\r\n<tr>\r\n<td>14.</td>\r\n<td>E:link</td>\r\n<td>匹配所有未被点击的链接</td>\r\n</tr>\r\n<tr>\r\n<td>15.</td>\r\n<td>E:visited</td>\r\n<td>匹配所有已被点击的链接</td>\r\n</tr>\r\n<tr>\r\n<td>16.</td>\r\n<td>E:active</td>\r\n<td>匹配鼠标已经其上按下、还没有释放的E元素</td>\r\n</tr>\r\n<tr>\r\n<td>17.</td>\r\n<td>E:hover</td>\r\n<td>匹配鼠标悬停其上的E元素</td>\r\n</tr>\r\n<tr>\r\n<td>18.</td>\r\n<td>E:focus</td>\r\n<td>匹配获得当前焦点的E元素</td>\r\n</tr>\r\n<tr>\r\n<td>19.</td>\r\n<td>E:lang(c)</td>\r\n<td>匹配lang属性等于c的E元素</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\np:first-child { font-style:italic; }\r\n\r\ninput[type=text]:focus { color:#000; background:#ffe; }\r\n\r\ninput[type=text]:focus:hover { background:#fff; }\r\n\r\nq:lang(sv) { quotes: "\\201D" "\\201D" "\\2019" "\\2019"; }\r\n\r\n</div></blockquote>\r\n<strong>五、 CSS 2.1中的伪元素</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>20.</td>\r\n<td>E:first-line</td>\r\n<td>匹配E元素的第一行</td>\r\n</tr>\r\n<tr>\r\n<td>21.</td>\r\n<td>E:first-letter</td>\r\n<td>匹配E元素的第一个字母</td>\r\n</tr>\r\n<tr>\r\n<td>22.</td>\r\n<td>E:before</td>\r\n<td>在E元素之前插入生成的内容</td>\r\n</tr>\r\n<tr>\r\n<td>23.</td>\r\n<td>E:after</td>\r\n<td>在E元素之后插入生成的内容</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\np:first-line { font-weight:bold; color;#600; }\r\n\r\n.preamble:first-letter { font-size:1.5em; font-weight:bold; }\r\n\r\n.cbb:before { content:""; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; }\r\n\r\na:link:after { content: " (" attr(href) ") "; }\r\n\r\n</div></blockquote>\r\n<strong>六、CSS 3的同级元素通用选择器</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>24.</td>\r\n<td>E ~ F</td>\r\n<td>匹配任何在E元素之后的同级F元素</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\np ~ ul { background:#ff0; }\r\n\r\n</div></blockquote>\r\n<strong>七、CSS 3 属性选择器</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>25.</td>\r\n<td>E[att^="val"]</td>\r\n<td>属性att的值以"val"开头的元素</td>\r\n</tr>\r\n<tr>\r\n<td>26.</td>\r\n<td>E[att$="val"]</td>\r\n<td>属性att的值以"val"结尾的元素</td>\r\n</tr>\r\n<tr>\r\n<td>27.</td>\r\n<td>E[att*="val"]</td>\r\n<td>属性att的值包含"val"字符串的元素</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\ndiv[id^="nav"] { background:#ff0; }\r\n\r\n</div></blockquote>\r\n<strong>八、CSS 3中与用户界面有关的伪类</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>28.</td>\r\n<td>E:enabled</td>\r\n<td>匹配表单中激活的元素</td>\r\n</tr>\r\n<tr>\r\n<td>29.</td>\r\n<td>E:disabled</td>\r\n<td>匹配表单中禁用的元素</td>\r\n</tr>\r\n<tr>\r\n<td>30.</td>\r\n<td>E:checked</td>\r\n<td>匹配表单中被选中的radio（单选框）或checkbox（复选框）元素</td>\r\n</tr>\r\n<tr>\r\n<td>31.</td>\r\n<td>E::selection</td>\r\n<td>匹配用户当前选中的元素</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\ninput[type="text"]:disabled { background:#ddd; }\r\n\r\n</div></blockquote>\r\n<strong>九、CSS 3中的结构性伪类</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>32.</td>\r\n<td>E:root</td>\r\n<td>匹配文档的根元素，对于HTML文档，就是HTML元素</td>\r\n</tr>\r\n<tr>\r\n<td>33.</td>\r\n<td>E:nth-child(n)</td>\r\n<td>匹配其父元素的第n个子元素，第一个编号为1</td>\r\n</tr>\r\n<tr>\r\n<td>34.</td>\r\n<td>E:nth-last-child(n)</td>\r\n<td>匹配其父元素的倒数第n个子元素，第一个编号为1</td>\r\n</tr>\r\n<tr>\r\n<td>35.</td>\r\n<td>E:nth-of-type(n)</td>\r\n<td>与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>\r\n</tr>\r\n<tr>\r\n<td>36.</td>\r\n<td>E:nth-last-of-type(n)</td>\r\n<td>与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>\r\n</tr>\r\n<tr>\r\n<td>37.</td>\r\n<td>E:last-child</td>\r\n<td>匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>\r\n</tr>\r\n<tr>\r\n<td>38.</td>\r\n<td>E:first-of-type</td>\r\n<td>匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>\r\n</tr>\r\n<tr>\r\n<td>39.</td>\r\n<td>E:last-of-type</td>\r\n<td>匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>\r\n</tr>\r\n<tr>\r\n<td>40.</td>\r\n<td>E:only-child</td>\r\n<td>匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>\r\n</tr>\r\n<tr>\r\n<td>41.</td>\r\n<td>E:only-of-type</td>\r\n<td>匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>\r\n</tr>\r\n<tr>\r\n<td>42.</td>\r\n<td>E:empty</td>\r\n<td>匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\np:nth-child(3) { color:#f00; }\r\n\r\np:nth-child(odd) { color:#f00; }\r\n\r\np:nth-child(even) { color:#f00; }\r\n\r\np:nth-child(3n+0) { color:#f00; }\r\n\r\np:nth-child(3n) { color:#f00; }\r\n\r\ntr:nth-child(2n+11) { background:#ff0; }\r\n\r\ntr:nth-last-child(2) { background:#ff0; }\r\n\r\np:last-child { background:#ff0; }\r\n\r\np:only-child { background:#ff0; }\r\n\r\np:empty { background:#ff0; }\r\n\r\n</div></blockquote>\r\n<strong>十、CSS 3的反选伪类</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>43.</td>\r\n<td>E:not(s)</td>\r\n<td>匹配不符合当前选择器的任何元素</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n实例：\r\n<blockquote>\r\n<div>\r\n\r\n:not(p) { border:1px solid #ccc; }\r\n\r\n</div></blockquote>\r\n<strong>十一、CSS 3中的 :target 伪类</strong>\r\n<table style="width: 500px; text-align: center;" border="1">\r\n<tbody>\r\n<tr>\r\n<td>序号</td>\r\n<td>选择器</td>\r\n<td>含义</td>\r\n</tr>\r\n<tr>\r\n<td>44.</td>\r\n<td>E:target</td>\r\n<td>匹配文档中特定"id"点击后的效果</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n请参看HTML DOG上关于该选择器的<a href="http://htmldog.com/articles/suckerfish/target/" target="_blank">详细解释</a>和<a href="http://htmldog.com/articles/suckerfish/target/example/" target="_blank">实例</a>。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','CSS选择器笔记','','publish','open','open','','css-selector','','','2016-11-01 18:59:54','2016-11-01 10:59:54','',0,'https://blog-scottwang.rhcloud.com/?p=104',0,'post','',0),
 (106,1,'2016-11-01 19:01:45','2016-11-01 11:01:45','from:\r\n<a href="http://www.ruanyifeng.com/blog/2009/07/xpath_path_expressions.html">http://www.ruanyifeng.com/blog/2009/07/xpath_path_expressions.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n简单说，xpath就是选择XML文件中节点的方法。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n所谓节点（node），就是XML文件的最小构成单位，一共分成7种。\r\n<blockquote>\r\n<div>\r\n\r\n- element（元素节点）\r\n- attribute（属性节点）\r\n- text （文本节点）\r\n- namespace （名称空间节点）\r\n- processing-instruction （处理命令节点）\r\n- comment （注释节点）\r\n- root （根节点）\r\n\r\n</div></blockquote>\r\nxpath可以用来选择这7种节点。不过，下面的笔记只涉及最常用的第一种element（元素节点），因此可以将下文中的节点和元素视为同义词。\r\n\r\n<strong>一、xpath表达式的基本格式</strong>\r\n\r\nxpath通过"路径表达式"（Path Expression）来选择节点。在形式上，"路径表达式"与传统的文件系统非常类似。\r\n<blockquote>\r\n<div>\r\n\r\n# 斜杠（/）作为路径内部的分割符。\r\n\r\n# 同一个节点有绝对路径和相对路径两种写法。\r\n\r\n# 绝对路径（absolute path）必须用"/"起首，后面紧跟根节点，比如/step/step/...。\r\n\r\n# 相对路径（relative path）则是除了绝对路径以外的其他写法，比如 step/step，也就是不使用"/"起首。\r\n\r\n# "."表示当前节点。\r\n\r\n# ".."表示当前节点的父节点\r\n\r\n</div></blockquote>\r\n<strong>二、选择节点的基本规则</strong>\r\n<blockquote>\r\n<div>\r\n\r\n- nodename（节点名称）：表示选择该节点的所有子节点\r\n\r\n- "/"：表示选择根节点\r\n\r\n- "//"：表示选择任意位置的某个节点\r\n\r\n- "@"： 表示选择某个属性\r\n\r\n</div></blockquote>\r\n<strong>三、选择节点的实例</strong>\r\n\r\n先看一个XML实例文档。\r\n<blockquote>\r\n<div>\r\n\r\n&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;\r\n\r\n&lt;bookstore&gt;\r\n\r\n&lt;book&gt;\r\n&lt;title lang="eng"&gt;Harry Potter&lt;/title&gt;\r\n&lt;price&gt;29.99&lt;/price&gt;\r\n&lt;/book&gt;\r\n\r\n&lt;book&gt;\r\n&lt;title lang="eng"&gt;Learning XML&lt;/title&gt;\r\n&lt;price&gt;39.95&lt;/price&gt;\r\n&lt;/book&gt;\r\n\r\n&lt;/bookstore&gt;\r\n\r\n</div></blockquote>\r\n[例1]\r\n\r\nbookstore ：选取 bookstore 元素的所有子节点。\r\n\r\n[例2]\r\n\r\n/bookstore ：选取根节点bookstore，这是绝对路径写法。\r\n\r\n[例3]\r\n\r\nbookstore/book ：选取所有属于 bookstore 的子元素的 book元素，这是相对路径写法。\r\n\r\n[例4]\r\n\r\n//book ：选择所有 book 子元素，而不管它们在文档中的位置。\r\n\r\n[例5]\r\n\r\nbookstore//book ：选择所有属于 bookstore 元素的后代的 book 元素，而不管它们位于 bookstore 之下的什么位置。\r\n\r\n[例6]\r\n\r\n//@lang ：选取所有名为 lang 的属性。\r\n\r\n<strong>四、xpath的谓语条件（Predicate）</strong>\r\n\r\n所谓"谓语条件"，就是对路径表达式的附加条件。\r\n\r\n所有的条件，都写在方括号"[]"中，表示对节点进行进一步的筛选。\r\n\r\n[例7]\r\n\r\n/bookstore/book[1] ：表示选择bookstore的第一个book子元素。\r\n\r\n[例8]\r\n\r\n/bookstore/book[last()] ：表示选择bookstore的最后一个book子元素。\r\n\r\n[例9]\r\n\r\n/bookstore/book[last()-1] ：表示选择bookstore的倒数第二个book子元素。\r\n\r\n[例10]\r\n\r\n/bookstore/book[position()&lt;3] ：表示选择bookstore的前两个book子元素。\r\n\r\n[例11]\r\n\r\n//title[@lang] ：表示选择所有具有lang属性的title节点。\r\n\r\n[例12]\r\n\r\n//title[@lang=\'eng\'] ：表示选择所有lang属性的值等于"eng"的title节点。\r\n\r\n[例13]\r\n\r\n/bookstore/book[price] ：表示选择bookstore的book子元素，且被选中的book元素必须带有price子元素。\r\n\r\n[例14]\r\n\r\n/bookstore/book[price&gt;35.00] ：表示选择bookstore的book子元素，且被选中的book元素的price子元素值必须大于35。\r\n\r\n[例15]\r\n\r\n/bookstore/book[price&gt;35.00]/title ：表示在例14结果集中，选择title子元素。\r\n\r\n[例16]\r\n\r\n/bookstore/book/price[.&gt;35.00] ：表示选择值大于35的"/bookstore/book"的price子元素。\r\n\r\n<strong>五、通配符</strong>\r\n<blockquote>\r\n<div>\r\n\r\n# "*"表示匹配任何元素节点。\r\n\r\n# "@*"表示匹配任何属性值。\r\n\r\n# node()表示匹配任何类型的节点。\r\n\r\n</div></blockquote>\r\n[例17]\r\n\r\n//* ：选择文档中的所有元素节点。\r\n\r\n[例18]\r\n\r\n/*/* ：表示选择所有第二层的元素节点。\r\n\r\n[例19]\r\n\r\n/bookstore/* ：表示选择bookstore的所有元素子节点。\r\n\r\n[例20]\r\n\r\n//title[@*] ：表示选择所有带有属性的title元素。\r\n\r\n<strong>六、选择多个路径</strong>\r\n\r\n用"|"选择多个并列的路径。\r\n\r\n[例21]\r\n\r\n//book/title | //book/price ：表示同时选择book元素的title子元素和price子元素。\r\n\r\n【相关文章】\r\n\r\n* <a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank">CSS选择器笔记</a>\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','xpath路径表达式笔记','','publish','open','open','','xpath-impression','','','2016-11-01 19:01:45','2016-11-01 11:01:45','',0,'https://blog-scottwang.rhcloud.com/?p=106',0,'post','',0),
 (108,1,'2016-11-01 19:03:23','2016-11-01 11:03:23','from:\r\n<a href="http://www.ruanyifeng.com/blog/2010/03/cross-browser_css3_features.html">http://www.ruanyifeng.com/blog/2010/03/cross-browser_css3_features.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n随着浏览器的升级，CSS3已经可以投入实际应用了。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n但是，不同的浏览器有不同的CSS3实现，兼容性是一个大问题。上周的<a href="http://developer.yahoo.net/blog/archives/2010/03/tech_thursday_css3_please_trojans_via_usb_ibm_visualization_engine_and_mosaic_source_code.html" target="_blank">YDN</a>介绍了<a href="http://css3please.com/" target="_blank">CSS3 Please</a>网站，该网站总结了一些常用功能的写法。\r\n\r\n以下就是这些写法的详细介绍。所有代码都经过了Firefox 3.6和IE 8.0的验证，原文的错误之处也已得到改正。\r\n\r\n<strong>一、圆角（Rounded Corner）</strong>\r\n\r\n<img src="http://image.beekka.com/blog/miscellaneous/bg2010031501.png" />\r\n<blockquote>\r\n<div>\r\n\r\n.box_round {\r\n\r\n-moz-border-radius: 30px; /* FF1+ */\r\n\r\n-webkit-border-radius: 30px; /* Saf3+, Chrome */\r\n\r\nborder-radius: 30px; /* Opera 10.5, IE 9 */\r\n\r\n}\r\n\r\n</div></blockquote>\r\n圆角的实现比较简单，只要设好一个半径值就可以了。遗憾的是，目前所有的IE都不支持CSS圆角，要等到IE 9才行。\r\n\r\n<strong>二、盒状阴影（Box Shadow）</strong>\r\n\r\n<img src="http://image.beekka.com/blog/miscellaneous/bg2010031502.png" />\r\n<blockquote>\r\n<div>\r\n\r\n.box_shadow {\r\n\r\n-moz-box-shadow: 3px 3px 4px #ffffff; /* FF3.5+ */\r\n\r\n-webkit-box-shadow: 3px 3px 4px #ffffff; /* Saf3.0+, Chrome */\r\n\r\nbox-shadow: 3px 3px 4px #ffffff; /* Opera 10.5, IE 9.0 */\r\n\r\nfilter: progid:DXImageTransform.Microsoft.dropshadow(OffX=3px, OffY=3px, Color=\'#ffffff\'); /* IE6,IE7 */\r\n\r\n-ms-filter: "progid:DXImageTransform.Microsoft.dropshadow(OffX=3px, OffY=3px, Color=\'#ffffff\')"; /* IE8 */\r\n}\r\n\r\n</div></blockquote>\r\n-moz-box-shadow、-webkit-box-shadow和box-shadow的设置是一样的，都有4个参数，含义分别为：x轴偏移值、y轴偏移值、阴影的模糊度、以及阴影颜色。\r\n\r\nIE 6~8使用其独有的滤镜，需要设置三个参数：offX（X轴偏移值）、offY（Y轴偏移值）、Color（阴影颜色）。\r\n\r\n<strong>三、线性渐变（Gradient）</strong>\r\n\r\n<img src="http://image.beekka.com/blog/miscellaneous/bg2010031503.png" />\r\n<blockquote>\r\n<div>\r\n\r\n.box_gradient {\r\n\r\nbackground-image: -moz-linear-gradient(top, #444444, #999999); /* FF3.6 */\r\n\r\nbackground-image: -webkit-gradient(linear,left top, left bottom, color-stop(0, #444444),color-stop(1, #999999)); /* Saf4+, Chrome */\r\n\r\nfilter: progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#444444\', endColorstr=\'#999999\', GradientType=\'0\'); /* IE6,IE7 */\r\n\r\n-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#444444\', endColorstr=\'#999999\',GradientType=\'0\')"; /* IE8 */\r\n\r\n}\r\n\r\n</div></blockquote>\r\n先看Firefox。\r\n<blockquote>\r\n<div>\r\n\r\n-moz-linear-gradient(top, #444444, #999999);\r\n\r\n</div></blockquote>\r\n-moz-linear-gradient有三个参数。第一个参数表示线性渐变的方向，top是从上到下、left是从左到右，如果定义成left top，那就是从左上角到右下角。第二个和第三个参数分别是起点颜色和终点颜色。你还可以在它们之间插入更多的参数，表示多种颜色的渐变。\r\n<blockquote>\r\n<div>\r\n\r\n-webkit-gradient(linear,left top, left bottom, color-stop(0, #444444),color-stop(1, #999999));\r\n\r\n</div></blockquote>\r\n-webkit-gradient是webkit引擎对渐变的实现，一共有五个参数。第一个参数表示渐变类型（type），可以是linear（线性渐变）或者radial（辐射渐变）。第二个参数和第三个参数，都是一对值，分别表示渐变起点和终点。这对值可以用坐标形式表示，也可以用关键值表示，比如left top（左上角）和left bottom（左下角）。第四个和第五个参数，分别是两个color-stop函数。color-stop函数接受两个参数，第一个表示渐变的位置，0为起点，0.5为中点，1为结束点；第二个表示该点的颜色。\r\n<blockquote>\r\n<div>\r\n\r\nDXImageTransform.Microsoft.gradient(startColorstr=\'#444444\', endColorstr=\'#999999\', GradientType=\'0\');\r\n\r\n</div></blockquote>\r\nIE依靠滤镜实现渐变。startColorstr表示起点的颜色，endColorstr表示终点颜色。GradientType表示渐变类型，0为缺省值，表示垂直渐变，1表示水平渐变。\r\n\r\n<strong>四、透明（opacity）</strong>\r\n\r\n正常情况下，上层的对象会覆盖下层的对象。\r\n\r\n<img src="http://image.beekka.com/blog/miscellaneous/bg2010031504.png" />\r\n\r\n但是，如果将上层对象的颜色变为透明，就可以透过它看到下层对象。\r\n\r\n<img src="http://image.beekka.com/blog/miscellaneous/bg2010031505.png" />\r\n<blockquote>\r\n<div>\r\n\r\n.box_rgba {\r\n\r\nbackground-color: #B4B490;\r\n\r\nbackground:transparent;\r\n\r\nfilter: progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#99B4B490\',endColorstr=\'#99B4B490\'); /* IE6,IE7 */\r\n\r\n-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#99B4B490\',endColorstr=\'#99B4B490\')"; /* IE8 */\r\n\r\nzoom: 1;\r\n\r\nbackground-color: rgba(180, 180, 144, 0.6); /* FF3+, Saf3+, Opera 10.10+, Chrome */\r\n\r\n}\r\n\r\n</div></blockquote>\r\n先看第一行。\r\n<blockquote>\r\n<div>\r\n\r\nbackground-color: #B4B490;\r\n\r\n</div></blockquote>\r\n这是设置对象的预备色，也就是不透明时的颜色。如果浏览器不支持透明，就将显示这个颜色。\r\n<blockquote>\r\n<div>\r\n\r\nbackground:transparent;\r\n\r\nfilter: progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#99B4B490\',endColorstr=\'#99B4B490\'); /* IE6,IE7 */\r\n\r\n-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#99B4B490\',endColorstr=\'#99B4B490\')"; /* IE8 */\r\n\r\nzoom: 1;\r\n\r\n</div></blockquote>\r\n这几行是专门为IE写的，其中主要用到 DXImageTransform.Microsoft.gradient滤镜。我们要为它设置起点色（startColorstr）和终点色（endColorstr）。在单色透明的情况下，这两个值是相同的。需要注意的是，它们的取值是一个八位的十六进制值，前两位表示alpha通道值，00表示完全透明，FF表示完全不透明；后六位则是这个颜色的RGB值。\r\n<blockquote>\r\n<div>\r\n\r\nbackground-color: rgba(180, 180, 144, 0.6);\r\n\r\n</div></blockquote>\r\n除了IE，其他浏览器几乎都支持rgba函数。它有四个参数，前三个为一种颜色的RGB值，第四个为透明度，这里设为0.6。\r\n\r\n<strong>五、旋转（rotation）</strong>\r\n\r\n<img src="http://image.beekka.com/blog/miscellaneous/bg2010031506.png" />\r\n<blockquote>\r\n<div>\r\n\r\n.box_rotate {\r\n\r\n-moz-transform: rotate(7.5deg); /* FF3.5+ */\r\n\r\n-o-transform: rotate(7.5deg); /* Opera 10.5 */\r\n\r\n-webkit-transform: rotate(7.5deg); /* Saf3.1+, Chrome */\r\n\r\nfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.9914,M12=-0.1305,M21=0.1305,M22=0.9914,SizingMethod=\'auto expand\');\r\n\r\n-ms-filter: "progid:DXImageTransform.Microsoft.Matrix(M11=0.9914,M12=-0.1305,M21=0.1305,M22=0.9914,SizingMethod=\'auto expand\')"; /* IE8 */\r\n\r\n}\r\n\r\n</div></blockquote>\r\n除了IE以外，其他浏览器都是用rotate函数，实现某个对象的旋转。比如rotate(7.5deg)就表示顺时针旋转7.5度（degree）。\r\n\r\nIE则需要用到一个复杂的滤镜DXImageTransform.Microsoft.Matrix。它一共接受五个参数，前四个参数需要自行计算三角函数，然后分别写成M11 = cos(rotation),M12 = -sin(rotation),M21 = sin(rotation),M22 = cos(rotation)，其中的rotation表示旋转角度，如果顺时针旋转7.5度，则rotation就为7.5；第五个参数SizingMethod表示重绘方式，\'auto expand\'代表自动扩展到新的边界。\r\n\r\n除了这个滤镜，IE还有一个稍微简单一点的滤镜DXImageTransform.Microsoft.BasicImage(rotation=x)。其中的x只能取值为1，2，3，0，分别表示顺时针选择90度、180度、270度和360度。\r\n\r\n<strong>六、服务器端字体（font-face）</strong>\r\n\r\n设计网页的时候，可能会用到某种特殊的字体。如果用户的机器中没有安装，文字只能以普通字体显示。\r\n\r\n<img src="http://image.beekka.com/blog/miscellaneous/bg2010031507.png" />\r\n\r\n这时可以让用户的浏览器自行下载服务器端字体，然后就能呈现出设计者想要的效果。\r\n\r\n<img src="http://image.beekka.com/blog/miscellaneous/bg2010031508.png" />\r\n<blockquote>\r\n<div>\r\n\r\n@font-face {\r\n\r\nfont-family: \'MyFont\';\r\n\r\nsrc: url(\'myfont.eot\'); /* IE6+ */\r\n\r\nsrc: local(\'myfont.ttf\'),\r\n\r\nurl(\'myfont.woff\') format(\'woff\'), /* FF3.6 */\r\n\r\nurl(\'myfont.ttf\') format(\'truetype\'); /* FF3.5+, Saf3+,Chrome,Opera10+ */\r\n\r\n}\r\n\r\n</div></blockquote>\r\n第一行代码：\r\n<blockquote>\r\n<div>\r\n\r\nfont-family: \'MyFont\';\r\n\r\n</div></blockquote>\r\n表示为这种字体起一个名称，可以随意设置，我这里用的是MyFont。\r\n<blockquote>\r\n<div>\r\n\r\nsrc: url(\'myfont.eot\');\r\n\r\n</div></blockquote>\r\n这一行表示字体位置，由于ie只支持服务器端的<a href="http://en.wikipedia.org/wiki/Embedded_OpenType" target="_blank">eot字体</a>，所以这一行是ie专用的。\r\n<blockquote>\r\n<div>\r\n\r\nsrc: local(\'myfont.ttf\'),\r\n\r\nurl(\'myfont.woff\') format(\'woff\'),\r\n\r\nurl(\'myfont.ttf\') format(\'truetype\');\r\n\r\n</div></blockquote>\r\nlocal()表示在本机（客户端）查找该字体，如果本机已经安装了，就不用下载了。url()表示字体在服务器上的位置，format()用来说明字体格式。Firefox 3.5支持TrueType和OpenType字体，Firefox 3.6又增加了WOFF字体。其他基于Webkit引擎的浏览器（sarif，opera、chrome），目前好像只支持truetype。\r\n\r\n然后，使用的时候这样写就可以了。\r\n<blockquote>\r\n<div>\r\n\r\nh2{ font-family: "MyFont"; }\r\n\r\n</div></blockquote>\r\n需要注意的是，字体文件必须与网页文件来自同一个域名，符合浏览器的"同源政策"。另外，由于中文字体文件太大，服务器端字体显然只适用于英文字体。\r\n\r\n<strong>七、其他</strong>\r\n\r\n利用css3，还可以完成transform（变形），包括skew（扭曲）和scale（缩放），以及css transitions（动态变换）。这些内容待以后再补充。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','CSS3常用功能的写法','','publish','open','open','','css3-features','','','2016-11-01 19:03:23','2016-11-01 11:03:23','',0,'https://blog-scottwang.rhcloud.com/?p=108',0,'post','',0),
 (110,1,'2016-11-01 19:04:48','2016-11-01 11:04:48','from:\r\n<a href="http://www.ruanyifeng.com/blog/2010/03/css_cookbook.html">http://www.ruanyifeng.com/blog/2010/03/css_cookbook.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n在修改模板的过程中，需要重写CSS样式表。正好看到<a href="http://www.instantshift.com/2010/03/15/47-css-tips-tricks-to-take-your-site-to-the-next-level/" target="_blank">instantshift.com</a>有一篇CSS常用技巧的总结文章，我就把它整理出来，供自己参考，也希望对大家有用。\r\n\r\n未来，本文将持续更新。\r\n\r\n<img src="http://image.beekka.com/blog/miscellaneous/bg2010033103.jpg" />\r\n\r\n<strong>1. 文字的水平居中</strong>\r\n\r\n将一段文字置于容器的水平中点，只要设置text-align属性即可：\r\n<blockquote>\r\n<div>\r\n\r\n　　text-align:center;\r\n\r\n</div></blockquote>\r\n<strong>2. 容器的水平居中</strong>\r\n\r\n先为该容器设置一个明确宽度，然后将margin的水平值设为auto即可。\r\n<blockquote>\r\n<div>\r\n\r\n　　div#container {\r\nwidth:760px;\r\nmargin:0 auto;\r\n}\r\n\r\n</div></blockquote>\r\n<strong>3. 文字的垂直居中</strong>\r\n\r\n单行文字的垂直居中，只要将行高与容器高设为相等即可。\r\n\r\n比如，容器中有一行数字。\r\n<blockquote>\r\n<div>\r\n\r\n　　&lt;div id="container"&gt;1234567890&lt;/div&gt;\r\n\r\n</div></blockquote>\r\n然后CSS这样写：\r\n<blockquote>\r\n<div>\r\n\r\n　　div#container {height: 35px; line-height: 35px;}\r\n\r\n</div></blockquote>\r\n如果有n行文字，那么将行高设为容器高度的n分之一即可。\r\n\r\n<strong>4. 容器的垂直居中</strong>\r\n\r\n比如，有一大一小两个容器，请问如何将小容器<a href="http://blog.themeforest.net/tutorials/vertical-centering-with-css/" target="_blank">垂直居中</a>？\r\n<blockquote>\r\n<div>\r\n\r\n　　&lt;div id="big"&gt;\r\n&lt;div id="small"&gt;\r\n&lt;/div&gt;\r\n&lt;/div&gt;\r\n\r\n</div></blockquote>\r\n首先，将大容器的定位为relative。\r\n<blockquote>\r\n<div>\r\n\r\n　　div#big{\r\nposition:relative;\r\nheight:480px;\r\n}\r\n\r\n</div></blockquote>\r\n然后，将小容器定位为absolute，再将它的左上角沿y轴下移50%，最后将它margin-top上移本身高度的50%即可。\r\n<blockquote>\r\n<div>\r\n\r\n　　div#small {\r\nposition: absolute;\r\ntop: 50%;\r\nheight: 240px;\r\nmargin-top: -120px;\r\n}\r\n\r\n</div></blockquote>\r\n使用同样的思路，也可以做出水平居中的效果。\r\n\r\n<strong>5. 图片宽度的自适应</strong>\r\n\r\n如何使得较大的图片，能够自动适应小容器的宽度？CSS可以这样写：\r\n<blockquote>\r\n<div>\r\n\r\n　　img {max-width: 100%}\r\n\r\n</div></blockquote>\r\n但是IE6不支持max-width，所以遇到IE6时，使用<a href="http://www.quirksmode.org/css/condcom.html" target="_blank">IE条件注释</a>，将语句改写为：\r\n<blockquote>\r\n<div>\r\n\r\n　　img {width: 100%}\r\n\r\n</div></blockquote>\r\n<strong>6. 3D按钮</strong>\r\n\r\n要使按钮具有<a href="http://www.vanseodesign.com/css/css-navigation-buttons/" target="_blank">3D效果</a>，只要将它的左上部边框设为浅色，右下部边框设为深色即可。\r\n<blockquote>\r\n<div>\r\n\r\n　　div#button {\r\nbackground: #888;\r\nborder: 1px solid;\r\nborder-color: #999 #777 #777 #999;\r\n}\r\n\r\n</div></blockquote>\r\n<strong>7. font属性的快捷写法</strong>\r\n\r\nfont快捷写法的格式为：\r\n<blockquote>\r\n<div>\r\n\r\n　　body {\r\nfont: font-style font-variant font-weight font-size line-height font-family;\r\n}\r\n\r\n</div></blockquote>\r\n所以，\r\n<blockquote>\r\n<div>\r\n\r\n　　body {\r\nfont-family: Arial, Helvetica, sans-serif;\r\nfont-size: 13px;\r\nfont-weight: normal;\r\nfont-variant: small-caps;\r\nfont-style: italic;\r\nline-height: 150%;\r\n}\r\n\r\n</div></blockquote>\r\n可以被写成：\r\n<blockquote>\r\n<div>\r\n\r\n　　body {\r\nfont: italic small-caps normal 13px/150% Arial, Helvetica, sans-serif;\r\n}\r\n\r\n</div></blockquote>\r\n<strong>8. link状态的设置顺序</strong>\r\n\r\nlink的四种状态，需要按照下面的前后顺序进行设置：\r\n<blockquote>\r\n<div>\r\n\r\n　　a:link\r\na:visited\r\na:hover\r\na:active\r\n\r\n</div></blockquote>\r\n<strong>9. IE条件注释</strong>\r\n\r\n你可以利用条件注释，设置只对IE产生作用的语句：\r\n<blockquote>\r\n<div>\r\n\r\n　　&lt;!--[if IE]&gt;\r\n&lt;link rel="stylesheet" type="text/css" href="ie-stylesheet.css" /&gt;\r\n&lt; ![endif]--&gt;\r\n\r\n</div></blockquote>\r\n还可以区分各种不同的IE版本：\r\n<blockquote>\r\n<div>\r\n\r\n　　&lt;!--[if IE 6]&gt; - targets IE6 only --&gt;\r\n&lt;!--[if gt IE 6]&gt; - targets IE7 and above --&gt;\r\n&lt;!--[if lt IE 6]&gt; - targets IE5.5 and below --&gt;\r\n&lt;!--[if gte IE 6]&gt; - targets IE6 and above --&gt;\r\n&lt;!--[if lte IE 6]&gt; - targets IE6 and below --&gt;\r\n\r\n</div></blockquote>\r\n<strong>10. IE6专用语句：方法一</strong>\r\n\r\n由于IE6不把html视为文档的根元素，所以利用这一点，可以写出只有IE6才能读到的语句：\r\n<blockquote>\r\n<div>\r\n\r\n　　/* the following rules apply only to IE6 */\r\n\r\n* html{\r\n}\r\n\r\n* html body{\r\n}\r\n\r\n* html .foo{\r\n}\r\n\r\n</div></blockquote>\r\nIE7专用语句则要写成\r\n<blockquote>\r\n<div>\r\n\r\n　　/* the following rules apply only to IE7 */\r\n\r\n*+html .foo{\r\n}\r\n\r\n</div></blockquote>\r\n<strong>11. IE专用语句：方法二</strong>\r\n\r\n除了IE6以外，所有浏览器都不能识别属性前的下划线。而除了IE7之外，所有浏览器都不能识别属性前的*号，因此可以写出只有这两个浏览器才能读到的语句：\r\n<blockquote>\r\n<div>\r\n\r\n　　.element {\r\nbackground: red; /* modern browsers */\r\n*background: green; /* IE 7 and below */\r\n_background: blue; /* IE6 exclusively */\r\n}\r\n\r\n</div></blockquote>\r\n<strong>12. CSS的优先性</strong>\r\n\r\n如果同一个容器被多条CSS语句定义，那么哪一个定义<a href="http://www.vanseodesign.com/css/css-specificity-inheritance-cascaade/" target="_blank">优先</a>呢？\r\n\r\n基本规则是：\r\n<blockquote>\r\n<div>\r\n\r\n　　行内样式 &gt; id样式 &gt; class样式 &gt; 标签名样式\r\n\r\n</div></blockquote>\r\n比如，有一个元素：\r\n<blockquote>\r\n<div>　　&lt;div id="ID" class="CLASS" style="color:black;"&gt;&lt;/div&gt;</div></blockquote>\r\n行内样式是最优先的，然后其他设置的优先性，从低到高依次为：\r\n<blockquote>\r\n<div>\r\n\r\n　　div &lt; .class &lt; div.class &lt; #id &lt; div#id &lt; #id.class &lt; div#id.class\r\n\r\n</div></blockquote>\r\n<strong>13. IE6的min-height</strong>\r\n\r\nIE6不支持min-height，有两种方法可以解决这个问题：\r\n\r\n方法一：\r\n<blockquote>\r\n<div>\r\n\r\n　　.element {\r\nmin-height: 500px;\r\nheight: auto !important;\r\nheight: 500px;\r\n}\r\n\r\n</div></blockquote>\r\n共有三条CSS语句，第一句是针对其他浏览器设置最小高度，第三句是针对IE设置最小高度，第二句则是让其他浏览器覆盖第三句的设置。\r\n\r\n方法二：\r\n<blockquote>\r\n<div>\r\n\r\n　　.element {\r\nmin-height: 500px\r\n_height: 500px\r\n}\r\n\r\n</div></blockquote>\r\n_height只有IE6能读取。\r\n\r\n<strong>14. font-size基准</strong>\r\n\r\n浏览器的缺省字体大小是16px，你可以先将基准字体大小设为10px：\r\n<blockquote>\r\n<div>\r\n\r\n　　body {font-size:62.5%;}\r\n\r\n</div></blockquote>\r\n后面统一采用em作为字体单位，2.4em就表示24px。\r\n<blockquote>\r\n<div>\r\n\r\n　　h1 {font-size: 2.4 em}\r\n\r\n</div></blockquote>\r\n<strong>15. Text-transform和Font Variant</strong>\r\n\r\nText-transform用于将所有字母变成小写字母、大写字母或首字母大写：\r\n<blockquote>\r\n<div>\r\n\r\n　　p {text-transform: uppercase}\r\np {text-transform: lowercase}\r\np {text-transform: capitalize}\r\n\r\n</div></blockquote>\r\nFont Variant用于将字体变成小型的大写字母（即与小写字母等高的大写字母）。\r\n<blockquote>\r\n<div>\r\n\r\n　　p {font-variant: small-caps}\r\n\r\n</div></blockquote>\r\n<strong>16. CSS重置</strong>\r\n\r\nCSS重置用于取消浏览器的内置样式，请参考<a href="http://developer.yahoo.com/yui/reset/" target="_blank">YUI</a>和<a href="http://meyerweb.com/eric/thoughts/2007/05/01/reset-reloaded/" target="_blank">Eric Meyer</a>的样式表。\r\n\r\n<strong>17. 用图片充当列表标志</strong>\r\n\r\n默认情况下，浏览器使用一个黑圆圈作为列表标志，可以用图片取代它：\r\n<blockquote>\r\n<div>\r\n\r\n　　ul {list-style: none}\r\n\r\nul li {\r\nbackground-image: url("path-to-your-image");\r\nbackground-repeat: none;\r\nbackground-position: 0 0.5em;\r\n}\r\n\r\n</div></blockquote>\r\n<strong>18. 透明</strong>\r\n\r\n将一个容器设为透明，可以使用下面的代码：\r\n<blockquote>\r\n<div>\r\n\r\n　　.element {\r\nfilter:alpha(opacity=50);\r\n-moz-opacity:0.5;\r\n-khtml-opacity: 0.5;\r\nopacity: 0.5;\r\n}\r\n\r\n</div></blockquote>\r\n在这四行CSS语句中，第一行是IE专用的，第二行用于Firefox，第三行用于webkit核心的浏览器，第四行用于Opera。\r\n\r\n<strong>19. CSS三角形</strong>\r\n\r\n如何使用CSS生成一个三角形？\r\n\r\n先编写一个空元素\r\n<blockquote>\r\n<div>\r\n\r\n　　&lt;div class="triangle"&gt;&lt;/div&gt;\r\n\r\n</div></blockquote>\r\n然后，将它四个边框中的三个边框设为透明，剩下一个设为可见，就可以生成三角形效果：\r\n<blockquote>\r\n<div>\r\n\r\n　　.triangle {\r\nborder-color: transparent transparent green transparent;\r\nborder-style: solid;\r\nborder-width: 0px 300px 300px 300px;\r\nheight: 0px;\r\nwidth: 0px;\r\n}\r\n\r\n</div></blockquote>\r\n<strong>20. 禁止自动换行</strong>\r\n\r\n如果你希望文字在一行中显示完成，不要自动换行，CSS命令如下：\r\n<blockquote>\r\n<div>\r\n\r\n　　h1 { white-space:nowrap; }\r\n\r\n</div></blockquote>\r\n<strong>21. 用图片替换文字</strong>\r\n\r\n有时我们需要在标题栏中使用图片，但是又必须保证搜索引擎能够读到标题，CSS语句可以这样写：\r\n<blockquote>\r\n<div>\r\n\r\n　　h1 {\r\ntext-indent:-9999px;\r\nbackground:url("h1-image.jpg") no-repeat;\r\nwidth:200px;\r\nheight:50px;\r\n}\r\n\r\n</div></blockquote>\r\n<strong>22. 获得焦点的表单元素</strong>\r\n\r\n当一个表单元素获得焦点时，可以将其突出显示：\r\n<blockquote>\r\n<div>\r\n\r\n　　input:focus { border: 2px solid green; }\r\n\r\n</div></blockquote>\r\n<strong>23. !important规则</strong>\r\n\r\n多条CSS语句互相冲突时，具有!important的语句将覆盖其他语句。由于IE不支持!important，所以也可以利用它区分不同的浏览器。\r\n<blockquote>\r\n<div>\r\n\r\n　　h1 {\r\ncolor: red !important;\r\ncolor: blue;\r\n}\r\n\r\n</div></blockquote>\r\n上面这段语句的结果是，其他浏览器都显示红色标题，只有IE显示蓝色标题。\r\n\r\n<strong>24. CSS提示框</strong>\r\n\r\n当鼠标移动到链接上方，会自动出现一个提示框。\r\n<blockquote>\r\n<div>\r\n\r\n　　&lt;a class="tooltip" href="#"&gt;链接文字 &lt;span&gt;提示文字&lt;/span&gt;&lt;/a&gt;\r\n\r\n</div></blockquote>\r\nCSS这样写：\r\n<blockquote>\r\n<div>\r\n\r\n　　a.tooltip {position: relative}\r\na.tooltip span {display:none; padding:5px; width:200px;}\r\na:hover {background:#fff;} /*background-color is a must for IE6*/\r\na.tooltip:hover span{display:inline; position:absolute;}\r\n\r\n</div></blockquote>\r\n<strong>25. 固定位置的页首</strong>\r\n\r\n当页面滚动时，有时需要页首在位置固定不变，CSS语句可以这样写，效果参见<a href="http://limpid.nl/lab/css/fixed/header" target="_blank">http://limpid.nl/lab/css/fixed/header</a>：\r\n<blockquote>\r\n<div>\r\n\r\n　　body{ margin:0;padding:100px 0 0 0;}\r\n\r\ndiv#header{\r\nposition:absolute;\r\ntop:0;\r\nleft:0;\r\nwidth:100%;\r\nheight:&lt;length&gt;;\r\n}\r\n\r\n@media screen{\r\nbody&gt;div#header{position: fixed;}\r\n}\r\n\r\n* html body{overflow:hidden;}\r\n\r\n* html div#content{height:100%;overflow:auto;}\r\n\r\n</div></blockquote>\r\nIE6的另一种写法（用于固定位置的页脚）：\r\n<blockquote>　　* html #footer {\r\nposition:absolute;\r\ntop:expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+\'px\');\r\n}</blockquote>\r\n<strong>26. 在IE6中设置PNG图片的透明效果</strong>\r\n<blockquote>　　.classname {\r\n\r\nbackground: url(image.png);\r\n\r\n_background: none;\r\n\r\n_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader\r\n(src=\'image.png\', sizingMethod=\'crop\');\r\n\r\n}</blockquote>\r\n<strong>27. 各类浏览器的专用语句</strong>\r\n<blockquote>　　/* IE6 and below */\r\n* html #uno { color: red }\r\n\r\n/* IE7 */\r\n*:first-child+html #dos { color: red }\r\n\r\n/* IE7, FF, Saf, Opera */\r\nhtml&gt;body #tres { color: red }\r\n\r\n/* IE8, FF, Saf, Opera (Everything but IE 6,7) */\r\nhtml&gt;/**/body #cuatro { color: red }\r\n\r\n/* Opera 9.27 and below, safari 2 */\r\nhtml:first-child #cinco { color: red }\r\n\r\n/* Safari 2-3 */\r\nhtml[xmlns*=""] body:last-child #seis { color: red }\r\n\r\n/* safari 3+, chrome 1+, opera9+, ff 3.5+ */\r\nbody:nth-of-type(1) #siete { color: red }\r\n\r\n/* safari 3+, chrome 1+, opera9+, ff 3.5+ */\r\nbody:first-of-type #ocho { color: red }\r\n\r\n/* saf3+, chrome1+ */\r\n@media screen and (-webkit-min-device-pixel-ratio:0) {\r\n#diez { color: red }\r\n}\r\n\r\n/* iPhone / mobile webkit */\r\n@media screen and (max-device-width: 480px) {\r\n#veintiseis { color: red }\r\n}\r\n\r\n/* Safari 2 - 3.1 */\r\nhtml[xmlns*=""]:root #trece { color: red }\r\n\r\n/* Safari 2 - 3.1, Opera 9.25 */\r\n*|html[xmlns*=""] #catorce { color: red }\r\n\r\n/* Everything but IE6-8 */\r\n:root *&gt; #quince { color: red }\r\n\r\n/* IE7 */\r\n*+html #dieciocho { color: red }\r\n\r\n/* Firefox only. 1+ */\r\n#veinticuatro, x:-moz-any-link { color: red }\r\n\r\n/* Firefox 3.0+ */\r\n#veinticinco, x:-moz-any-link, x:default { color: red }\r\n\r\n/***** Attribute Hacks ******/\r\n\r\n/* IE6 */\r\n#once { _color: blue }\r\n\r\n/* IE6, IE7 */\r\n#doce { *color: blue; /* or #color: blue */ }\r\n\r\n/* Everything but IE6 */\r\n#diecisiete { color/**/: blue }\r\n\r\n/* IE6, IE7, IE8 */\r\n#diecinueve { color: blue\\9; }\r\n\r\n/* IE7, IE8 */\r\n#veinte { color/*\\**/: blue\\9; }\r\n\r\n/* IE6, IE7 -- acts as an !important */\r\n#veintesiete { color: blue !ie; } /* string after ! can be anything */</blockquote>\r\n<strong>28. 容器的水平和垂直居中</strong>\r\n\r\nHTML代码如下：\r\n<blockquote>　　&lt;figure class=\'logo\'&gt;\r\n\r\n&lt;span&gt;&lt;/span&gt;\r\n\r\n&lt;img class=\'photo\'/&gt;\r\n\r\n&lt;/figure&gt;</blockquote>\r\nCSS代码如下：\r\n<blockquote>　　.logo {\r\ndisplay: block;\r\ntext-align: center;\r\ndisplay: block;\r\ntext-align: center;\r\nvertical-align: middle;\r\nborder: 4px solid #dddddd;\r\npadding: 4px;\r\nheight: 74px;\r\nwidth: 74px; }\r\n\r\n.logo * {\r\ndisplay: inline-block;\r\nheight: 100%;\r\nvertical-align: middle; }\r\n\r\n.logo .photo {\r\nheight: auto;\r\nwidth: auto;\r\nmax-width: 100%;\r\nmax-height: 100%; }</blockquote>\r\n<strong>29. CSS阴影</strong>\r\n\r\n外阴影：\r\n<blockquote>　　.shadow {\r\n-moz-box-shadow: 5px 5px 5px #ccc;\r\n-webkit-box-shadow: 5px 5px 5px #ccc;\r\nbox-shadow: 5px 5px 5px #ccc;\r\n}</blockquote>\r\n内阴影：\r\n<blockquote>　　.shadow {\r\n-moz-box-shadow:inset 0 0 10px #000000;\r\n-webkit-box-shadow:inset 0 0 10px #000000;\r\nbox-shadow:inset 0 0 10px #000000;\r\n}</blockquote>\r\n<strong>30. 取消IE文本框的滚动条</strong>\r\n<blockquote>　　textarea { overflow: auto; }</blockquote>\r\n<strong>31. 图片预加载</strong>\r\n\r\n请参考<a href="http://perishablepress.com/press/2009/12/28/3-ways-preload-images-css-javascript-ajax/" target="_blank">3 Ways to Preload Images with CSS, JavaScript, or Ajax</a>。\r\n\r\n<strong>32. CSS重置</strong>\r\n\r\n请参考<a href="http://sixrevisions.com/css/should-you-reset-your-css/" target="_blank">Should You Reset Your CSS?</a>。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','CSS使用技巧','','publish','open','open','','css-cookbook','','','2016-11-01 19:04:48','2016-11-01 11:04:48','',0,'https://blog-scottwang.rhcloud.com/?p=110',0,'post','',0),
 (112,1,'2016-11-01 19:07:03','2016-11-01 11:07:03','from:\r\n<a href="http://www.ruanyifeng.com/blog/2009/01/what_is_a_circle.html">http://www.ruanyifeng.com/blog/2009/01/what_is_a_circle.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n昨天，我读到一篇<a href="http://betterexplained.com/articles/developing-your-intuition-for-math/" target="_blank">文章</a>，很赞同它的观点。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n<blockquote>\r\n<div>\r\n\r\n<strong>科学认识形成于直观的想法，但是最终要用抽象的公式来表达。</strong>\r\n\r\n<strong>Conception is about ideas, but formulas are the way to express them.</strong>\r\n\r\n</div></blockquote>\r\n作者举了一个圆的例子，来说明这一点。\r\n\r\n圆形可能是人类最先认识的形状。我们从直观的体验，就可以马上说出，什么是圆的。比如，苹果是圆的，轮子是圆的，太阳是圆的，等等。\r\n\r\n但是，如果要从学术的角度，严密地定义圆，就不是那么简单了。原作者举出了5种定义，可以看到，随着定义越来越严密，圆形的概念也变得越来越抽象。\r\n\r\n===============\r\n\r\n<strong>定义一：圆是最对称的2维平面图形。</strong>\r\n\r\n通过中心的任意一条直线，都可以将圆形分成完全相等的二部分。\r\n\r\n<img src="http://lh4.ggpht.com/_6p3hNkUNWrQ/SWyMOkohwgI/AAAAAAAAAko/skZh4N4DRlg/s800/bg2009011101.jpg" />\r\n\r\n<strong>定义二：在相同周长的情况下，面积最大的图形就是圆。</strong>\r\n\r\n或者说，在相同面积的情况下，周长最短的图形就是圆。\r\n\r\n有一道常见的面试题，问的是"为什么下水道的盖子是圆的？"理由有两个，一是给定窨井盖的周长，圆形的制造材料是最少的；二是圆的直径都相等，因此不会掉进下水道。\r\n\r\n<img src="http://lh4.ggpht.com/_6p3hNkUNWrQ/SWyMOi1JKxI/AAAAAAAAAkw/sWfniyjUdk0/s800/bg2009011102.jpg" />\r\n\r\n<strong>定义三：任意一条切线，都垂直于"切点的位置向量"的图像就是圆。</strong>\r\n\r\n说实话，这一条好像更像圆的性质，而不像定义。\r\n\r\n<img src="http://lh3.ggpht.com/_6p3hNkUNWrQ/SWyMOo0QdvI/AAAAAAAAAk4/Joj8P-uhsPc/s800/bg2009011105.jpg" />\r\n\r\n<strong>定义四：满足公式x²+y²=r²(r为大于0的已知实数)的所有点（x,y）的集合就是圆。</strong>\r\n\r\n这种定义就是"到定点距离等于定长"的解析几何版本。\r\n\r\n<img src="http://lh4.ggpht.com/_6p3hNkUNWrQ/SWyMOmoxvOI/AAAAAAAAAlA/khCeI4eohXE/s800/bg2009011103.jpg" />\r\n\r\n<strong>定义五：满足x=r*sin(t)、y=r*cos(t)的所有点（x，y）的集合就是圆。（r为大于0的已知实数，t为任意实数。）</strong>\r\n\r\n这种定义给出了圆的参数方程形式。\r\n\r\n<img src="http://lh5.ggpht.com/_6p3hNkUNWrQ/SWyMO_klpqI/AAAAAAAAAlI/8DGa4olGqWg/s800/bg2009011104.jpg" />\r\n\r\n=================\r\n\r\n定义一只是在描述一种形状，到了定义五，就变成在描述一种纯数学关系。越是后面的定义，就越严密和越抽象。这正好同人类对圆的认识历史相一致。\r\n\r\n马克思说过："一种科学只有在成功地运用数学时，才算达到了真正完善的地步。"只有当人类可以用方程来描述圆时，人类对圆的认识才真正地完善。\r\n\r\n在我看来，这是科学发展的一般规律，即<strong>任何一种科学发展到成熟阶段，它的逻辑结构必定可以用数学表达出来。</strong>即使学科本身的内容无法用数学表达，但是至少内容与内容之间的逻辑关系是可以用数学表达的。也就是说，如果一门学科是真正的科学，那么这门学科的结构一定可以被数学化。\r\n\r\n上面所说的"科学"，不仅指自然科学，也包括社会科学。为什么经济学、法学、政治学还不能被说成是真正的科学？一个原因就在于，这些学科本身的逻辑结构还不能用数学表达出来。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','关于圆的定义','','publish','open','open','','about-circle','','','2016-11-01 19:07:03','2016-11-01 11:07:03','',0,'https://blog-scottwang.rhcloud.com/?p=112',0,'post','',0),
 (114,1,'2016-11-01 19:10:08','2016-11-01 11:10:08','from:\r\n<a href="http://www.ruanyifeng.com/blog/2011/07/mathematical_constant_e.html">http://www.ruanyifeng.com/blog/2011/07/mathematical_constant_e.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n1.\r\n\r\ne是一个重要的常数，但是我一直不知道，它的真正含义是什么。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n它不像π。大家都知道，π代表了圆的周长与直径之比3.14159，可是如果我问你，e代表了什么。你能回答吗？\r\n\r\n<a href="http://en.wikipedia.org/wiki/E_(mathematical_constant)" target="_blank">维基百科</a>说：\r\n<blockquote>"e是自然对数的底数。"</blockquote>\r\n但是，你去看<a href="http://en.wikipedia.org/wiki/Natural_logarithm" target="_blank">"自然对数"</a>，得到的解释却是：\r\n<blockquote>"自然对数是以e为底的对数函数，e是一个无理数，约等于2.718281828。"</blockquote>\r\n这就构成了循环定义，完全没有说e是什么。数学家选择这样一个无理数作为底数，还号称这种对数很"自然"，这难道不是很奇怪的事情吗？\r\n\r\n<img src="http://image.beekka.com/blog/201107/bg2011070901.png" />\r\n\r\n2.\r\n\r\n昨天我读到一篇<a href="http://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/" target="_blank">好文章</a>，它把这个问题解释得非常清楚，而且一看就懂。\r\n\r\n它说，什么是e？简单说，<strong>e就是增长的极限。</strong>\r\n\r\n下面就是它的解释。\r\n\r\n3.\r\n\r\n假定有一种单细胞生物，它每过24小时分裂一次。\r\n\r\n那么很显然，这种生物的数量，每天都会翻一倍。今天是1个，明天就是2个，后天就是4个。我们可以写出一个增长数量的公式：\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=growth%3D2%5Ex&amp;chs=30" />\r\n\r\n上式中的x就表示天数。这种生物在x天的总数，就是2的x次方。这个式子可以被改成下面这样：\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=growth%20%3D%20(1%20%2B%20100%25)%5Ex&amp;chs=30" />\r\n\r\n其中，1表示原有数量，100%表示单位时间内的增长率。\r\n\r\n4.\r\n\r\n我们继续假定：每过12个小时，也就是分裂进行到一半的时候，新产生的那半个细胞已经可以再次分裂了。\r\n\r\n因此，一天24个小时可以分成两个阶段，每一个阶段都在前一个阶段的基础上增长50%。\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=growth%3D(1%2B%5Cfrac%7B100%25%7D%7B2%7D)%5E2%3D2.25&amp;chs=50" />\r\n\r\n当这一天结束的时候，我们一共得到了2.25个细胞。其中，1个是原有的，1个是新生的，另外的0.25个是新生细胞分裂到一半的。\r\n\r\n如果我们继续修改假设，这种细胞每过8小时就具备独立分裂的能力，也就是将1天分成3个阶段。\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=growth%3D(1%2B%5Cfrac%7B100%25%7D%7B3%7D)%5E3%3D2.37037...&amp;chs=50" />\r\n\r\n那么，最后我们就可以得到大约2.37个细胞。\r\n\r\n很自然地，如果我们进一步设想，这种分裂是连续不断进行的，新生细胞每分每秒都具备继续分裂的能力，那么一天最多可以得到多少个细胞呢？\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=growth%3D(1%2B%5Cfrac%7B100%25%7D%7Bn%7D)%5En%3D%3F&amp;chs=50" />\r\n\r\n当n趋向无限时，这个式子的极值等于2.718281828...。\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=%5Clim_%7Bn%5Cto%5Cinfty%7D(1%2B%5Cfrac%7B100%25%7D%7Bn%7D)%5En%3D2.718281828...&amp;chs=50" />\r\n\r\n因此，当增长率为100%保持不变时，我们在单位时间内最多只能得到2.71828个细胞。<strong>数学家把这个数就称为e，它的含义是单位时间内，持续的翻倍增长所能达到的极限值。</strong>\r\n\r\n这个值是自然增长的极限，因此以e为底的对数，就叫做自然对数。\r\n\r\n5.\r\n\r\n有了这个值以后，计算银行的复利就非常容易。\r\n\r\n假定有一家银行，每年的复利是100%，请问存入100元，一年后可以拿多少钱？\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=%5Clim_%7Bn%5Cto%5Cinfty%7D100(1%2B%5Cfrac%7B100%25%7D%7Bn%7D)%5En%3D100e%3D271.828...&amp;chs=50" />\r\n\r\n回答就是271.828元，等于100个e。\r\n\r\n但是，实际生活中，银行的利息没有这么高，如果利息率只有5%，那么100元存一年可以拿到多少钱呢？\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=%5Clim_%7Bn%5Cto%5Cinfty%7D100(1%2B%5Cfrac%7B5%25%7D%7Bn%7D)%5En%3D%3F&amp;chs=50" />\r\n\r\n为了便于思考，我们取n等于50：\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=100(1%2B%5Cfrac%7B5%25%7D%7B50%7D)%5E%7B50%7D%3D100(1%2B0.1%25)%5E%7B50%7D&amp;chs=50" />\r\n\r\n我们知道，在100%利息率的情况下，n=1000所得到的值非常接近e：\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=(1%2B%5Cfrac%7B100%25%7D%7B1000%7D)%5E%7B1000%7D%3D(1%2B0.1%25)%5E%7B1000%7D%5Capprox%20e&amp;chs=50" />\r\n\r\n因此，5%利息率就相当于e的20分之一次方：\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=(1%2B%5Cfrac%7B5%25%7D%7B50%7D)%5E%7B50%7D%3D%5B(1%2B%5Cfrac%7B100%25%7D%7B1000%7D)%5E%7B1000%7D%5D%5E%7B%5Cfrac%7B1%7D%7B20%7D%7D%5Capprox%20e%5E%7B%5Cfrac%7B1%7D%7B20%7D%7D&amp;chs=50" />\r\n\r\n20分之一正好等于5%的利率率，所以我们可以把公式改写成：\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=growth%3De%5E%7Brate%7D&amp;chs=25" />\r\n\r\n上式的rate就代表增长率。这说明e可以用于任何增长率的计算，前提是它必须是持续不断的复合式增长。\r\n\r\n6.\r\n\r\n再考虑时间因素，如果把钱在银行里存2年，可以得到多少钱？\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=growth%3D(e%5E%7Br%7D)%5E2%3De%5E%7B2r%7D&amp;chs=30" />\r\n\r\n在时间t的情况下，通用公式就是：\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=growth%3D(e%5E%7Br%7D)%5Et%3De%5E%7Br%5Ccdot%20t%7D%3De%5E%7Brt%7D&amp;chs=30" />\r\n\r\n上式就是计算增长量的万能公式，可以适用于任何时间、任何增长率。\r\n\r\n7.\r\n\r\n回到上面的例子，如果银行的利息率是5%的复利，请问100元存款翻倍需要多少时间？\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=100%5Ccdot%20e%5E%7B5%25t%7D%20%3D%20200&amp;chs=25" />\r\n\r\n计算结果是13.86年：\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=t%3D%5Cfrac%7Bln2%7D%7B5%25%7D%3D%5Cfrac%7B0.693%7D%7B5%25%7D%3D%5Cfrac%7B69.3%7D%7B5%7D%5Capprox%20%5Cfrac%7B72%7D%7B5%7D&amp;chs=50" />\r\n\r\n上式最后一个等号，表明用72除以增长率，可以得到翻倍的大致时间，这就是<a href="http://zh.wikipedia.org/wiki/72%E6%B3%95%E5%89%87" target="_blank">72法则</a>的来源。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','数学常数e的含义','','publish','open','open','','mathematical_constant_e','','','2016-11-01 19:10:08','2016-11-01 11:10:08','',0,'https://blog-scottwang.rhcloud.com/?p=114',0,'post','',0),
 (116,1,'2016-11-01 19:12:02','2016-11-01 11:12:02','from:\r\n<a href="http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html">http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n大多数人在高中，或者大学低年级，都上过一门课《线性代数》。这门课其实是教矩阵。\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090114.jpg" alt="" />\r\n\r\n刚学的时候，还蛮简单的，矩阵加法就是相同位置的数字加一下。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090102.png" alt="" />\r\n\r\n矩阵减法也类似。\r\n\r\n矩阵乘以一个常数，就是所有位置都乘以这个数。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090103.png" alt="" />\r\n\r\n但是，等到矩阵乘以矩阵的时候，一切就不一样了。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090104.png" alt="" />\r\n\r\n这个结果是怎么算出来的？\r\n\r\n教科书告诉你，计算规则是，第一个矩阵第一行的每个数字（2和1），各自乘以第二个矩阵第一列对应位置的数字（1和1），然后将乘积相加（ 2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090105.gif" alt="" />\r\n\r\n也就是说，结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和。\r\n\r\n怎么会有这么奇怪的规则？\r\n\r\n我一直没理解这个规则的含义，导致《线性代数》这门课就没学懂。研究生时发现，线性代数是向量计算的基础，很多重要的数学模型都要用到向量计算，所以我做不了复杂模型。这一直让我有点伤心。\r\n\r\n前些日子，受到<a href="https://nolaymanleftbehind.wordpress.com/2011/07/10/linear-algebra-what-matrices-actually-are/" target="_blank">一篇文章</a>的启发，我终于想通了，矩阵乘法到底是什么东西。关键就是一句话，<strong>矩阵的本质就是线性方程式，两者是一一对应关系。</strong>如果从线性方程式的角度，理解矩阵乘法就毫无难度。\r\n\r\n下面是一组线性方程式。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090106.png" alt="" />\r\n\r\n矩阵的最初目的，只是为线性方程组提供一个简写形式。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090107.png" alt="" />\r\n\r\n老实说，从上面这种写法，已经能看出矩阵乘法的规则了：系数矩阵第一行的2和1，各自与 x 和 y 的乘积之和，等于3。不过，这不算严格的证明，只是线性方程式转为矩阵的书写规则。\r\n\r\n下面才是严格的证明。有三组未知数 x、y 和 t，其中 x 和 y 的关系如下。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090108.png" alt="" />\r\n\r\nx 和 t 的关系如下。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090109.png" alt="" />\r\n\r\n有了这两组方程式，就可以求 y 和 t 的关系。从矩阵来看，很显然，只要把第二个矩阵代入第一个矩阵即可。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090110.png" alt="" />\r\n\r\n从方程式来看，也可以把第二个方程组代入第一个方程组。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090111.png" alt="" />\r\n\r\n上面的方程组可以整理成下面的形式。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090112.png" alt="" />\r\n\r\n最后那个矩阵等式，与前面的矩阵等式一对照，就会得到下面的关系。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090113.png" alt="" />\r\n\r\n矩阵乘法的计算规则，从而得到证明。\r\n<p id="sponsor">=========================================</p>\r\n以下为广告部分。欢迎大家在我的网络日志<a href="http://www.ruanyifeng.com/ads.html" target="_blank">投放广告</a>。\r\n\r\n<strong>[赞助商广告]</strong>\r\n\r\n如果你想换工作，花五分钟，浏览一下 <a href="http://www.100offer.com/join/free?utm_source=ruanyf&amp;utm_medium=essay&amp;utm_campaign=ruanyf&amp;utm_content=daxiaogongsi" target="_blank">100offer</a>，也许人生从此就会不同。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090122.jpg" alt="" />\r\n\r\n<a href="http://www.100offer.com/join/free?utm_source=ruanyf&amp;utm_medium=essay&amp;utm_campaign=ruanyf&amp;utm_content=daxiaogongsi" target="_blank">100offer</a> 的目标是，只要你有2年以上的互联网工作经验（一线互联网公司更好），它就极有可能帮你拿到年薪 20W--80W 的 Offer。\r\n\r\n<img title="" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090121.jpg" alt="" />\r\n\r\n它最近对514位用户的一份<a href="http://100offer.com/blog/posts/96" target="_blank">实证分析</a>，有两点发现。\r\n<blockquote>（1）所有离职的工程师之中，BAT员工最受欢迎，新工作的薪酬通常可以翻番。\r\n\r\n（2）只有40%的程序员跳槽去了C轮、D轮和上市公司，其余60%都去了天使轮、A轮和B轮的公司，其中不乏资深的高级程序员。原因是这些创业公司刚刚起步、产品模式初步得到认可，上升空间大、技术人才需求量大、愿意给出较多的期权。</blockquote>\r\n<img title="" src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/p/blog_100offer_b0_upaiyun_com/05ac5f607ecc4337acd415baf2c63b5e.jpg" alt="" />\r\n\r\n结合上面两点，年青程序员可以这样设计自己的职业生涯：\r\n\r\n<strong>1、至少有一次大公司的成功工作经历。</strong>\r\n\r\n所谓"成功"，是指参与过知名的产品开发或主力项目经验。这一般代表你已经具备：良好的代码规范、团队协作能力、与大牛一起工作的开阔眼界成熟的技术体系。\r\n\r\n<strong>2、然后，加入一家高速发展的创业公司。</strong>\r\n\r\n<a href="http://www.100offer.com/join/free?utm_source=ruanyf&amp;utm_medium=essay&amp;utm_campaign=ruanyf&amp;utm_content=daxiaogongsi" target="_blank">100offer</a> 帮助你实现这条职业道路。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','理解矩阵乘法','','publish','open','open','','matrix-multiplication','','','2016-11-01 19:12:02','2016-11-01 11:12:02','',0,'https://blog-scottwang.rhcloud.com/?p=116',0,'post','',0),
 (118,1,'2016-11-01 19:13:59','2016-11-01 11:13:59','from:\r\n<a href="http://www.ruanyifeng.com/blog/2012/09/imaginary_number.html">http://www.ruanyifeng.com/blog/2012/09/imaginary_number.html</a>\r\n\r\n<article class="hentry">\r\n<h1 id="page-title" class="asset-name entry-title"></h1>\r\n<div class="asset-meta"></div>\r\n<div id="main-content" class="asset-content entry-content">\r\n\r\n<!-- div class="asset-body" -->\r\n\r\n有人在<a href="http://math.stackexchange.com/questions/199676/what-are-imaginary-numbers" target="_blank">Stack Exchange</a>问了一个问题：\r\n\r\n<!-- /div -->\r\n\r\n<!-- div id="more" class="asset-more" -->\r\n<blockquote>　　"我一直觉得虚数（imaginary number）很难懂。\r\n\r\n中学老师说，虚数就是-1的平方根。\r\n\r\n<img style="border: none;" src="http://chart.googleapis.com/chart?cht=tx&amp;chl=i%3D%5Csqrt%7B-1%7D&amp;chs=80" />\r\n\r\n可是，什么数的平方等于-1呢？计算器直接显示出错！\r\n\r\n直到今天，我也没有搞懂。谁能解释，虚数到底是什么？\r\n\r\n它有什么用？"</blockquote>\r\n帖子的下面，很多人给出了自己的解释，还推荐了一篇非常棒的文章<a href="http://betterexplained.com/articles/a-visual-intuitive-guide-to-imaginary-numbers/" target="_blank">《虚数的图解》</a>。我读后恍然大悟，醍醐灌顶，原来虚数这么简单，一点也不奇怪和难懂！\r\n\r\n下面，我就用自己的语言，讲述我所理解的虚数。\r\n\r\n<strong>一、什么是虚数？</strong>\r\n\r\n首先，假设有一根数轴，上面有两个反向的点：+1和-1。\r\n\r\n<img src="http://image.beekka.com/blog/201209/bg2012092401.png" />\r\n\r\n这根数轴的正向部分，可以绕原点旋转。显然，逆时针旋转180度，+1就会变成-1。\r\n\r\n<img src="http://image.beekka.com/blog/201209/bg2012092402.png" />\r\n\r\n这相当于两次逆时针旋转90度。\r\n\r\n<img src="http://image.beekka.com/blog/201209/bg2012092403.png" />\r\n\r\n因此，我们可以得到下面的关系式：\r\n<blockquote>　　(+1) * (逆时针旋转90度) * (逆时针旋转90度) = (-1)</blockquote>\r\n如果把+1消去，这个式子就变为：\r\n<blockquote>　　(逆时针旋转90度)^2 = (-1)</blockquote>\r\n将"逆时针旋转90度"记为 i ：\r\n<blockquote>　　i^2 = (-1)</blockquote>\r\n这个式子很眼熟，它就是虚数的定义公式。\r\n\r\n所以，我们可以知道，<strong>虚数 i 就是逆时针旋转90度，i 不是一个数，而是一个旋转量。</strong>\r\n\r\n<strong>二、复数的定义</strong>\r\n\r\n既然 i 表示旋转量，我们就可以用 i ，表示任何实数的旋转状态。\r\n\r\n<img src="http://image.beekka.com/blog/201209/bg2012092404.png" />\r\n\r\n将实数轴看作横轴，虚数轴看作纵轴，就构成了一个二维平面。旋转到某一个角度的任何正实数，必然唯一对应这个平面中的某个点。\r\n\r\n只要确定横坐标和纵坐标，比如( 1 , i )，就可以确定某个实数的旋转量（45度）。\r\n\r\n数学家用一种特殊的表示方法，表示这个二维坐标：用 + 号把横坐标和纵坐标连接起来。比如，把 ( 1 , i ) 表示成 1 + i 。<strong>这种表示方法就叫做复数（complex number），其中 1 称为实数部，i 称为虚数部。</strong>\r\n\r\n为什么要把二维坐标表示成这样呢，下一节告诉你原因。\r\n\r\n<strong>三、虚数的作用：加法</strong>\r\n\r\n虚数的引入，大大方便了涉及到旋转的计算。\r\n\r\n<img src="http://image.beekka.com/blog/201209/bg2012092405.png" />\r\n\r\n比如，物理学需要计算"力的合成"。假定一个力是 3 + i ，另一个力是 1 + 3i ，请问它们的合成力是多少？\r\n\r\n<img src="http://image.beekka.com/blog/201209/bg2012092406.png" />\r\n\r\n根据"平行四边形法则"，你马上得到，合成力就是 ( 3 + i ) + ( 1 + 3i ) = ( 4 + 4i )。\r\n\r\n这就是虚数加法的物理意义。\r\n\r\n<strong>四、虚数的作用：乘法</strong>\r\n\r\n如果涉及到旋转角度的改变，处理起来更方便。\r\n\r\n<img src="http://image.beekka.com/blog/201209/bg2012092407.png" />\r\n\r\n比如，一条船的航向是 3 + 4i 。\r\n\r\n如果该船的航向，逆时针增加45度，请问新航向是多少？\r\n\r\n<img src="http://image.beekka.com/blog/201209/bg2012092408.png" />\r\n\r\n45度的航向就是 1 + i 。计算新航向，只要把这两个航向 3 + 4i 与 1 + i 相乘就可以了（原因在下一节解释）：\r\n<blockquote>　　( 3 + 4i ) * ( 1 + i ) = ( -1 + 7i )</blockquote>\r\n所以，该船的新航向是 -1 + 7i 。\r\n\r\n如果航向逆时针增加90度，就更简单了。因为90度的航向就是 i ，所以新航向等于：\r\n<blockquote>　　( 3 + 4i ) * i = ( -4 + 3i )</blockquote>\r\n这就是虚数乘法的物理意义：改变旋转角度。\r\n\r\n<strong>五、虚数乘法的数学证明</strong>\r\n\r\n为什么一个复数改变旋转角度，只要做乘法就可以了？\r\n\r\n下面就是它的数学证明，实际上很简单。\r\n\r\n<img src="http://image.beekka.com/blog/201209/bg2012092409.png" />\r\n\r\n任何复数 a + bi，都可以改写成旋转半径 r 与横轴夹角 θ 的形式。\r\n\r\n假定现有两个复数 a + bi 和 c + di，可以将它们改写如下：\r\n<blockquote>　　a + bi = r1 * ( cosα + isinα )\r\n\r\nc + di = r2 * ( cosβ + isinβ )</blockquote>\r\n<!--\r\n\r\n<img src="http://chart.googleapis.com/chart?cht=tx&chl=a%2Bbi%3Dr_%7B1%7D(cos%5Ctheta_%7B1%7D%20%2B%20isin%5Ctheta_%7B1%7D)&chs=50" style="border:none;" />\r\n\r\n<img src="http://chart.googleapis.com/chart?cht=tx&chl=c%2Bdi%3Dr_%7B2%7D(cos%5Ctheta_%7B2%7D%20%2B%20isin%5Ctheta_%7B2%7D)&chs=50" style="border:none;" />\r\n\r\n-->\r\n\r\n这两个复数相乘，( a + bi )( c + di ) 就相当于\r\n<blockquote>　　r1 * r2 * ( cosα + isinα ) * ( cosβ + isinβ )</blockquote>\r\n<!--<img src="http://chart.googleapis.com/chart?cht=tx&chl=r_%7B1%7Dr_%7B2%7D(cos%5Ctheta_%7B1%7D%20%2B%20isin%5Ctheta_%7B1%7D)(cos%5Ctheta_%7B2%7D%20%2B%20isin%5Ctheta_%7B2%7D)&chs=50" style="border:none;" />-->\r\n\r\n展开后面的乘式，得到\r\n<blockquote>　　cosα * cosβ - sinα * sinβ + i( cosα * sinβ + sinα * cosβ )</blockquote>\r\n<!--<img src="http://chart.googleapis.com/chart?cht=tx&chl=cos%5Ctheta_%7B1%7Dcos%5Ctheta_%7B2%7D-sin%5Ctheta_%7B1%7Dsin%5Ctheta_%7B2%7D%2Bi(sin%5Ctheta_%7B1%7Dcos%5Ctheta_%7B2%7D%2Bcos%5Ctheta_%7B1%7Dsin%5Ctheta_%7B2%7D)&chs=40" style="border:none;" />-->\r\n\r\n根据三角函数公式，上面的式子就等于\r\n<blockquote>　　cos(α+β) + isin(α+β)</blockquote>\r\n<!--<img src="http://chart.googleapis.com/chart?cht=tx&chl=cos(%5Ctheta_%7B1%7D%2B%5Ctheta_%7B2%7D)%2Bisin(%5Ctheta_%7B1%7D%2B%5Ctheta_%7B2%7D)&chs=40" style="border:none;" />-->\r\n\r\n所以，\r\n<blockquote>　　( a + bi )( c + di )　＝　r1 * r2 * ( cos(α+β) + isin(α+β) )</blockquote>\r\n<!-- <img src="http://chart.googleapis.com/chart?cht=tx&chl=(a%2Bbi)(c%2Bdi)%3Dr_%7B1%7Dr_%7B2%7D(cos(%5Ctheta_%7B1%7D%2B%5Ctheta_%7B2%7D)%2Bisin(%5Ctheta_%7B1%7D%2B%5Ctheta_%7B2%7D))&chs=40" style="border:none;" />-->\r\n\r\n这就证明了，两个复数相乘，就等于旋转半径相乘、旋转角度相加。\r\n\r\n（完）\r\n\r\n</div>\r\n</article>','虚数的意义','','publish','open','open','','imaginary-number','','','2016-11-01 19:13:59','2016-11-01 11:13:59','',0,'https://blog-scottwang.rhcloud.com/?p=118',0,'post','',0);

SET FOREIGN_KEY_CHECKS = 1 ; 
COMMIT ; 
SET AUTOCOMMIT = 1 ; 
